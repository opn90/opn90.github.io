

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="SSM框架 - Spring">
  <meta name="author" content="OPN">
  <meta name="keywords" content="">
  
  <title>SSM - Spring - OPN&#39;S BLOG</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"opn90.top","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":3},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong> OPN'S BLOG </strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="SSM - Spring">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-01-27 11:11" pubdate>
        2023年1月27日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      81
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">SSM - Spring</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：14 天前
                
              </p>
            
            <div class="markdown-body">
              <p>SSM框架 - Spring</p>
<span id="more"></span>

<p><a target="_blank" rel="noopener" href="https://spring.io/">https://spring.io</a></p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>Spring技术是JavaEE开发必备技能，企业开发技术选型命中率&gt;90%</p>
<ul>
<li>简化开发，降低企业级开发的复杂性</li>
<li>框架整合，高效整合其他技术，提高企业级应用开发与运行效率</li>
</ul>
<p>简化开发</p>
<p>IoC<br>AoP<br>（事务处理 ） </p>
<p>框架整合</p>
<p>MyBatis<br>……</p>
<h1 id="Spring-Framework系统架构"><a href="#Spring-Framework系统架构" class="headerlink" title="Spring Framework系统架构"></a>Spring Framework系统架构</h1><p><img src="/2023/01/27/SSM/ssm-1.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="IoC-控制反转"><a href="#IoC-控制反转" class="headerlink" title="IoC 控制反转"></a>IoC 控制反转</h3><ul>
<li>Inversion of Control 控制反转</li>
</ul>
<p>对象的创建控制权由程序转移到外部，这种思想称之为控制反转</p>
<p>使用对象时，由主动new产生对象转换为由外部提供对象</p>
<ul>
<li>IoC容器</li>
</ul>
<p>IoC容器，充当IoC思想中的—外部</p>
<ul>
<li>Bean</li>
</ul>
<p>IoC容器负责对象的创建，初始化等一系列工作，被创建或者被管理的对象在IoC容器中统称为—Bean</p>
<h3 id="DI-依赖注入"><a href="#DI-依赖注入" class="headerlink" title="DI 依赖注入"></a>DI 依赖注入</h3><ul>
<li>Dependency Injection 依赖注入</li>
</ul>
<p>在容器中建立bean与bean之间的依赖关系的整个过程，称之为依赖注入</p>
<h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p>使用对象时，不仅可以直接从IoC容器中获取，并且获取到的bean已经绑定了所有的依赖关系</p>
<h3 id="IoC入门案例"><a href="#IoC入门案例" class="headerlink" title="IoC入门案例"></a>IoC入门案例</h3><p>1、导入Spring坐标</p>
<p>pom.xml</p>
<div class="hljs code-wrapper"><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre></div>
<p>2、定义Spring管理的类（接口）</p>
<div class="hljs code-wrapper"><pre><code>两个接口iocdemo1，iocdemo2
仅包含save方法的声明
两个实现类，iocdemo1_1,iocdemo2_1

..........

public class iocdemo1_1 implements iocdemo1 &#123;
    public void save()&#123;
        System.out.println(&quot;this is demo1-1&quot;);
    &#125;
&#125;

public class iocdemo2_1 implements iocdemo2 &#123;
    iocdemo1_1 demo1 = new iocdemo1_1();
    public void save()&#123;
        System.out.println(&quot;this is demo2-1&quot;);
        demo1.save();
    &#125;
&#125;
</code></pre></div>
<p>3、在resources中，新建xml配置文件，Spring配置，（applicationContext.xml），配置对应类作为Spring管理的bean</p>
<div class="hljs code-wrapper"><pre><code>&lt;bean id=&quot;demo2&quot; class=&quot;com.opn.web.iocdemo2_1&quot;&gt;&lt;/bean&gt;
</code></pre></div>
<p>4、初始化IoC容器，通过容器获取bean</p>
<div class="hljs code-wrapper"><pre><code>//效果相同

    iocdemo2_1 demo2 = new iocdemo2_1();
    demo2.save();

    System.out.println(&quot;--------------------------&quot;);

    //获取IoC容器
    ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);

    //获取资源
    iocdemo2_1 demo2_2 = (iocdemo2_1)ctx.getBean(&quot;demo2&quot;);

    demo2_2.save();
</code></pre></div>
<h3 id="DI入门案例"><a href="#DI入门案例" class="headerlink" title="DI入门案例"></a>DI入门案例</h3><p>1、删除业务层中使用new的方式创建的对象</p>
<p>2、提供对应的set方法</p>
<p>3、在配置中构建关系</p>
<div class="hljs code-wrapper"><pre><code>public class iocdemo2_1 implements iocdemo2 &#123;
    //删除业务层中使用new的方式创建的对象
    iocdemo1_1 demo1;
    public void save()&#123;
        System.out.println(&quot;this is demo2-1&quot;);
        demo1.save();
    &#125;
    //提供对应的set方法
    public void setDemo1(iocdemo1_1 demo)&#123;
        this.demo1 = demo;
    &#125;
&#125;



&lt;bean id=&quot;demo2&quot; class=&quot;com.opn.web.iocdemo2_1&quot;&gt;
    &lt;!--配置iocdemo1_1和iocdemo2_1的关系
        name属性表示配置哪一个具体的属性
        ref属性表示参照哪一个bean--&gt;
    &lt;property name=&quot;demo1&quot; ref=&quot;demo1&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;demo1&quot; class=&quot;com.opn.web.iocdemo1_1&quot;&gt;&lt;/bean&gt;



//获取IoC容器
    ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);

    //获取资源
    iocdemo2_1 demo2_2 = (iocdemo2_1)ctx.getBean(&quot;demo2&quot;);
    demo2_2.save();
</code></pre></div>
<p><img src="/2023/01/27/SSM/ssm-2.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h1><h3 id="bean基础配置"><a href="#bean基础配置" class="headerlink" title="bean基础配置"></a>bean基础配置</h3><ul>
<li>别名</li>
</ul>
<p>name 可用,;(空格)多个间隔</p>
<p>可用在ref上</p>
<div class="hljs code-wrapper"><pre><code>&lt;bean id=&quot;&quot; name=&quot;&quot;class=&quot;&quot;&gt;
</code></pre></div>
<ul>
<li>单例</li>
</ul>
<p>多个对象地址相同—一个对象</p>
<p>非单例</p>
<p>地址不同多个对象</p>
<div class="hljs code-wrapper"><pre><code>//单例（默认）
&lt;bean ... scope=&quot;singleton&quot;&gt;
//非单例
&lt;bean ... scope=&quot;prototype&quot;&gt;
</code></pre></div>
<ul>
<li>适合交给容器进行管理的bean</li>
</ul>
<p>表现层对象<br>业务层对象<br>数据层对象<br>工具对象</p>
<ul>
<li>不适合交给容器进行管理的bean</li>
</ul>
<p>封装实体的域对象</p>
<h1 id="实例化bean的三种方式"><a href="#实例化bean的三种方式" class="headerlink" title="实例化bean的三种方式"></a>实例化bean的三种方式</h1><h3 id="bean实例化-—-构造方法"><a href="#bean实例化-—-构造方法" class="headerlink" title="bean实例化 — 构造方法"></a>bean实例化 — 构造方法</h3><p>bean本质是对象，创建bean使用构造方法完成</p>
<p><init>()</init></p>
<p>spring创建bean的时候，调用的是无参数的构造方法</p>
<p>没有无参构造方法报错</p>
<div class="hljs code-wrapper"><pre><code>&lt;!--方式一：构造方法实例化bean--&gt;

&lt;bean id=&quot;user&quot; class=&quot;com.opn.web.user&quot;/&gt;
</code></pre></div>
<h3 id="bean实例化-—-静态工厂"><a href="#bean实例化-—-静态工厂" class="headerlink" title="bean实例化 — 静态工厂"></a>bean实例化 — 静态工厂</h3><p>静态工厂</p>
<p>不使用new</p>
<p>在factory类中，定义getxxx()方法return new xxx类</p>
<p>实例化时，类 实例名 = 类工厂.get类();</p>
<div class="hljs code-wrapper"><pre><code>factory类

public class userFactory&#123;
    public static user getuser()&#123;
        return new user();
    &#125;
&#125;

实例化

user user1 = userFactory.getuser();
</code></pre></div>
<hr>
<div class="hljs code-wrapper"><pre><code>&lt;!--方式二：使用静态工厂实例化bean
    factory-method，使用工厂的哪个类实例化对象
--&gt;

&lt;bean id=&quot;user&quot; class=&quot;com.opn.factory.userfactory&quot; factory-method=&quot;getuser&quot;/&gt;
</code></pre></div>
<h3 id="bean实例化-—-实例工厂"><a href="#bean实例化-—-实例工厂" class="headerlink" title="bean实例化 — 实例工厂"></a>bean实例化 — 实例工厂</h3><p>在factory类中，getxxx()方法 为非静态方法，</p>
<p>创建对象时，需要先将工厂类实例化，再使用getxxx()方法，进行创建</p>
<div class="hljs code-wrapper"><pre><code>factory类

public class userFactory&#123;
    public user getuser()&#123;
        return new user();
    &#125;
&#125;

实例化

userFactory factory1 = new userFactory();
user user1 = factory1.getuser();
</code></pre></div>
<hr>
<div class="hljs code-wrapper"><pre><code>&lt;!--方式三：使用实例工厂实例化bean
    先bean实例工厂
    再bean对象，factory-method工厂方法，factory-bean工厂的bean
--&gt;

&lt;bean id=&quot;userfactory&quot; class=&quot;com.opn.factory.userfactory&quot;/&gt;

&lt;bean id=&quot;userfactory&quot; factory-method=&quot;getuser&quot; factory-bean=&quot;userfactory&quot;/&gt;
</code></pre></div>
<h3 id="bean实例化-—-FactoryBean"><a href="#bean实例化-—-FactoryBean" class="headerlink" title="bean实例化 — FactoryBean"></a>bean实例化 — FactoryBean</h3><p>创建类FactoryBean</p>
<div class="hljs code-wrapper"><pre><code>//&lt;T&gt; 泛型 中 填写 需要实例化的类
public class iocdemo2_1FactoryBean implements FactoryBean&lt;iocdemo2_1&gt; &#123;

    @Override
    public iocdemo2_1 getObject() throws Exception &#123;
        //返回需要实例化的类
        return new iocdemo2_1();
    &#125;

    @Override
    public Class&lt;?&gt; getObjectType() &#123;
        //返回需要的类的类型
        return iocdemo2_1.class;
    &#125;

    //改变方法的返回值，改变单例模式
    @Override
    public boolean isSingleton() &#123;
        return FactoryBean.super.isSingleton();
    &#125;

&#125;
</code></pre></div>
<p>配置bean</p>
<div class="hljs code-wrapper"><pre><code>&lt;!--方式四：使用FactoryBean实例化bean--&gt;

&lt;bean id=&quot;iocdemo2_1&quot; class=&quot;com.opn.web.iocdemo2_1FactoryBean&quot;&gt;
</code></pre></div>
<h3 id="bean生命周期"><a href="#bean生命周期" class="headerlink" title="bean生命周期"></a>bean生命周期</h3><p>生命周期：从创建到消亡的完整过程</p>
<p>bean生命周期：bean从创建到销毁的整体过程</p>
<p>bean生命周期控制：在bean创建后到销毁前做一些事情</p>
<p>初始化容器</p>
<ol>
<li>创建对象（内存分配）</li>
<li>执行构造方法</li>
<li>执行属性执行（set方法，为属性赋值）</li>
<li>执行bean初始化方法</li>
</ol>
<hr>
<p>bean配置方式</p>
<div class="hljs code-wrapper"><pre><code>//初始化对应的的操作
public void init()
&#123;&#125;

//销毁前对应的操作
public void destory()
&#123;&#125;


&lt;bean id=&quot;&quot; class=&quot;&quot; init-method=&quot;init&quot; destory-method=&quot;destory&quot;&gt;
</code></pre></div>
<p>如果需要执行销毁方法，要关闭容器</p>
<p>close()/registerShutdownHook()</p>
<p>关闭容器(父类–ConfigurableApplicationContext)/关闭钩子</p>
<hr>
<p>接口方式</p>
<p>官方接口 InitializingBean, DisposableBean</p>
<div class="hljs code-wrapper"><pre><code>public class iocdemo2_1 implements iocdemo , InitializingBean, DisposableBean &#123;

    ......

    //销毁
    @Override
    public void destroy() throws Exception &#123;
    &#125;
    
    //初始化 --- 属性初始化之后运行
    @Override
    public void afterPropertiesSet() throws Exception &#123;
    &#125;
&#125;
</code></pre></div>
<hr>
<h1 id="DI注入方式"><a href="#DI注入方式" class="headerlink" title="DI注入方式"></a>DI注入方式</h1><p>注入方式—</p>
<p>setter注入</p>
<p>构造器注入/构造方法注入</p>
<p>对象关联的属性—</p>
<p>引用类型</p>
<p>简单类型</p>
<p><img src="/2023/01/27/SSM/SSM-3.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h3><p>用set方法为变量赋值</p>
<div class="hljs code-wrapper"><pre><code>public class booker&#123;
    private book b;
    public setbooker()
    &#123;
        b = new book();
    &#125;
&#125;
</code></pre></div>
<ul>
<li>引用类型</li>
</ul>
<p>在bean中定义引用类型属性并提供可访问的set方法</p>
<p>配置中使用property标签ref属性注入引用类型对象</p>
<div class="hljs code-wrapper"><pre><code>&lt;bean id=&quot;&quot;    class=&quot;&quot;&gt;
    //实参b
    &lt;property name=&quot;实参名&quot; ref=&quot;&quot;/&gt;
&lt;/bean&gt;
</code></pre></div>
<ul>
<li>简单类型</li>
</ul>
<p>在bean中定义简单类型属性并提供可访问的set方法</p>
<p>配置中使用property标签value属性注入简单类型数据</p>
<div class="hljs code-wrapper"><pre><code>&lt;bean id=&quot;&quot;    class=&quot;&quot;&gt;
    //实参b
    &lt;property name=&quot;实参名&quot; value=&quot;&quot;/&gt;
&lt;/bean&gt;
</code></pre></div>
<h3 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h3><h5 id="标准书写"><a href="#标准书写" class="headerlink" title="标准书写"></a>标准书写</h5><p>用构造方法为变量赋值</p>
<div class="hljs code-wrapper"><pre><code>public class booker&#123;
    private book b;
    public booker(book a)
    &#123;
        this.b = a;
    &#125;
&#125;
</code></pre></div>
<ul>
<li>引用类型</li>
</ul>
<p>在bean中不定义set方法</p>
<p>配置中使用property标签ref属性注入引用类型对象</p>
<div class="hljs code-wrapper"><pre><code>&lt;bean id=&quot;&quot;    class=&quot;&quot;&gt;
    //形参a
    &lt;constructor-arg name=&quot;形参名&quot; ref=&quot;&quot;/&gt;
&lt;/bean&gt;
</code></pre></div>
<ul>
<li>简单类型</li>
</ul>
<p>在bean中定义简单类型属性并提供可访问的set方法</p>
<p>配置中使用property标签value属性注入简单类型数据</p>
<div class="hljs code-wrapper"><pre><code>&lt;bean id=&quot;&quot;    class=&quot;&quot;&gt;
    //形参a
    &lt;constructor-arg name=&quot;形参名&quot; value=&quot;&quot;/&gt;
&lt;/bean&gt;
</code></pre></div>
<hr>
<h5 id="参数适配"><a href="#参数适配" class="headerlink" title="参数适配"></a>参数适配</h5><p>type属性设置形参类型注入</p>
<div class="hljs code-wrapper"><pre><code>&lt;constructor-arg type=&quot;int&quot; value=&quot;&quot;/&gt;
</code></pre></div>
<p>index属性设置形参位置注入</p>
<div class="hljs code-wrapper"><pre><code>&lt;constructor-arg index=&quot;0&quot; value=&quot;&quot;/&gt;
</code></pre></div>
<h3 id="依赖注入方式选择"><a href="#依赖注入方式选择" class="headerlink" title="依赖注入方式选择"></a>依赖注入方式选择</h3><p>强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现</p>
<p>可选依赖使用setter注入进行，灵活性强</p>
<p>Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨</p>
<p>如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入</p>
<p>实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入</p>
<p>自己开发的模块推荐使用setter注入</p>
<h3 id="依赖自动装配"><a href="#依赖自动装配" class="headerlink" title="依赖自动装配"></a>依赖自动装配</h3><p>IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称之为自动装配</p>
<p>自动装配方法</p>
<p>按类型</p>
<div class="hljs code-wrapper"><pre><code>提供set方法，bean唯一 

autowire=&quot;byType&quot;
</code></pre></div>
<p>按名称</p>
<div class="hljs code-wrapper"><pre><code>提供set方法，bean指定名称

autowire=&quot;byName&quot;
</code></pre></div>
<p>特征</p>
<p>自动装配用于引用类型依赖注入，不能对简单类型进行操作</p>
<p>使用按类型装配时（ byType )必须保障容器中相同类型的bean唯一，推荐使用</p>
<p>使用按名称装配时 ( byName )必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</p>
<p>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效</p>
<h3 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h3><p>数组array、列表list、集合set、</p>
<div class="hljs code-wrapper"><pre><code>&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;
    //(变量名)
    &lt;property name=&quot;array/list/set&quot;&gt;
        //(数据类型)
        &lt;array/list/set&gt;
            &lt;value&gt;...&lt;/value&gt;
        &lt;/array/list/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre></div>
<p>字典map</p>
<div class="hljs code-wrapper"><pre><code>&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;
    //(变量名)
    &lt;property name=&quot;map&quot;&gt;
        //(数据类型)
        &lt;map&gt;
            &lt;entry key=&quot;&quot; value=&quot;&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre></div>
<p>属性文件/配置文件properties</p>
<div class="hljs code-wrapper"><pre><code>&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;
    //(变量名)
    &lt;property name=&quot;properties&quot;&gt;
        //(数据类型)
        &lt;props&gt;
            &lt;prop key=&quot;&quot;&gt;--(value)--&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre></div>
<h3 id="管理第三方bean-—-数据源对象管理"><a href="#管理第三方bean-—-数据源对象管理" class="headerlink" title="管理第三方bean — 数据源对象管理"></a>管理第三方bean — 数据源对象管理</h3><p>查找其构造、set方法，赋相应值</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Fi4y1S7ix?p=17">https://www.bilibili.com/video/BV1Fi4y1S7ix?p=17</a></p>
<h3 id="使用Spring加载properties文件"><a href="#使用Spring加载properties文件" class="headerlink" title="使用Spring加载properties文件"></a>使用Spring加载properties文件</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Fi4y1S7ix?p=18">https://www.bilibili.com/video/BV1Fi4y1S7ix?p=18</a></p>
<p><img src="/2023/01/27/SSM/ssm-4.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h3 id="加载配置文件方式"><a href="#加载配置文件方式" class="headerlink" title="加载配置文件方式"></a>加载配置文件方式</h3><p>1、类路径加载配置文件</p>
<div class="hljs code-wrapper"><pre><code>ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
</code></pre></div>
<p>2、文件路径加载配置文件</p>
<div class="hljs code-wrapper"><pre><code>//绝对路径
ApplicationContext ctx2 = new FileSystemXmlApplicationContext(&quot;&quot;);
</code></pre></div>
<p>3、加载多个配置文件</p>
<div class="hljs code-wrapper"><pre><code>ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;,&quot;bean2.xml&quot;);
</code></pre></div>
<h3 id="加载bean的方式"><a href="#加载bean的方式" class="headerlink" title="加载bean的方式"></a>加载bean的方式</h3><div class="hljs code-wrapper"><pre><code>1、使用bean名称获取

User user1 = (User) ctx.getBean(&quot;user&quot;);

2、使用bean名称获取并指定类型
    
User user1 = ctx.getBean(&quot;user&quot;,User.class);

3、使用bean类型获取    

//按类型区分，该类型只能存在一个bean
User user1 = ctx.getBean(User.class);
</code></pre></div>
<h3 id="BeanFactory创建容器"><a href="#BeanFactory创建容器" class="headerlink" title="BeanFactory创建容器"></a>BeanFactory创建容器</h3><p>过时技术…</p>
<p>BeanFactory创建完毕后，所有的bean均为延迟加载</p>
<h3 id="容器类层次结构图"><a href="#容器类层次结构图" class="headerlink" title="容器类层次结构图"></a>容器类层次结构图</h3><p><img src="/2023/01/27/SSM/ssm-5.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="核心容器总结"><a href="#核心容器总结" class="headerlink" title="核心容器总结"></a>核心容器总结</h1><p>BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载</p>
<p>ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载</p>
<p>ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能ApplicationContext接口常用初始化类</p>
<p>classPathXmlApplicationContext</p>
<p>FileSystemXmlApplicationContext</p>
<h1 id="bean相关总结"><a href="#bean相关总结" class="headerlink" title="bean相关总结"></a>bean相关总结</h1><p><img src="/2023/01/27/SSM/ssm-6.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="依赖注入相关总结"><a href="#依赖注入相关总结" class="headerlink" title="依赖注入相关总结"></a>依赖注入相关总结</h1><p><img src="/2023/01/27/SSM/ssm-7.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h1><h3 id="注解开发定义bean"><a href="#注解开发定义bean" class="headerlink" title="注解开发定义bean"></a>注解开发定义bean</h3><p>@Component</p>
<div class="hljs code-wrapper"><pre><code>在类前，加注解指定名称/id

@Component(&quot;user&quot;)

在配置文件中，扫描文件夹中的类，子类

&lt;context:component-scan base-package=&quot;com.opn&quot;&gt;
</code></pre></div>
<p>@Controller<br>@Service<br>@Repository  </p>
<h3 id="纯注解开发"><a href="#纯注解开发" class="headerlink" title="纯注解开发"></a>纯注解开发</h3><p>Spring3.0升级了纯注解开发模式，使用]ava类替代配置文件，开启了Spring快速开发赛道</p>
<p>使用Java类代替Spring核心配置文件</p>
<p>@Configuration注解用于设定当前类为配置类</p>
<p>@ComponentScan注解用于设定扫描路径，此注解只能添加一次，多个数据用数组格式</p>
<div class="hljs code-wrapper"><pre><code>//配置类

@Configuration
@ComponentScan(&quot;com.opn&quot;)
public class SpringConfig &#123;
&#125;
</code></pre></div>
<p>从读取配置文件—&gt; 读取配置类</p>
<div class="hljs code-wrapper"><pre><code>//实现

ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class)
</code></pre></div>
<h3 id="bean管理"><a href="#bean管理" class="headerlink" title="bean管理"></a>bean管理</h3><p>单例模式</p>
<div class="hljs code-wrapper"><pre><code>@Scope(&quot;singleton&quot;)
</code></pre></div>
<p>非单例模式</p>
<div class="hljs code-wrapper"><pre><code>@Scpoe(&quot;prototype&quot;)
</code></pre></div>
<p>生命周期</p>
<p>构造方法后—构造方法</p>
<div class="hljs code-wrapper"><pre><code>@PostConstruct
public void init()  &#123;
&#125;
</code></pre></div>
<p>销毁前—销毁构造方法</p>
<div class="hljs code-wrapper"><pre><code>@PreDestroy
public void destory() &#123;
&#125;
</code></pre></div>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><h5 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h5><p>默认按照类型装配，类内仅仅存在一个关系</p>
<p>写在类中</p>
<p>@Autowired</p>
<div class="hljs code-wrapper"><pre><code>@Autowired
private User user;
</code></pre></div>
<p>指定对应bean的名称</p>
<p>@Qualifier</p>
<div class="hljs code-wrapper"><pre><code>@Autowired
@Qualifier(&quot;UserService&quot;)
private User user;
</code></pre></div>
<p>@Qualifier注解无法单独使用，必须配合@Autowired注解使用</p>
<h5 id="简单类型注入"><a href="#简单类型注入" class="headerlink" title="简单类型注入"></a>简单类型注入</h5><p>@Value()</p>
<div class="hljs code-wrapper"><pre><code>@Value(&quot;909090&quot;)
private String username;
</code></pre></div>
<h5 id="加载外部properties文件"><a href="#加载外部properties文件" class="headerlink" title="加载外部properties文件"></a>加载外部properties文件</h5><p>@PropertySource(“jdbc.properties”)</p>
<div class="hljs code-wrapper"><pre><code>jdbc.properties

username=this_is_username

配置类

@Configuration
@ComponentScan(&quot;com.opn&quot;)
@PropertySource(&quot;jdbc.properties&quot;)
public class SpringConfig &#123;
&#125;

bean类

@Value(&quot;$&#123;username&#125;&quot;)
private String username;
</code></pre></div>
<h3 id="第三方bean管理"><a href="#第三方bean管理" class="headerlink" title="第三方bean管理"></a>第三方bean管理</h3><p>@Bean</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Fi4y1S7ix/?p=25">https://www.bilibili.com/video/BV1Fi4y1S7ix/?p=25</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Fi4y1S7ix/?p=26">https://www.bilibili.com/video/BV1Fi4y1S7ix/?p=26</a></p>
<p>新创建独立 JdbcConfig 配置类</p>
<ul>
<li>方式一：导入式</li>
</ul>
<p>将独立的配置类导入核心配置</p>
<div class="hljs code-wrapper"><pre><code>public class JdbcConfig &#123;
    
    @Bean
    public DataSource dataSource()&#123;
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(username);
        ds.setPassword(password);
        return ds;
    &#125;
&#125;

使用@Import注解手动加入配置类到核心配置，此注解只能添加一次，多个数据使用数组形式

@Configuration
@Import(JdbcConfig.class)
public class SpringConfig&#123;

&#125;
</code></pre></div>
<ul>
<li>方式二：扫描式</li>
</ul>
<p>直接将独立配置类加入核心配置</p>
<div class="hljs code-wrapper"><pre><code>@Configuration
public class JdbcConfig &#123;
    
    @Bean
    public DataSource dataSource()&#123;
        DruidDataSource ds = new DruidDataSource();
        ...
        return ds;
    &#125;
&#125;

使用@ComponentScan注解扫描配置类所在包，加载对应的配置信息

@Configuration
@ComponentScan(&#123;&quot;com.opn.config&quot;,&quot;&quot;,&quot;&quot;&#125;)
public class SpringConfig&#123;

&#125;
</code></pre></div>
<h3 id="第三方bean管理-注入"><a href="#第三方bean管理-注入" class="headerlink" title="第三方bean管理 - 注入"></a>第三方bean管理 - 注入</h3><ul>
<li><p>简单类型</p>
<p>  @Value(“username”)<br>  private String username;</p>
</li>
<li><p>引用类型</p>
</li>
</ul>
<p>给个形参</p>
<p>引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象</p>
<div class="hljs code-wrapper"><pre><code>    @Bean
    public DataSource dataSource(User user)&#123;
        sout(user);
    &#125;
</code></pre></div>
<h3 id="注解开发总结"><a href="#注解开发总结" class="headerlink" title="注解开发总结"></a>注解开发总结</h3><p>xml配置和注解配置</p>
<p><img src="/2023/01/27/SSM/ssm-8.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="Spring整合MyBatis"><a href="#Spring整合MyBatis" class="headerlink" title="Spring整合MyBatis"></a>Spring整合MyBatis</h1><h3 id="MyBatis基础流程"><a href="#MyBatis基础流程" class="headerlink" title="MyBatis基础流程"></a>MyBatis基础流程</h3><div class="hljs code-wrapper"><pre><code>//1、创建SqlSessionFactoryBuilder对象
SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();

//2、加载SqlMapConfig.xml配置文件
InputStream inputStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);

//3、创建SqlSessionFactory对象
SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);

//4、获取SqlSession
SqlSession sqlSession = sqlSessionFactory.openSession();
    
//5、执行SqlSession对象执行查询，获取结果User
User user = sqlSession.getMapper(User.class);

...

//6、释放资源
sqlSession.close();
</code></pre></div>
<p><img src="/2023/01/27/SSM/ssm-12.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="Spring-MyBatis注解-没有实现类"><a href="#Spring-MyBatis注解-没有实现类" class="headerlink" title="Spring+MyBatis注解 没有实现类"></a>Spring+MyBatis注解 没有实现类</h3><p><a target="_blank" rel="noopener" href="https://www.bbsmax.com/A/QW5YWKD9zm/">https://www.bbsmax.com/A/QW5YWKD9zm/</a></p>
<p><img src="/2023/01/27/SSM/ssm-13.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="整合Druid-MyBatis"><a href="#整合Druid-MyBatis" class="headerlink" title="整合Druid,MyBatis"></a>整合Druid,MyBatis</h3><p><img src="/2023/01/27/SSM/ssm-14.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/2023/01/27/SSM/ssm-15.png" srcset="/img/loading.gif" lazyload></p>
<p>所用Maven</p>
<div class="hljs code-wrapper"><pre><code>    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;version&gt;3.5.5&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
        &lt;version&gt;1.3.0&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre></div>
<p>domain 数据表/bean</p>
<p>dao 数据访问层 使用注解形式自动配置</p>
<p>JdbcConfig bean</p>
<div class="hljs code-wrapper"><pre><code>public class JdbcConfig &#123;
    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)
    private String driver;

    @Value(&quot;$&#123;jdbc.url&#125;&quot;)
    private String url;

    @Value(&quot;$&#123;jdbc.username&#125;&quot;)
    private String username;

    @Value(&quot;$&#123;jdbc.password&#125;&quot;)
    private String password;

    @Bean
    public DataSource dataSource()&#123;
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(username);
        ds.setPassword(password);
           return ds;
    &#125;
&#125;
</code></pre></div>
<p>MyBatisConfig bean</p>
<div class="hljs code-wrapper"><pre><code>public class MybatisConfig &#123;

    @Bean
    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource)&#123;
        SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean();
        ssfb.setTypeAliasesPackage(&quot;com.opn.domain&quot;);
        ssfb.setDataSource(dataSource);
        return ssfb;
    &#125;

    @Bean
    public MapperScannerConfigurer mapperScannerConfigurer()&#123;
        MapperScannerConfigurer msc = new MapperScannerConfigurer();
        msc.setBasePackage(&quot;com.opn.mapper&quot;);
        return msc;
    &#125;
&#125;
</code></pre></div>
<p>使用/实现类</p>
<div class="hljs code-wrapper"><pre><code>public static void main(String[] args) &#123;

    ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);

    UserService userService = ctx.getBean(UserService.class);

    User user = userService.findByName(&quot;111&quot;);\

    System.out.println(user);
&#125;
</code></pre></div>
<h3 id="整合JUnit"><a href="#整合JUnit" class="headerlink" title="整合JUnit"></a>整合JUnit</h3><p>测试</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Fi4y1S7ix?p=30">https://www.bilibili.com/video/BV1Fi4y1S7ix?p=30</a></p>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>OOP<br>Object Oriented Programming<br>面向对象编程</p>
<p>AOP<br>Aspect Oriented Programming<br>面向切面编程<br>一种编程范式，指导开发者如何组织程序结构</p>
<ul>
<li>作用：  在不惊动原始设计/不改变原始代码的基础上，进行功能增强</li>
</ul>
<p>Spring理念—无入侵式/无侵入式</p>
<h3 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h3><p>连接点、切入点、通知、切面、通知类</p>
<p><img src="/2023/01/27/SSM/ssm-9.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>连接点 ( JoinPoint )：程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等</li>
</ul>
<p>在SpringAOP中，理解为方法的执行</p>
<ul>
<li>切入点（ Pointcut ) ：匹配连接点的式子</li>
</ul>
<p>在SpringAoP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法</p>
<ul>
<li>通知( Advice )：在切入点处执行的操作，也就是共性功能</li>
</ul>
<p>在SpringAOP中，功能最终以方法的形式呈现</p>
<ul>
<li>通知类：定义通知的类</li>
</ul>
<ul>
<li>切面( Aspect )︰描述通知与切入点的对应关系</li>
</ul>
<p>见解：</p>
<p>连接点—所有的方法</p>
<p>切入点—执行通知的方法</p>
<p>通知—在切入点处执行的操作，包含共性语句的方法</p>
<p>通知类—定义通知方法的类</p>
<p>切面—配置通知和切入点的关系</p>
<h3 id="AOP入门案例"><a href="#AOP入门案例" class="headerlink" title="AOP入门案例"></a>AOP入门案例</h3><ol>
<li><p>导入坐标</p>
</li>
<li><p>制造连接点方法(原始操作，Dao接口，实现类)</p>
</li>
<li><p>制造共性功能(通知类和通知)</p>
</li>
<li><p>定义切入点<br>切入点定义依托一个不具有实际意义的方法进行，即无参数，无返回值，方法体无实际逻辑</p>
</li>
<li><p>绑定切入点和通知关系，并指定通知添加到原始连接点的具体执行位置</p>
</li>
<li><p>@Aspect 定义通知类受Spring容器管理，并定义当前类为切面类</p>
</li>
<li><p>@EnableAspectJAutoProxy 开启spring对AOP注解驱动支持</p>
</li>
</ol>
<p>pom.xml</p>
<p>导入springframework自动导入aop相关包</p>
<div class="hljs code-wrapper"><pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
  &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
  &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
  &lt;version&gt;1.9.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre></div>
<p>接口、实现类</p>
<div class="hljs code-wrapper"><pre><code>public interface dao &#123;
    void save();
    void update();
&#125;

@Component()
public class daoimpl implements dao &#123;

    public void save() &#123;
        System.out.println(&quot;Start this is AOP ~~~~~~~~~~ &quot;);
        System.out.println(&quot;dao save&quot;);
    &#125;

    public void update() &#123;
        System.out.println(&quot;dao update&quot;);
    &#125;
&#125;
</code></pre></div>
<p>共性功能（通知和通知类）</p>
<p>@Component — Spring bean<br>@Aspect — 当AOP处理</p>
<p>定义切入点：<br>切入点定义依托一个不具有实际意义的方法进行，即无参数，无返回值，方法体无实际逻辑</p>
<div class="hljs code-wrapper"><pre><code>@Component
@Aspect
public class MyAdvice &#123;

    //定义切入点和共性功能

    @Pointcut(&quot;execution(void com.opn.dao.dao.update())&quot;)
    private void pp()&#123;&#125;

    //@Before告知在切入点前执行共性方法

    @Before(&quot;pp()&quot;)
    public void method()&#123;
        System.out.println(&quot;Start this is AOP ~~~~~~~~~~ &quot;);
    &#125;
&#125;
</code></pre></div>
<p>配置类</p>
<p>@EnableAspectJAutoProxy — 启动配置中的@Aspect</p>
<p>告知Spring存在AOP编程</p>
<div class="hljs code-wrapper"><pre><code>@Configuration
@ComponentScan(&quot;com.opn&quot;)
@EnableAspectJAutoProxy
public class SpringConfig &#123;
&#125;
</code></pre></div>
<p>实现</p>
<div class="hljs code-wrapper"><pre><code>    public static void main(String[] args) &#123;
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);

    dao ddd =  ctx.getBean(dao.class);

    ddd.save();

    ddd.update();
    &#125;
</code></pre></div>
<p>结果</p>
<div class="hljs code-wrapper"><pre><code>Start this is AOP ~~~~~~~~~~ 
dao save
Start this is AOP ~~~~~~~~~~ 
dao update
</code></pre></div>
<h3 id="AOP入门案例-—-编写的代码-实际进行的操作"><a href="#AOP入门案例-—-编写的代码-实际进行的操作" class="headerlink" title="AOP入门案例 — 编写的代码/实际进行的操作"></a>AOP入门案例 — 编写的代码/实际进行的操作</h3><ol>
<li>编写通知类</li>
<li>在Spring配置类添加@EnableAspectJAutoProxy注解</li>
</ol>
<p>通知类</p>
<p>定义切入点：<br>切入点定义依托一个不具有实际意义的方法进行，即无参数，无返回值，方法体无实际逻辑</p>
<div class="hljs code-wrapper"><pre><code>@Component  //Spring bean处理
@Aspect        //Spring AOP操作
public class MyAdvice &#123;            //定义通知类

    //定义切入点
    @Pointcut(&quot;execution(void com.opn.dao.dao.update())&quot;)
    private void pp()&#123;&#125;

    //定义共性方法，绑定切入点和共性功能
    //@Before告知在切入点前执行共性方法

    @Before(&quot;pp()&quot;)
    public void method()&#123;
        System.out.println(&quot;Start this is AOP ~~~~~~~~~~ &quot;);
    &#125;
&#125;
</code></pre></div>
<p>Spring配置类</p>
<div class="hljs code-wrapper"><pre><code>@Configuration
@ComponentScan(&quot;com.opn&quot;)
@EnableAspectJAutoProxy
public class SpringConfig &#123;
&#125;
</code></pre></div>
<h3 id="AOP工作流程"><a href="#AOP工作流程" class="headerlink" title="AOP工作流程"></a>AOP工作流程</h3><ol>
<li>Spring容器启动</li>
<li>读取所有切面配置中的切入点</li>
<li>初始化bean，判定bean对应的类中的方法是否匹配到任意切入点<br>匹配失败，创建对象<br>匹配成功，创建原始对象（目标对象）的代理对象  </li>
<li>获取bean执行方法<br>获取bean，调用方法并执行，完成操作<br>获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作</li>
</ol>
<p>SpringAOP本质:代理模式</p>
<h3 id="AOP核心概念-1"><a href="#AOP核心概念-1" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h3><p>目标对象（ Target ):原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的</p>
<p>代理（ Proxy )∶目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象实现</p>
<h3 id="AOP切入点表达式"><a href="#AOP切入点表达式" class="headerlink" title="AOP切入点表达式"></a>AOP切入点表达式</h3><p>切入点∶要进行增强的方法</p>
<p>切入点表达式︰要进行增强的方法的描述方式</p>
<h5 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h5><p>切入点表达式标准格式︰动作关键字（访问修饰符﹐返回值﹐包名.类/接口名.方法名（参数）异常名)</p>
<p>…</p>
<h5 id="描述方式一-描述接口方法"><a href="#描述方式一-描述接口方法" class="headerlink" title="描述方式一:描述接口方法"></a>描述方式一:描述接口方法</h5><p>执行com.opn.dao包下的Dao接口中的无参数update方法</p>
<div class="hljs code-wrapper"><pre><code>execution(void com.opn.dao.Dao.update())
</code></pre></div>
<h5 id="描述方式二-描述实现类方法"><a href="#描述方式二-描述实现类方法" class="headerlink" title="描述方式二:描述实现类方法"></a>描述方式二:描述实现类方法</h5><p>执行com.opn.dao.impl包下的DaoImpl类中的无参数update方法</p>
<div class="hljs code-wrapper"><pre><code>execution(void com.opn.dao.impl.DaoImpl.update())
</code></pre></div>
<h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><p>*︰单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现</p>
<p>必有一个参数</p>
<div class="hljs code-wrapper"><pre><code>execution(void com.opn.dao.Dao.*())
</code></pre></div>
<p>..:多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写</p>
<p>有或没有参数</p>
<div class="hljs code-wrapper"><pre><code>execution(void com.opn..*(..))
</code></pre></div>
<p>+∶专用于匹配子类类型</p>
<p>…</p>
<h5 id="书写技巧"><a href="#书写技巧" class="headerlink" title="书写技巧"></a>书写技巧</h5><p><img src="/2023/01/27/SSM/ssm-10.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="AOP通知类型"><a href="#AOP通知类型" class="headerlink" title="AOP通知类型"></a>AOP通知类型</h3><p>AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置</p>
<p>前置通知</p>
<p>后置通知</p>
<p>环绕通知（重点)</p>
<p>返回后通知（了解)</p>
<p>抛出异常后通知（了解)</p>
<p>前置</p>
<p>@Before()</p>
<p>后置</p>
<p>@After()</p>
<p>环绕</p>
<p>@Around()</p>
<p>原始方法无返回值</p>
<div class="hljs code-wrapper"><pre><code>@Around(&quot;pp()&quot;)
public void method(ProceedingJoinPoint pjp) throws Throwable &#123;
    System.out.println(&quot;Start this is AOP ~~~~~~~~~~ &quot;);

    //表示对原始操作的调用
    pjp.proceed();

    System.out.println(&quot;End this is AOP ~~~~~~~~~~ &quot;);
&#125;
</code></pre></div>
<p><img src="/2023/01/27/SSM/ssm-11.png" srcset="/img/loading.gif" lazyload></p>
<p>原始方法有返回值</p>
<div class="hljs code-wrapper"><pre><code>@Around(&quot;pp()&quot;)
public Object method(ProceedingJoinPoint pjp) throws Throwable &#123;
    System.out.println(&quot;Start this is AOP ~~~~~~~~~~ &quot;);

    //表示对原始操作的调用
    Object ret = pjp.proceed();

    System.out.println(&quot;End this is AOP ~~~~~~~~~~ &quot;);

    //返回原始方法的返回对象
    return ret;
&#125;
</code></pre></div>
<p>返回后通知/不抛出异常才通知</p>
<p>@AfterReturning()</p>
<p>抛出异常后通知</p>
<p>@AfterThrowing()</p>
<h3 id="AOP通知获取数据"><a href="#AOP通知获取数据" class="headerlink" title="AOP通知获取数据"></a>AOP通知获取数据</h3><p>@Before()、@After()、@AfterReturning()、@AfterThrowing()</p>
<div class="hljs code-wrapper"><pre><code>@Before(&quot;pp()&quot;)
public void method1(JoinPoint jp)&#123;
    Object[] args = jp.getArgs();
    System.out.println(Arrays.toString(args));
&#125;
</code></pre></div>
<p>@Around</p>
<div class="hljs code-wrapper"><pre><code>@Around(&quot;pp()&quot;)
public Object method(ProceedingJoinPoint pjp) throws Throwable &#123;

    Object[] args = pjp.getArgs();
    System.out.println(Arrays.toString(args));

    //可在此处理数据
    //args[0]=&quot;...&quot;;

    Object ret = pjp.proceed(args);

    return ret;
&#125;
</code></pre></div>
<h3 id="AOP总结"><a href="#AOP总结" class="headerlink" title="AOP总结"></a>AOP总结</h3><p>概念:AOP(Aspect Oriented Programming)面向切面编程，一种编程范式</p>
<p>作用:在不惊动原始设计的基础上为方法进行功能增强</p>
<p>核心概念</p>
<p>代理、连接点、切入点、通知、切面、目标对象</p>
<p>切入点表达式</p>
<p>通知类型</p>
<p>环绕通知</p>
<p>环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用</p>
<p>环绕通知可以隔离原始方法的调用执行</p>
<p>环绕通知返回值设置为0bject类型</p>
<p>环绕通知中可以对原始方法调用过程中出现的异常进行处理</p>
<p>获取切入点方法的参数</p>
<p>JoinPoint</p>
<p>获取切入点方法返回值</p>
<p>获取切入点方法运行异常信息</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务作用︰在数据层保障一系列的数据库操作同成功同失败</p>
<p>Spring事务作用∶在数据层或业务层保障一系列的数据库操作同成功同失败</p>
<p>PlatformTransactionManager 接口</p>
<p>DatasourceTransactionManager 实现类</p>
<h3 id="案例-账户转账业务"><a href="#案例-账户转账业务" class="headerlink" title="案例 账户转账业务"></a>案例 账户转账业务</h3><p>1、在业务层接口上添加Spring事务管理</p>
<p>2、设置事务管理器</p>
<p>3、开启注解式事件驱动</p>
<hr>
<p>1、在业务层接口上添加Spring事务管理</p>
<p>注解式事务可以添加到业务方法上表示当前方法开启事务，也可以添加到接口上表示当前接口所有方法开启事务</p>
<div class="hljs code-wrapper"><pre><code>public interface AccountService &#123;
    @Transactional
    public void transfer(String out,String in ,Integer money) ;
&#125;
</code></pre></div>
<p>2、设置事务管理器</p>
<p>在JdbcConfig中</p>
<div class="hljs code-wrapper"><pre><code>//配置事务管理器，mybatis使用的是jdbc事务
@Bean
public PlatformTransactionManager transactionManager(DataSource dataSource)&#123;
    DataSourceTransactionManager ptm = new DataSourceTransactionManager();
    ptm.setDataSource(dataSource);
    return ptm;
&#125;
</code></pre></div>
<p>3、开启注解式事件驱动</p>
<div class="hljs code-wrapper"><pre><code>@EnableTransactionManagement
</code></pre></div>
<h3 id="Spring事务角色"><a href="#Spring事务角色" class="headerlink" title="Spring事务角色"></a>Spring事务角色</h3><p>事务管理员:发起事务方，在Spring中通常指代业务层开启事务的方法</p>
<p>事务协调员︰加入事务方，在Spring中通常指代数据层方法，也可以是业务层方法</p>
<p>事务管理和JDBC用同一个datasource</p>
<h3 id="Spring事务属性"><a href="#Spring事务属性" class="headerlink" title="Spring事务属性"></a>Spring事务属性</h3><p><img src="/2023/01/27/SSM/ssm-16.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h3><p><img src="/2023/01/27/SSM/ssm-17.png" srcset="/img/loading.gif" lazyload></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/java-SSM/">java SSM</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/02/08/SSM-SpringMVC/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">SSM - SpringMVC</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/12/16/JavaWeb-Verification-code/">
                        <span class="hidden-mobile">JavaWeb--Verification code</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
<a href="http://www.beian.miit.gov.cn/"  style="color:#f72b07" target="_blank">苏ICP备2021015436号-1</a>
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
